<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <meta property="og:title" content="ZuriHac 2022" />
    <meta property="og:description"
        content="ZuriHac is a free annual haskell event brought to you by Â«ZÃ¼rich Friends of HaskellÂ»" />
    <meta property="og:image" content="https://zfoh.ch/images/zurihac2022/static.png" />


    <title>ZuriHac 2022</title>
    <link rel="icon" type="image/png" href="/images/favicon.png" />
    <link rel="stylesheet" type="text/css" href="/css/zurihac2022.css?v=4" />
    <style>
    </style>
  </head>
  <body>
    <header>
  <img src="/images/zurihac2022/logo.svg" alt="ZuriHac 2022">
</header>
<section>
  <details open>
    <summary>
      ðŸ¤” What is ZuriHac?
    </summary>
    <div class="content">
      <p>
        ZuriHac is the biggest <a href="https://haskell.org">Haskell</a> Hackathon
        in the world: a <strong>completely free</strong>, three-day grassroots
        coding festival organized by
        <a href="https://zfoh.ch/">ZÃ¼rich Friends of Haskell</a>.
        It features fantastic keynotes, hands-on tracks, and of course lots of
        hacking and socializing!
      </p>
      <p>
        ZuriHac takes place <strong>Saturday 11 June â€” Monday 13 June</strong>
        2022.  We are super excited that after two years as a virtual event,
        ZuriHac 2022 will return as a <strong>physical event</strong> at the
        <a href="https://www.ost.ch/en/university-of-applied-sciences/campus/rapperswil-jona-campus">beautiful
        Rapperswil-Jona campus of OST (formerly HSR)</a> located right
        next to lake ZÃ¼rich!
      <p>
    </div>
  </details>
</section>

<h1>Program</h1>
<section>
  <div class="tooltip">
    <p>
      ZuriHac is primarily a community event and a hackathon, rather than a
      conference.  Aside from the talks and tracks, attendees are encouraged to
      work together on all sorts of Haskell-related open-source projects and
      socialize!
    </p>
    <p>
      <a href="/zurihac2022/projects.html">Here is a list of projects
      participants are planning to work on</a> -- feel free to add your own!
    </p>
    <p>
      Due to the change in days, this year we're concentrating the talks in the
      weekend so there is a bit more time for hacking on Monday.
    </p>
  </div>
</section>

<div class="schedule" id="schedule">
  <table>
    <tr><th>Start              </th><th>End                </th><th>Kind    </th><th>Link                       </th><th>Title                                             </th></tr>
    <tr><td>2022-06-11T09:00:00</td><td>2022-06-11T10:00:00</td><td>admin   </td><td>                           </td><td>Registration Opens                                </td></tr>
    <tr><td>2022-06-11T10:00:00</td><td>2022-06-11T11:30:00</td><td>talk    </td><td>#speaker-gabriele-keller   </td><td>Opening Presentation &amp; Talk by Gabriele Keller</td></tr>
    <tr><td>2022-06-11T11:00:00</td><td>2022-06-11T15:00:00</td><td>food    </td><td>#food                      </td><td>Food Trucks                                       </td></tr>
    <tr><td>2022-06-11T12:00:00</td><td>2022-06-11T13:00:00</td><td>talk    </td><td>                           </td><td>Beginner Session                                  </td></tr>
    <tr><td>2022-06-11T13:30:00</td><td>2022-06-11T16:30:00</td><td>talk    </td><td>                           </td><td>Advanced Track by Well-Typed                      </td></tr>
    <tr><td>2022-06-11T17:00:00</td><td>2022-06-11T18:30:00</td><td>talk    </td><td>#speaker-alejandro-serrano </td><td>Program with Alejandro Serrano                    </td></tr>
    <tr><td>2022-06-11T18:00:00</td><td>2022-06-11T20:30:00</td><td>food    </td><td>#food                      </td><td>Barbecue                                          </td></tr>

    <tr><td>2022-06-12T10:00:00</td><td>2022-06-12T11:00:00</td><td>talk    </td><td>#speaker-simon-peyton-jones</td><td>Talk by Simon Peyton Jones                        </td></tr>
    <tr><td>2022-06-12T11:00:00</td><td>2022-06-12T15:00:00</td><td>food    </td><td>#food                      </td><td>Food Trucks                                       </td></tr>
    <tr><td>2022-06-12T11:30:00</td><td>2022-06-12T12:30:00</td><td>talk    </td><td>                           </td><td>Beginner Session                                  </td></tr>
    <tr><td>2022-06-12T13:30:00</td><td>2022-06-12T16:30:00</td><td>talk    </td><td>                           </td><td>Advanced Track by Well-Typed                      </td></tr>
    <tr><td>2022-06-12T17:00:00</td><td>2022-06-12T18:00:00</td><td>talk    </td><td>#speaker-andrew-lelechenko </td><td>Talk by Andrew Lelechenko                         </td></tr>
    <tr><td>2022-06-12T18:00:00</td><td>2022-06-12T20:30:00</td><td>food    </td><td>#food                      </td><td>Barbecue                                          </td></tr>

    <tr><td>2022-06-13T10:00:00</td><td>2022-06-13T11:30:00</td><td>talk    </td><td>#speaker-alejandro-serrano </td><td>Program with Alejandro Serrano                    </td></tr>
    <tr><td>2022-06-13T11:30:00</td><td>2022-06-13T13:00:00</td><td>food    </td><td>#food                      </td><td>Lunch at Mensa                                    </td></tr>
    <tr><td>2022-06-13T15:30:00</td><td>2022-06-13T17:00:00</td><td>admin   </td><td>                           </td><td>Project presentations                             </td></tr>
  </table>
</div>

<script type="text/JavaScript">
  // Generated by purs bundle 0.14.1
var PS = {};
(function(exports) {
  "use strict";

  exports.arrayApply = function (fs) {
    return function (xs) {
      var l = fs.length;
      var k = xs.length;
      var result = new Array(l*k);
      var n = 0;
      for (var i = 0; i < l; i++) {
        var f = fs[i];
        for (var j = 0; j < k; j++) {
          result[n++] = f(xs[j]);
        }
      }
      return result;
    };
  };
})(PS["Control.Apply"] = PS["Control.Apply"] || {});
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Control.Semigroupoid"] = $PS["Control.Semigroupoid"] || {};
  var exports = $PS["Control.Semigroupoid"];
  var Semigroupoid = function (compose) {
      this.compose = compose;
  };
  var semigroupoidFn = new Semigroupoid(function (f) {
      return function (g) {
          return function (x) {
              return f(g(x));
          };
      };
  });
  exports["semigroupoidFn"] = semigroupoidFn;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Control.Category"] = $PS["Control.Category"] || {};
  var exports = $PS["Control.Category"];
  var Control_Semigroupoid = $PS["Control.Semigroupoid"];                
  var Category = function (Semigroupoid0, identity) {
      this.Semigroupoid0 = Semigroupoid0;
      this.identity = identity;
  };
  var identity = function (dict) {
      return dict.identity;
  };
  var categoryFn = new Category(function () {
      return Control_Semigroupoid.semigroupoidFn;
  }, function (x) {
      return x;
  });
  exports["identity"] = identity;
  exports["categoryFn"] = categoryFn;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Data.Function"] = $PS["Data.Function"] || {};
  var exports = $PS["Data.Function"];
  var flip = function (f) {
      return function (b) {
          return function (a) {
              return f(a)(b);
          };
      };
  };
  var $$const = function (a) {
      return function (v) {
          return a;
      };
  };
  exports["flip"] = flip;
  exports["const"] = $$const;
})(PS);
(function(exports) {
  "use strict";

  exports.arrayMap = function (f) {
    return function (arr) {
      var l = arr.length;
      var result = new Array(l);
      for (var i = 0; i < l; i++) {
        result[i] = f(arr[i]);
      }
      return result;
    };
  };
})(PS["Data.Functor"] = PS["Data.Functor"] || {});
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Data.Functor"] = $PS["Data.Functor"] || {};
  var exports = $PS["Data.Functor"];
  var $foreign = $PS["Data.Functor"];                
  var Functor = function (map) {
      this.map = map;
  };
  var map = function (dict) {
      return dict.map;
  };                                                                                             
  var functorArray = new Functor($foreign.arrayMap);
  exports["Functor"] = Functor;
  exports["map"] = map;
  exports["functorArray"] = functorArray;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Control.Apply"] = $PS["Control.Apply"] || {};
  var exports = $PS["Control.Apply"];
  var $foreign = $PS["Control.Apply"];
  var Control_Category = $PS["Control.Category"];
  var Data_Function = $PS["Data.Function"];
  var Data_Functor = $PS["Data.Functor"];            
  var Apply = function (Functor0, apply) {
      this.Functor0 = Functor0;
      this.apply = apply;
  }; 
  var applyArray = new Apply(function () {
      return Data_Functor.functorArray;
  }, $foreign.arrayApply);
  var apply = function (dict) {
      return dict.apply;
  };
  var applySecond = function (dictApply) {
      return function (a) {
          return function (b) {
              return apply(dictApply)(Data_Functor.map(dictApply.Functor0())(Data_Function["const"](Control_Category.identity(Control_Category.categoryFn)))(a))(b);
          };
      };
  };
  exports["Apply"] = Apply;
  exports["apply"] = apply;
  exports["applySecond"] = applySecond;
  exports["applyArray"] = applyArray;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Control.Applicative"] = $PS["Control.Applicative"] || {};
  var exports = $PS["Control.Applicative"];
  var Control_Apply = $PS["Control.Apply"];          
  var Applicative = function (Apply0, pure) {
      this.Apply0 = Apply0;
      this.pure = pure;
  };
  var pure = function (dict) {
      return dict.pure;
  };
  var liftA1 = function (dictApplicative) {
      return function (f) {
          return function (a) {
              return Control_Apply.apply(dictApplicative.Apply0())(pure(dictApplicative)(f))(a);
          };
      };
  };
  exports["Applicative"] = Applicative;
  exports["pure"] = pure;
  exports["liftA1"] = liftA1;
})(PS);
(function(exports) {
  "use strict";

  exports.arrayBind = function (arr) {
    return function (f) {
      var result = [];
      for (var i = 0, l = arr.length; i < l; i++) {
        Array.prototype.push.apply(result, f(arr[i]));
      }
      return result;
    };
  };
})(PS["Control.Bind"] = PS["Control.Bind"] || {});
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Control.Bind"] = $PS["Control.Bind"] || {};
  var exports = $PS["Control.Bind"];
  var $foreign = $PS["Control.Bind"];
  var Control_Apply = $PS["Control.Apply"];          
  var Bind = function (Apply0, bind) {
      this.Apply0 = Apply0;
      this.bind = bind;
  }; 
  var bindArray = new Bind(function () {
      return Control_Apply.applyArray;
  }, $foreign.arrayBind);
  var bind = function (dict) {
      return dict.bind;
  };
  exports["Bind"] = Bind;
  exports["bind"] = bind;
  exports["bindArray"] = bindArray;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Control.Monad"] = $PS["Control.Monad"] || {};
  var exports = $PS["Control.Monad"];
  var Control_Applicative = $PS["Control.Applicative"];
  var Control_Bind = $PS["Control.Bind"];                
  var Monad = function (Applicative0, Bind1) {
      this.Applicative0 = Applicative0;
      this.Bind1 = Bind1;
  };
  var ap = function (dictMonad) {
      return function (f) {
          return function (a) {
              return Control_Bind.bind(dictMonad.Bind1())(f)(function (f$prime) {
                  return Control_Bind.bind(dictMonad.Bind1())(a)(function (a$prime) {
                      return Control_Applicative.pure(dictMonad.Applicative0())(f$prime(a$prime));
                  });
              });
          };
      };
  };
  exports["Monad"] = Monad;
  exports["ap"] = ap;
})(PS);
(function(exports) {
  "use strict";

  //------------------------------------------------------------------------------
  // Sorting ---------------------------------------------------------------------
  //------------------------------------------------------------------------------

  exports.sortByImpl = (function () {
    function mergeFromTo(compare, fromOrdering, xs1, xs2, from, to) {
      var mid;
      var i;
      var j;
      var k;
      var x;
      var y;
      var c;

      mid = from + ((to - from) >> 1);
      if (mid - from > 1) mergeFromTo(compare, fromOrdering, xs2, xs1, from, mid);
      if (to - mid > 1) mergeFromTo(compare, fromOrdering, xs2, xs1, mid, to);

      i = from;
      j = mid;
      k = from;
      while (i < mid && j < to) {
        x = xs2[i];
        y = xs2[j];
        c = fromOrdering(compare(x)(y));
        if (c > 0) {
          xs1[k++] = y;
          ++j;
        }
        else {
          xs1[k++] = x;
          ++i;
        }
      }
      while (i < mid) {
        xs1[k++] = xs2[i++];
      }
      while (j < to) {
        xs1[k++] = xs2[j++];
      }
    }

    return function (compare) {
      return function (fromOrdering) {
        return function (xs) {
          var out;

          if (xs.length < 2) return xs;

          out = xs.slice(0);
          mergeFromTo(compare, fromOrdering, out, xs.slice(0), 0, xs.length);

          return out;
        };
      };
    };
  })();
})(PS["Data.Array"] = PS["Data.Array"] || {});
(function(exports) {
  "use strict";

  exports.foldrArray = function (f) {
    return function (init) {
      return function (xs) {
        var acc = init;
        var len = xs.length;
        for (var i = len - 1; i >= 0; i--) {
          acc = f(xs[i])(acc);
        }
        return acc;
      };
    };
  };

  exports.foldlArray = function (f) {
    return function (init) {
      return function (xs) {
        var acc = init;
        var len = xs.length;
        for (var i = 0; i < len; i++) {
          acc = f(acc)(xs[i]);
        }
        return acc;
      };
    };
  };
})(PS["Data.Foldable"] = PS["Data.Foldable"] || {});
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Data.Monoid"] = $PS["Data.Monoid"] || {};
  var exports = $PS["Data.Monoid"];
  var mempty = function (dict) {
      return dict.mempty;
  };
  exports["mempty"] = mempty;
})(PS);
(function(exports) {
  "use strict";

  exports.concatArray = function (xs) {
    return function (ys) {
      if (xs.length === 0) return ys;
      if (ys.length === 0) return xs;
      return xs.concat(ys);
    };
  };
})(PS["Data.Semigroup"] = PS["Data.Semigroup"] || {});
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Data.Semigroup"] = $PS["Data.Semigroup"] || {};
  var exports = $PS["Data.Semigroup"];
  var $foreign = $PS["Data.Semigroup"];
  var Semigroup = function (append) {
      this.append = append;
  }; 
  var semigroupArray = new Semigroup($foreign.concatArray);
  var append = function (dict) {
      return dict.append;
  };
  exports["append"] = append;
  exports["semigroupArray"] = semigroupArray;
})(PS);
(function(exports) {
  "use strict";

  exports.unit = {};
})(PS["Data.Unit"] = PS["Data.Unit"] || {});
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Data.Unit"] = $PS["Data.Unit"] || {};
  var exports = $PS["Data.Unit"];
  var $foreign = $PS["Data.Unit"];
  exports["unit"] = $foreign.unit;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Data.Foldable"] = $PS["Data.Foldable"] || {};
  var exports = $PS["Data.Foldable"];
  var $foreign = $PS["Data.Foldable"];
  var Control_Applicative = $PS["Control.Applicative"];
  var Control_Apply = $PS["Control.Apply"];
  var Data_Function = $PS["Data.Function"];
  var Data_Monoid = $PS["Data.Monoid"];
  var Data_Semigroup = $PS["Data.Semigroup"];
  var Data_Unit = $PS["Data.Unit"];                
  var Foldable = function (foldMap, foldl, foldr) {
      this.foldMap = foldMap;
      this.foldl = foldl;
      this.foldr = foldr;
  };
  var foldr = function (dict) {
      return dict.foldr;
  };
  var traverse_ = function (dictApplicative) {
      return function (dictFoldable) {
          return function (f) {
              return foldr(dictFoldable)((function () {
                  var $313 = Control_Apply.applySecond(dictApplicative.Apply0());
                  return function ($314) {
                      return $313(f($314));
                  };
              })())(Control_Applicative.pure(dictApplicative)(Data_Unit.unit));
          };
      };
  };
  var for_ = function (dictApplicative) {
      return function (dictFoldable) {
          return Data_Function.flip(traverse_(dictApplicative)(dictFoldable));
      };
  };
  var foldl = function (dict) {
      return dict.foldl;
  }; 
  var foldMapDefaultR = function (dictFoldable) {
      return function (dictMonoid) {
          return function (f) {
              return foldr(dictFoldable)(function (x) {
                  return function (acc) {
                      return Data_Semigroup.append(dictMonoid.Semigroup0())(f(x))(acc);
                  };
              })(Data_Monoid.mempty(dictMonoid));
          };
      };
  };
  var foldableArray = new Foldable(function (dictMonoid) {
      return foldMapDefaultR(foldableArray)(dictMonoid);
  }, $foreign.foldlArray, $foreign.foldrArray);
  exports["foldl"] = foldl;
  exports["traverse_"] = traverse_;
  exports["for_"] = for_;
  exports["foldableArray"] = foldableArray;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Data.Maybe"] = $PS["Data.Maybe"] || {};
  var exports = $PS["Data.Maybe"];                 
  var Nothing = (function () {
      function Nothing() {

      };
      Nothing.value = new Nothing();
      return Nothing;
  })();
  var Just = (function () {
      function Just(value0) {
          this.value0 = value0;
      };
      Just.create = function (value0) {
          return new Just(value0);
      };
      return Just;
  })();
  var maybe = function (v) {
      return function (v1) {
          return function (v2) {
              if (v2 instanceof Nothing) {
                  return v;
              };
              if (v2 instanceof Just) {
                  return v1(v2.value0);
              };
              throw new Error("Failed pattern match at Data.Maybe (line 230, column 1 - line 230, column 51): " + [ v.constructor.name, v1.constructor.name, v2.constructor.name ]);
          };
      };
  };
  exports["Nothing"] = Nothing;
  exports["Just"] = Just;
  exports["maybe"] = maybe;
})(PS);
(function(exports) {
  "use strict";

  var unsafeCompareImpl = function (lt) {
    return function (eq) {
      return function (gt) {
        return function (x) {
          return function (y) {
            return x < y ? lt : x === y ? eq : gt;
          };
        };
      };
    };
  };                                         
  exports.ordIntImpl = unsafeCompareImpl;
  exports.ordNumberImpl = unsafeCompareImpl;
})(PS["Data.Ord"] = PS["Data.Ord"] || {});
(function(exports) {
  "use strict";

  var refEq = function (r1) {
    return function (r2) {
      return r1 === r2;
    };
  };                            
  exports.eqIntImpl = refEq;
  exports.eqNumberImpl = refEq;
  exports.eqStringImpl = refEq;
})(PS["Data.Eq"] = PS["Data.Eq"] || {});
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Data.Eq"] = $PS["Data.Eq"] || {};
  var exports = $PS["Data.Eq"];
  var $foreign = $PS["Data.Eq"];
  var Eq = function (eq) {
      this.eq = eq;
  }; 
  var eqString = new Eq($foreign.eqStringImpl);
  var eqNumber = new Eq($foreign.eqNumberImpl);
  var eqInt = new Eq($foreign.eqIntImpl);
  var eq = function (dict) {
      return dict.eq;
  };
  exports["Eq"] = Eq;
  exports["eq"] = eq;
  exports["eqInt"] = eqInt;
  exports["eqNumber"] = eqNumber;
  exports["eqString"] = eqString;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Data.Ordering"] = $PS["Data.Ordering"] || {};
  var exports = $PS["Data.Ordering"];              
  var LT = (function () {
      function LT() {

      };
      LT.value = new LT();
      return LT;
  })();
  var GT = (function () {
      function GT() {

      };
      GT.value = new GT();
      return GT;
  })();
  var EQ = (function () {
      function EQ() {

      };
      EQ.value = new EQ();
      return EQ;
  })();
  exports["LT"] = LT;
  exports["GT"] = GT;
  exports["EQ"] = EQ;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Data.Ord"] = $PS["Data.Ord"] || {};
  var exports = $PS["Data.Ord"];
  var $foreign = $PS["Data.Ord"];
  var Data_Eq = $PS["Data.Eq"];
  var Data_Ordering = $PS["Data.Ordering"];
  var Ord = function (Eq0, compare) {
      this.Eq0 = Eq0;
      this.compare = compare;
  }; 
  var ordNumber = new Ord(function () {
      return Data_Eq.eqNumber;
  }, $foreign.ordNumberImpl(Data_Ordering.LT.value)(Data_Ordering.EQ.value)(Data_Ordering.GT.value));
  var ordInt = new Ord(function () {
      return Data_Eq.eqInt;
  }, $foreign.ordIntImpl(Data_Ordering.LT.value)(Data_Ordering.EQ.value)(Data_Ordering.GT.value));
  var compare = function (dict) {
      return dict.compare;
  };
  var comparing = function (dictOrd) {
      return function (f) {
          return function (x) {
              return function (y) {
                  return compare(dictOrd)(f(x))(f(y));
              };
          };
      };
  };
  var greaterThanOrEq = function (dictOrd) {
      return function (a1) {
          return function (a2) {
              var v = compare(dictOrd)(a1)(a2);
              if (v instanceof Data_Ordering.LT) {
                  return false;
              };
              return true;
          };
      };
  };
  var lessThanOrEq = function (dictOrd) {
      return function (a1) {
          return function (a2) {
              var v = compare(dictOrd)(a1)(a2);
              if (v instanceof Data_Ordering.GT) {
                  return false;
              };
              return true;
          };
      };
  };
  var max = function (dictOrd) {
      return function (x) {
          return function (y) {
              var v = compare(dictOrd)(x)(y);
              if (v instanceof Data_Ordering.LT) {
                  return y;
              };
              if (v instanceof Data_Ordering.EQ) {
                  return x;
              };
              if (v instanceof Data_Ordering.GT) {
                  return x;
              };
              throw new Error("Failed pattern match at Data.Ord (line 176, column 3 - line 179, column 12): " + [ v.constructor.name ]);
          };
      };
  };
  var min = function (dictOrd) {
      return function (x) {
          return function (y) {
              var v = compare(dictOrd)(x)(y);
              if (v instanceof Data_Ordering.LT) {
                  return x;
              };
              if (v instanceof Data_Ordering.EQ) {
                  return x;
              };
              if (v instanceof Data_Ordering.GT) {
                  return y;
              };
              throw new Error("Failed pattern match at Data.Ord (line 167, column 3 - line 170, column 12): " + [ v.constructor.name ]);
          };
      };
  };
  exports["Ord"] = Ord;
  exports["compare"] = compare;
  exports["lessThanOrEq"] = lessThanOrEq;
  exports["greaterThanOrEq"] = greaterThanOrEq;
  exports["comparing"] = comparing;
  exports["min"] = min;
  exports["max"] = max;
  exports["ordInt"] = ordInt;
  exports["ordNumber"] = ordNumber;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Data.Array"] = $PS["Data.Array"] || {};
  var exports = $PS["Data.Array"];
  var $foreign = $PS["Data.Array"];
  var Control_Bind = $PS["Control.Bind"];
  var Control_Category = $PS["Control.Category"];
  var Data_Foldable = $PS["Data.Foldable"];
  var Data_Function = $PS["Data.Function"];
  var Data_Maybe = $PS["Data.Maybe"];
  var Data_Ord = $PS["Data.Ord"];
  var Data_Ordering = $PS["Data.Ordering"];
  var sortBy = function (comp) {
      return $foreign.sortByImpl(comp)(function (v) {
          if (v instanceof Data_Ordering.GT) {
              return 1;
          };
          if (v instanceof Data_Ordering.EQ) {
              return 0;
          };
          if (v instanceof Data_Ordering.LT) {
              return -1 | 0;
          };
          throw new Error("Failed pattern match at Data.Array (line 831, column 31 - line 834, column 11): " + [ v.constructor.name ]);
      });
  };
  var sortWith = function (dictOrd) {
      return function (f) {
          return sortBy(Data_Ord.comparing(dictOrd)(f));
      };
  };
  var singleton = function (a) {
      return [ a ];
  };                                                           
  var foldl = Data_Foldable.foldl(Data_Foldable.foldableArray);
  var concatMap = Data_Function.flip(Control_Bind.bind(Control_Bind.bindArray));
  var mapMaybe = function (f) {
      return concatMap((function () {
          var $109 = Data_Maybe.maybe([  ])(singleton);
          return function ($110) {
              return $109(f($110));
          };
      })());
  };
  var catMaybes = mapMaybe(Control_Category.identity(Control_Category.categoryFn));
  exports["mapMaybe"] = mapMaybe;
  exports["catMaybes"] = catMaybes;
  exports["foldl"] = foldl;
  exports["sortWith"] = sortWith;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Data.Boolean"] = $PS["Data.Boolean"] || {};
  var exports = $PS["Data.Boolean"];
  var otherwise = true;
  exports["otherwise"] = otherwise;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Data.Generic.Rep"] = $PS["Data.Generic.Rep"] || {};
  var exports = $PS["Data.Generic.Rep"];             
  var Inl = (function () {
      function Inl(value0) {
          this.value0 = value0;
      };
      Inl.create = function (value0) {
          return new Inl(value0);
      };
      return Inl;
  })();
  var Inr = (function () {
      function Inr(value0) {
          this.value0 = value0;
      };
      Inr.create = function (value0) {
          return new Inr(value0);
      };
      return Inr;
  })();
  var Product = (function () {
      function Product(value0, value1) {
          this.value0 = value0;
          this.value1 = value1;
      };
      Product.create = function (value0) {
          return function (value1) {
              return new Product(value0, value1);
          };
      };
      return Product;
  })();
  var Generic = function (from, to) {
      this.from = from;
      this.to = to;
  };
  var from = function (dict) {
      return dict.from;
  };
  exports["Generic"] = Generic;
  exports["from"] = from;
  exports["Inl"] = Inl;
  exports["Inr"] = Inr;
  exports["Product"] = Product;
})(PS);
(function(exports) {
  // This Source Code Form is subject to the terms of the Mozilla Public
  // License, v. 2.0. If a copy of the MPL was not distributed with this
  // file, You can obtain one at http://mozilla.org/MPL/2.0/.

  "use strict";

  /** @constructor */
  function MapNode(datamap, nodemap, content) {
      this.datamap = datamap;
      this.nodemap = nodemap;
      this.content = content;
  }

  MapNode.prototype.lookup = function lookup(Nothing, Just, keyEquals, key, keyHash, shift) {
      var bit = mask(keyHash, shift);
      if ((this.datamap & bit) !== 0) {
          var i = index(this.datamap, bit);
          if (keyEquals(key)(this.content[i * 2]))
              return new Just(this.content[i * 2 + 1]);
          return Nothing;
      }
      if ((this.nodemap & bit) !== 0) {
          return this.content[this.content.length - 1 - index(this.nodemap, bit)].lookup(Nothing, Just, keyEquals, key, keyHash, shift + 5);
      }
      return Nothing;
  }

  function remove2insert1Mut(a, removeIndex, insertIndex, v1) {
      for (var i = removeIndex; i < insertIndex; i++) a[i] = a[i+2];
      a[i++] = v1;
      for (; i < a.length - 1; i++) a[i] = a[i+1];
      a.length = a.length - 1;
  }

  MapNode.prototype.insertMut = function insertMut(keyEquals, hashFunction, key, keyHash, value, shift) {
      var bit = mask(keyHash, shift);
      var i = index(this.datamap, bit);
      if ((this.datamap & bit) !== 0) {
          var k = this.content[i * 2];
          if (keyEquals(k)(key)) {
              this.content[i*2+1] = value;
          } else {
              var newNode = binaryNode(k, hashFunction(k), this.content[i*2+1], key, keyHash, value, shift + 5);
              this.datamap = this.datamap ^ bit;
              this.nodemap = this.nodemap | bit;
              remove2insert1Mut(this.content, i*2, this.content.length - index(this.nodemap, bit) - 2, newNode);
          }
      } else if ((this.nodemap & bit) !== 0) {
          var n = this.content.length - 1 - index(this.nodemap, bit);
          this.content[n].insertMut(keyEquals, hashFunction, key, keyHash, value, shift + 5);
      } else {
          this.datamap = this.datamap | bit;
          this.content.splice(i*2, 0, key, value);
      }
  }

  MapNode.prototype.insert = function insert(keyEquals, hashFunction, key, keyHash, value, shift) {
      var bit = mask(keyHash, shift);
      var i = index(this.datamap, bit);
      if ((this.datamap & bit) !== 0) {
          var k = this.content[i * 2];
          if (keyEquals(k)(key))
              return new MapNode(this.datamap, this.nodemap, overwriteTwoElements(this.content, i*2, key, value));
          var newNode = binaryNode(k, hashFunction(k), this.content[i*2+1], key, keyHash, value, shift + 5);
          return new MapNode(this.datamap ^ bit, this.nodemap | bit, remove2insert1(this.content, i * 2, this.content.length - index(this.nodemap, bit) - 2, newNode));
      }
      if ((this.nodemap & bit) !== 0) {
          var n = this.content.length - 1 - index(this.nodemap, bit);
          return new MapNode(this.datamap, this.nodemap,
                             copyAndOverwriteOrExtend1(this.content, n,
                                              this.content[n].insert(keyEquals, hashFunction, key, keyHash, value, shift + 5)));
      }
      return new MapNode(this.datamap | bit, this.nodemap, insert2(this.content, i*2, key, value));
  }

  MapNode.prototype.insertWith = function insertWith(keyEquals, hashFunction, f, key, keyHash, value, shift) {
      var bit = mask(keyHash, shift);
      var i = index(this.datamap, bit);
      if ((this.datamap & bit) !== 0) {
          var k = this.content[i * 2];
          if (keyEquals(k)(key))
              return new MapNode(this.datamap, this.nodemap, overwriteTwoElements(this.content, i*2, key, f(this.content[i*2+1])(value)));
          var newNode = binaryNode(k, hashFunction(k), this.content[i*2+1], key, keyHash, value, shift + 5);
          return new MapNode(this.datamap ^ bit, this.nodemap | bit, remove2insert1(this.content, i * 2, this.content.length - index(this.nodemap, bit) - 2, newNode));
      }
      if ((this.nodemap & bit) !== 0) {
          var n = this.content.length - 1 - index(this.nodemap, bit);
          return new MapNode(this.datamap, this.nodemap,
                             copyAndOverwriteOrExtend1(this.content, n,
                                              this.content[n].insertWith(keyEquals, hashFunction, f, key, keyHash, value, shift + 5)));
      }
      return new MapNode(this.datamap | bit, this.nodemap, insert2(this.content, i*2, key, value));
  }

  MapNode.prototype.delet = function delet(keyEquals, key, keyHash, shift) {
      var bit = mask(keyHash, shift);
      if ((this.datamap & bit) !== 0) {
          var dataIndex = index(this.datamap, bit);
          if (keyEquals(this.content[dataIndex*2])(key)) {
              if (this.nodemap === 0 && this.content.length === 2) return empty;
              return new MapNode(this.datamap ^ bit, this.nodemap, remove2(this.content, dataIndex * 2));
          }
          return this;
      }
      if ((this.nodemap & bit) !== 0) {
          var nodeIndex = index(this.nodemap,bit);
          var recNode = this.content[this.content.length - 1 - nodeIndex];
          var recRes = recNode.delet(keyEquals, key, keyHash, shift + 5);
          if (recNode === recRes) return this;
          if (recRes.isSingleton()) {
              if (this.content.length === 1) {
                  recRes.datamap = this.nodemap;
                  return recRes;
              }
              return new MapNode(this.datamap | bit, this.nodemap ^ bit,
                                 insert2remove1(this.content, 2 * index(this.datamap, bit), recRes.content[0], recRes.content[1], this.content.length - 1 - nodeIndex));
          }
          return new MapNode(this.datamap, this.nodemap, copyAndOverwriteOrExtend1(this.content, this.content.length - 1 - nodeIndex, recRes));
      }
      return this;
  }

  MapNode.prototype.toArrayBy = function (f, res) {
      for (var i = 0; i < popCount(this.datamap) * 2;) {
          var k = this.content[i++];
          var v = this.content[i++];
          res.push(f(k)(v));
      }
      for (; i < this.content.length; i++)
          this.content[i].toArrayBy(f, res);
  }

  MapNode.prototype.isSingleton = function () {
      return this.nodemap === 0 && this.content.length === 2;
  }

  MapNode.prototype.eq = function(kf, vf, that) {
      if (this === that) return true;
      if (this.constructor !== that.constructor || this.nodemap !== that.nodemap || this.datamap !== that.datamap) return false;
      for (var i = 0; i < popCount(this.datamap) * 2;) {
          if (kf(this.content[i])(that.content[i])) i++; else return false;
          if (vf(this.content[i])(that.content[i])) i++; else return false;
      }
      for (; i < this.content.length; i++)
          if (!this.content[i].eq(kf, vf, that.content[i])) return false;
      return true;
  }

  MapNode.prototype.hash = function (vhash) {
      var h = this.datamap;
      for (var i = 0; i < popCount(this.datamap); i++)
          h = (h * 31 + vhash(this.content[i * 2 + 1])) | 0;
      for (var j = 0; j < popCount(this.nodemap); j++)
          h = (h * 31 + this.content[this.content.length - j - 1].hash(vhash)) | 0;
      return h;
  }

  MapNode.prototype.size = function () {
      var res = popCount(this.datamap);
      for (var i = res * 2; i < this.content.length; i++) res += this.content[i].size();
      return res;
  }

  MapNode.prototype.imap = function (f) {
      var newContent = this.content.slice();
      for (var i = 0; i < popCount(this.datamap) * 2;) {
          var k = this.content[i++];
          var v = this.content[i++];
          newContent[i-2] = k;
          newContent[i-1] = f(k)(v);
      }
      for (; i < this.content.length; i++)
          newContent[i] = this.content[i].imap(f);
      return new MapNode(this.datamap, this.nodemap, newContent);
  }

  MapNode.prototype.ifoldMap = function (m, mappend, f) {
      for (var i = 0; i < popCount(this.datamap) * 2;) {
          var k = this.content[i++];
          var v = this.content[i++];
          m = mappend(m)(f(k)(v));
      }
      for (; i < this.content.length; i++)
          m = this.content[i].ifoldMap(m, mappend, f);
      return m;
  }

  function lowestBit(n) { return n & -n; }

  function mergeState(bit, thisnode, thisdata, thatnode, thatdata) {
      /* Returns one of these constants:

       const NONE_NONE = 0;
       const NODE_NONE = 1;
       const DATA_NONE = 2;
       const NONE_NODE = 4;
       const NONE_DATA = 8;
       const DATA_NODE = DATA_NONE | NONE_NODE;
       const NODE_DATA = NODE_NONE | NONE_DATA;
       const DATA_DATA = DATA_NONE | NONE_DATA;
       const NODE_NODE = NODE_NONE | NONE_NODE;

       I would love to declare them in the file, but purs compile
       complains about `const` and purs bundle removes variables.
    */  

      var state = 0;
      state |= (bit & thisnode) !== 0 ? 1 : 0;
      state |= (bit & thisdata) !== 0 ? 2 : 0;
      state |= (bit & thatnode) !== 0 ? 4 : 0;
      state |= (bit & thatdata) !== 0 ? 8 : 0;
      return state;
  }

  MapNode.prototype.unionWith = function (eq, hash, f, that, shift) {
      if (this.constructor !== that.constructor)
          throw "Trying to union a MapNode with something else";

      // I'd rather declare these locally in the branches, but purs
      // compile complains about `const`.
      var thisDataIndex, thatDataIndex, thisNodeIndex, thatNodeIndex;

      var datamap = 0;
      var nodemap = 0;
      var data = [];
      var nodes = [];

      // Conceptually, we go through all of the 32 bits in the result
      // and then handle the (in/notin + left/right + data/node)
      // combinations. With this clever trick, we get to skip the 0 bits.
      var skipmap = this.datamap | this.nodemap | that.datamap | that.nodemap;
      while (skipmap !== 0) {
          var bit = lowestBit(skipmap);
          skipmap &= ~bit;

          switch (mergeState(bit, this.nodemap, this.datamap, that.nodemap, that.datamap)) {
          case 1 /* NODE_NONE */:
              thisNodeIndex = index(this.nodemap, bit);
              nodemap |= bit;
              nodes.push(this.content[this.content.length - thisNodeIndex - 1]);
              break;
          case 2 /* DATA_NONE */:
              thisDataIndex = index(this.datamap, bit);
              datamap |= bit;
              data.push(this.content[thisDataIndex * 2], this.content[thisDataIndex * 2 + 1]);
              break;
          case 4 /* NONE_NODE */:
              thatNodeIndex = index(that.nodemap, bit);
              nodemap |= bit;
              nodes.push(that.content[that.content.length - thatNodeIndex - 1]);
              break;
          case 5 /* NODE_NODE */:
              thisNodeIndex = index(this.nodemap, bit);
              thatNodeIndex = index(that.nodemap, bit);
              nodemap |= bit;
              nodes.push(
                  this.content[this.content.length - thisNodeIndex - 1].
                       unionWith(eq, hash, f, that.content[that.content.length - thatNodeIndex - 1], shift + 5));
              break;
          case 6 /* DATA_NODE */:
              thisDataIndex = index(this.datamap, bit);
              thatNodeIndex = index(that.nodemap, bit);
              var k = this.content[thisDataIndex * 2];
              var v = this.content[thisDataIndex * 2 + 1];
              var hk = hash(k);
              var flippedF = function (a) { return function (b) { return f(b)(a); }; };
              nodemap |= bit;
              nodes.push(that.content[that.content.length - thatNodeIndex - 1].insertWith(eq, hash, flippedF, k, hk, v, shift + 5));
              break;
          case 8 /* NONE_DATA */:
              thatDataIndex = index(that.datamap, bit);
              datamap |= bit;
              data.push(that.content[thatDataIndex * 2], that.content[thatDataIndex * 2 + 1]);
              break;
          case 9 /* NODE_DATA */:
              thatDataIndex = index(that.datamap, bit);
              thisNodeIndex = index(this.nodemap, bit);
              var k = that.content[thatDataIndex * 2];
              var v = that.content[thatDataIndex * 2 + 1];
              var hk = hash(k);
              nodemap |= bit;
              nodes.push(this.content[this.content.length - thisNodeIndex - 1].insertWith(eq, hash, f, k, hk, v, shift + 5));
              break;
          case 10 /* DATA_DATA */:
              thisDataIndex = index(this.datamap, bit);
              thatDataIndex = index(that.datamap, bit);
              if (eq(this.content[thisDataIndex * 2])(that.content[thatDataIndex * 2])) {
                  // equal, merge with f
                  datamap |= bit;
                  data.push(this.content[thisDataIndex * 2], f(this.content[thisDataIndex * 2 + 1])(that.content[thatDataIndex * 2 + 1]));
              } else {
                  // key hashes equal at this level, merge into node
                  nodemap |= bit;
                  nodes.push(binaryNode(
                      this.content[thisDataIndex * 2],
                      hash(this.content[thisDataIndex * 2]),
                      this.content[thisDataIndex*2+1],
                      that.content[thatDataIndex * 2],
                      hash(that.content[thatDataIndex * 2]),
                      that.content[thatDataIndex*2+1],
                      shift + 5));
              }
              break;
          }
      }
      return new MapNode(datamap, nodemap, data.concat(nodes.reverse()));
  }

  MapNode.prototype.intersectionWith = function (Nothing, Just, eq, hash, f, that, shift) {
      if (this.constructor !== that.constructor)
          throw "Trying to intersect a MapNode with something else";

      // I'd rather declare these locally in the branches, but purs
      // compile complains about `const`.
      var thisDataIndex, thatDataIndex, thisNodeIndex, thatNodeIndex;

      var datamap = 0;
      var nodemap = 0;
      var data = [];
      var nodes = [];

      // Conceptually, we go through all of the 32 bits in the result
      // and then handle the (in/notin + left/right + data/node)
      // combinations. With this clever trick, we get to skip the 0 bits.
      var skipmap = (this.datamap | this.nodemap) & (that.datamap | that.nodemap);
      while (skipmap !== 0) {
          var bit = lowestBit(skipmap);
          skipmap &= ~bit;

          switch (mergeState(bit, this.nodemap, this.datamap, that.nodemap, that.datamap)) {
          case 5 /* NODE_NODE */:
              thisNodeIndex = index(this.nodemap, bit);
              thatNodeIndex = index(that.nodemap, bit);
              var recRes = this.content[this.content.length - thisNodeIndex - 1].
                   intersectionWith(Nothing, Just, eq, hash, f, that.content[that.content.length - thatNodeIndex - 1], shift + 5);
              if (isEmpty(recRes)) continue;
              if (recRes.isSingleton()) {
                  datamap |= bit;
                  data.push(recRes.content[0], recRes.content[1]);
              } else {
                  nodemap |= bit;
                  nodes.push(recRes);
              }
              break;
          case 6 /* DATA_NODE */:
              thisDataIndex = index(this.datamap, bit);
              thatNodeIndex = index(that.nodemap, bit);
              var k = this.content[thisDataIndex * 2];
              var v = this.content[thisDataIndex * 2 + 1];
              var hk = hash(k);
              var res = that.content[that.content.length - thatNodeIndex - 1].lookup(Nothing, Just, eq, k, hk, shift + 5);
              if (res !== Nothing) {
                  datamap |= bit;
                  data.push(k, f(v)(res.value0));
              }
              break;
          case 9 /* NODE_DATA */:
              thatDataIndex = index(that.datamap, bit);
              thisNodeIndex = index(this.nodemap, bit);
              var k = that.content[thatDataIndex * 2];
              var v = that.content[thatDataIndex * 2 + 1];
              var hk = hash(k);
              var res = this.content[this.content.length - thisNodeIndex - 1].lookup(Nothing, Just, eq, k, hk, shift + 5);
              if (res !== Nothing) {
                  datamap |= bit;
                  data.push(k, f(res.value0)(v));
              }
              break;
          case 10 /* DATA_DATA */:
              thisDataIndex = index(this.datamap, bit);
              thatDataIndex = index(that.datamap, bit);
              if (eq(this.content[thisDataIndex * 2])(that.content[thatDataIndex * 2])) {
                  datamap |= bit;
                  data.push(this.content[thisDataIndex * 2], f(this.content[thisDataIndex * 2 + 1])(that.content[thatDataIndex * 2 + 1]));
              }
              break;
          }
      }
      return new MapNode(datamap, nodemap, data.concat(nodes.reverse()));
  }

  MapNode.prototype.filterWithKey = function filterWithKey(f) {
      var datamap = 0;
      var nodemap = 0;
      var data = [];
      var nodes = [];
      var skipmap = this.datamap | this.nodemap;
      while (skipmap !== 0) {
          var bit = lowestBit(skipmap);
          skipmap &= ~bit;
          if ((this.datamap & bit) !== 0) {
              var dataIndex = index(this.datamap, bit);
              var k = this.content[dataIndex * 2];
              var v = this.content[dataIndex * 2 + 1];
              if (f(k)(v)) {
                  datamap |= bit;
                  data.push(k, v);
              }
          } else { // assert (this.nodemap & bit) !== 0
              var nodeIndex = index(this.nodemap, bit);
              var node = this.content[this.content.length - nodeIndex - 1].filterWithKey(f);
              if (isEmpty(node)) continue;
              if (node.isSingleton()) {
                  datamap |= bit;
                  data.push(node.content[0], node.content[1]);
              } else {
                  nodemap |= bit;
                  nodes.push(node);
              }
          }
      }
      return new MapNode(datamap, nodemap, data.concat(nodes.reverse()));
  }

  // This builds an n-ary curried function that takes all values and all
  // subnodes as arguments and places them in a copy of the hashmap
  // preserving the keys, datamap, and nodemap. Basically, a (Hashmap k
  // v) with s key-value pairs and t nodes turns into a function:
  //
  // k_0 -> .. -> k_s -> HashMap_0 k v -> .. -> HashMap_t k v -> HashMap k v
  //
  // Indices here are to be understood as count.
  //
  // The main use for this is the as the partial hashmap constructor in
  // place of the hole in this concept of an implementation of
  // traverseWithKey:
  //
  // pure ?here <*> f k1 v1 <*> f k2 v2 <*> traverseWithKey f n1 <*> traverseWithKey f n2
  MapNode.prototype.travHelper = function () {
      // TODO could have two helpers that basically switch mode from
      // setting values to setting nodes. That way branches would be
      // more predictable. Because the value branch is essentially
      // unpredictable.
      function go(vi, vm, ni, nm, copy) {
          if (vi < vm)
              return function (v) {
                  return go(vi + 1, vm, ni, nm, function () { var res = copy();
                                                              res.content[vi * 2 + 1] = v;
                                                              return res;
                                                            });
              }
          if (ni < nm)
              return function (n) {
                  return go(vi, vm, ni+1, nm, function () { var res = copy();
                                                            // order of parameters must match stored order
                                                            res.content[vm*2 + ni] = n;
                                                            return res;
                                                          });
              }
          return copy();
      }
      var vm = popCount(this.datamap);
      var self = this;
      return go(0, vm, 0, this.content.length - vm * 2, function () { return new MapNode(self.datamap, self.nodemap, self.content.slice()); });
  }

  MapNode.prototype.ifoldMap = function (m, mappend, f) {
      for (var i = 0; i < popCount(this.datamap) * 2;) {
          var k = this.content[i++];
          var v = this.content[i++];
          m = mappend(m)(f(k)(v));
      }
      for (; i < this.content.length; i++)
          m = this.content[i].ifoldMap(m, mappend, f);
      return m;
  }

  MapNode.prototype.itraverse = function (pure, apply, f) {
      var m = pure(this.travHelper());
      for (var i = 0; i < popCount(this.datamap) * 2;) {
          var k = this.content[i++];
          var v = this.content[i++];
          m = apply(m)(f(k)(v));
      }
      for (; i < this.content.length; i++)
          m = apply(m)(this.content[i].itraverse(pure, apply, f));
      return m;
  }

  /** @constructor */
  function Collision(keys, values) {
      this.keys = keys;
      this.values = values;
  }

  Collision.prototype.lookup = function collisionLookup(Nothing, Just, keyEquals, key, keyHash, shift) {
      for (var i = 0; i < this.keys.length; i++)
          if (keyEquals(key)(this.keys[i]))
              return new Just(this.values[i]);
      return Nothing;
  };

  Collision.prototype.insert = function collisionInsert(keyEquals, hashFunction, key, keyHash, value, shift) {
      var i = 0;
      for (; i < this.keys.length; i++)
          if (keyEquals(key)(this.keys[i]))
              break;
      return new Collision(copyAndOverwriteOrExtend1(this.keys, i, key),
                           copyAndOverwriteOrExtend1(this.values, i, value));
  };

  Collision.prototype.insertMut = function collisionInsertMut(keyEquals, hashFunction, key, keyHash, value, shift) {
      var i = 0;
      for (; i < this.keys.length; i++)
          if (keyEquals(key)(this.keys[i]))
              break;
      // i may be *after* the last element, if the key is not already in the map
      this.keys[i] = key;
      this.values[i] = value;
  };

  Collision.prototype.insertWith = function collisionInsert(keyEquals, hashFunction, f, key, keyHash, value, shift) {
      var i = 0;
      for (; i < this.keys.length; i++)
          if (keyEquals(key)(this.keys[i]))
              return new Collision(copyAndOverwriteOrExtend1(this.keys, i, key),
                                   copyAndOverwriteOrExtend1(this.values, i, f(this.values[i])(value)));
      return new Collision(copyAndOverwriteOrExtend1(this.keys, i, key),
                           copyAndOverwriteOrExtend1(this.values, i, value));
  };

  Collision.prototype.delet = function collisionDelete(keyEquals, key, keyHash, shift) {
      var i = 0;
      for (; i < this.keys.length; i++)
          if (keyEquals(key)(this.keys[i]))
              break;
      if (i === this.keys.length) return this;
      if (this.keys.length === 2)
          return new MapNode(1 << (keyHash & 31), 0, [this.keys[1 - i], this.values[1 - i]]);
      return new Collision(remove1(this.keys, i), remove1(this.values, i));
  }

  Collision.prototype.toArrayBy = function (f, res) {
      for (var i = 0; i < this.keys.length; i++)
          res.push(f(this.keys[i])(this.values[i]));
  }

  Collision.prototype.isSingleton = function () { return false; }

  Collision.prototype.eq = function(kf, vf, that) {
      if (this.constructor !== that.constructor || this.keys.length !== that.keys.length) return false;
      outer:
      for (var i = 0; i < this.keys.length; i++) {
          for (var j = 0; j < that.keys.length; j++) {
              if (kf(this.keys[i])(that.keys[j])) {
                  if (vf(this.values[i])(that.values[j]))
                      continue outer;
                  else
                      return false;
              }
          }
      }
      return true;
  }

  Collision.prototype.hash = function (vhash) {
      // We ignore keys because they have all the same hash anyways
      // (we're in a collision node!)
      var h = 0;
      // We use just + here, not multiply&add, because order in
      // collision nodes is undefined. A commutative combining operation
      // allows us to simply ignore the order.
      for (var i = 0; i < this.values.length; i++)
          h += vhash(this.values[i]);
      return h;
  }

  Collision.prototype.size = function () {
      return this.keys.length;
  }

  Collision.prototype.imap = function (f) {
      var newValues = this.values.slice();
      for (var i = 0; i < this.values.length; i++)
          newValues[i] = f(this.keys[i])(this.values[i]);
      return new Collision(this.keys, newValues);
  }

  Collision.prototype.ifoldMap = function (m, mappend, f) {
      for (var i = 0; i < this.keys.length; i++)
          m = mappend(m)(f(this.keys[i])(this.values[i]));
      return m;
  }

  Collision.prototype.travHelper = function () {
      function go(i, m, copy) {
          if (i < m)
              return function (v) {
                  return go(i + 1, m, function () { var res = copy();
                                                    res.values[i] = v;
                                                    return res;
                                                  });
              }
          return copy();
      }
      var self = this;
      return go(0, this.keys.length, function () { return new Collision(self.keys, self.values.slice()); });
  }

  Collision.prototype.itraverse = function (pure, apply, f) {
      var m = pure(this.travHelper());
      for (var i = 0; i < this.keys.length; i++)
          m = apply(m)(f(this.keys[i])(this.values[i]));
      return m;
  }

  Collision.prototype.unionWith = function (eq, hash, f, that, shift) {
      if (that.constructor !== Collision)
          throw "Trying to union a Collision with something else";
      var keys = [];
      var values = [];
      var added = Array(that.keys.length).fill(false);
      outer:
      for (var i = 0; i < this.keys.length; i++) {
          for (var j = 0; j < that.keys.length; j++) {
              if (eq(this.keys[i])(that.keys[j])) {
                  keys.push(this.keys[i]);
                  values.push(f(this.values[i])(that.values[j]));
                  added[j] = true;
                  continue outer;
              }
          }
          keys.push(this.keys[i]);
          values.push(this.values[i]);
          added[j] = true;
      }
      for (var k = 0; k < that.keys.length; k++) {
          if (!added[k]) {
              keys.push(that.keys[k]);
              values.push(that.values[k]);
          }
      }
      return new Collision(keys, values);
  }

  Collision.prototype.intersectionWith = function (Nothing, Just, eq, hash, f, that, shift) {
      if (that.constructor !== Collision)
          throw "Trying to intersect a Collision with something else";
      var keys = [];
      var values = [];
      outer:
      for (var i = 0; i < this.keys.length; i++) {
          for (var j = 0; j < that.keys.length; j++) {
              if (eq(this.keys[i])(that.keys[j])) {
                  keys.push(this.keys[i]);
                  values.push(f(this.values[i])(that.values[j]));
                  continue outer;
              }
          }
      }
      if (keys.length === 0)
          return empty;
      // This is a bit dodgy. We return a fake MapNode (wrong datamap
      // (WHICH CANNOT BE 0, OTHERWISE isEmpty THINKS IT'S EMPTY!) and
      // nodemap), but it's okay, because we will immediately
      // deconstruct it in the MapNode.intersectionWith.
      if (keys.length === 1)
          return new MapNode(1, 0, [keys[0], values[0]]);
      return new Collision(keys, values);
  }

  Collision.prototype.filterWithKey = function collisionFilterWithKey(f) {
      var keys = [];
      var values = [];
      for (var i = 0; i < this.keys.length; i++) {
          var k = this.keys[i];
          var v = this.values[i];
          if (f(k)(v)) {
              keys.push(k);
              values.push(v);
          }
      }
      if (keys.length === 0) return empty;
      // This is a bit dodgy. We return a fake MapNode (wrong datamap
      // (WHICH CANNOT BE 0, OTHERWISE isEmpty THINKS IT'S EMPTY!) and
      // nodemap), but it's okay, because we will immediately
      // deconstruct it in MapNode's filterWithKey.
      if (keys.length === 1) return new MapNode(1, 0, [keys[0], values[0]]);
      return new Collision(keys, values);
  }

  function mask(keyHash, shift) {
      return 1 << ((keyHash >>> shift) & 31);
  }

  function index(map, bit) {
      return popCount(map & (bit - 1));
  }

  function popCount (n) {
      n = n - ((n >> 1) & 0x55555555);
      n = (n & 0x33333333) + ((n >> 2) & 0x33333333);
      return ((n + (n >> 4) & 0xF0F0F0F) * 0x1010101) >> 24;
  }

  function binaryNode(k1, kh1, v1, k2, kh2, v2, s) {
      if (s >= 32) return new Collision([k1, k2], [v1, v2]);

      var b1 = (kh1 >>> s) & 31;
      var b2 = (kh2 >>> s) & 31;

      if (b1 !== b2) return new MapNode((1 << b1) | (1 << b2), 0, (b1 >>> 0) < (b2 >>> 0) ? [k1, v1, k2, v2] : [k2, v2, k1, v1]);

      return new MapNode(0, 1 << b1, [binaryNode(k1, kh1, v1, k2, kh2, v2, s + 5)]);
  }

  function overwriteTwoElements(a, index, v1, v2) {
      var res = a.slice();
      res[index] = v1;
      res[index+1] = v2;
      return res;
  }

  // TODO benchmark some alternative implementations (manual copy, slice
  // left + copy?, slice both + concat?, ...)
  function remove2(a, index) {
      var res = a.slice();
      res.splice(index, 2);
      return res;
  }

  // I think this is always called with a node index? Therefore, the
  // left will often be larger than the right. Does that help?
  function remove1(a, index) {
      var res = a.slice();
      res.splice(index, 1);
      return res;
  }

  // Make a copy while overwriting the element at index, or adding one element if index == a.length
  function copyAndOverwriteOrExtend1(a, index, v) {
      var res = a.slice();
      res[index] = v;
      return res;
  }

  function remove2insert1(a, removeIndex, insertIndex, v1) {
      var res = new Array(a.length - 1);
      for (var i = 0; i < removeIndex; i++) res[i] = a[i];
      for (; i < insertIndex; i++) res[i] = a[i+2];
      res[i++] = v1;
      for (; i < res.length; i++) res[i] = a[i+1];
      return res;
  }

  function insert2(a, index, v1, v2) {
      var res = new Array(a.length + 2);
      for (var i = 0; i < index; i++) res[i] = a[i];
      res[i++] = v1;
      res[i++] = v2;
      for (; i < res.length; i++) res[i] = a[i - 2];
      return res;
  }

  function insert2remove1(a, insertIndex, v1, v2, removeIndex) {
      var res = new Array(a.length + 1);
      for (var i = 0; i < insertIndex; i++) res[i] = a[i];
      res[i++] = v1;
      res[i++] = v2;
      for (; i < removeIndex + 2; i++) res[i] = a[i-2];
      for (; i < res.length; i++) res[i] = a[i-1];
      return res;
  }

  var empty = new MapNode(0,0,[]);

  exports.empty = empty;

  exports.lookupPurs = function (Nothing, Just, keyEquals, key, keyHash) {
      return function (m) {
          return m.lookup(Nothing, Just, keyEquals, key, keyHash, 0);
      };
  };

  exports.insertPurs = function (keyEquals, hashFunction) {
      return function (key) {
          return function (value) {
              return function (m) {
                  return m.insert(keyEquals, hashFunction, key, hashFunction(key), value, 0);
              };
          };
      };
  };

  exports.toArrayBy = function (f) {
      return function (m) {
          var res = [];
          m.toArrayBy(f, res);
          return res;
      };
  };

  function isEmpty (m) {
      return m.datamap === 0 && m.nodemap === 0;
  }
})(PS["Data.HashMap"] = PS["Data.HashMap"] || {});
(function(exports) {
  // This Source Code Form is subject to the terms of the Mozilla Public
  // License, v. 2.0. If a copy of the MPL was not distributed with this
  // file, You can obtain one at http://mozilla.org/MPL/2.0/.

  "use strict";

  exports.hashString = function (s) {
      var h = 0;
      for (var i = 0; i < s.length; i++) {
          h = (31 * h + s.charCodeAt(i)) | 0;
      }
      return h;
  };
})(PS["Data.Hashable"] = PS["Data.Hashable"] || {});
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Data.Hashable"] = $PS["Data.Hashable"] || {};
  var exports = $PS["Data.Hashable"];
  var $foreign = $PS["Data.Hashable"];
  var Data_Eq = $PS["Data.Eq"];
  var Hashable = function (Eq0, hash) {
      this.Eq0 = Eq0;
      this.hash = hash;
  }; 
  var hashableString = new Hashable(function () {
      return Data_Eq.eqString;
  }, $foreign.hashString);
  var hash = function (dict) {
      return dict.hash;
  };
  exports["hash"] = hash;
  exports["hashableString"] = hashableString;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Data.HashMap"] = $PS["Data.HashMap"] || {};
  var exports = $PS["Data.HashMap"];
  var $foreign = $PS["Data.HashMap"];
  var Data_Eq = $PS["Data.Eq"];
  var Data_Hashable = $PS["Data.Hashable"];
  var Data_Maybe = $PS["Data.Maybe"];
  var lookup = function (dictHashable) {
      return function (k) {
          return $foreign.lookupPurs(Data_Maybe.Nothing.value, Data_Maybe.Just.create, Data_Eq.eq(dictHashable.Eq0()), k, Data_Hashable.hash(dictHashable)(k));
      };
  };
  var insert = function (dictHashable) {
      return $foreign.insertPurs(Data_Eq.eq(dictHashable.Eq0()), Data_Hashable.hash(dictHashable));
  };
  exports["lookup"] = lookup;
  exports["insert"] = insert;
  exports["empty"] = $foreign.empty;
  exports["toArrayBy"] = $foreign.toArrayBy;
})(PS);
(function(exports) {
  "use strict";

  exports.toNumber = function (n) {
    return n;
  };
})(PS["Data.Int"] = PS["Data.Int"] || {});
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Data.Int"] = $PS["Data.Int"] || {};
  var exports = $PS["Data.Int"];
  var $foreign = $PS["Data.Int"];
  exports["toNumber"] = $foreign.toNumber;
})(PS);
(function(exports) {
  // global exports
  "use strict";

  exports.dateMethod = function(method, date) {
    return date[method]();
  };

  exports.parse = function(dateString) {
    return function() {
      return new Date(dateString);
    };
  };
})(PS["Data.JSDate"] = PS["Data.JSDate"] || {});
(function(exports) {
  "use strict";

  exports.showNumberImpl = function (n) {
    var str = n.toString();
    return isNaN(str + ".0") ? str : str + ".0";
  };

  exports.cons = function (head) {
    return function (tail) {
      return [head].concat(tail);
    };
  };

  exports.join = function (separator) {
    return function (xs) {
      return xs.join(separator);
    };
  };
})(PS["Data.Show"] = PS["Data.Show"] || {});
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Data.Symbol"] = $PS["Data.Symbol"] || {};
  var exports = $PS["Data.Symbol"];
  var IsSymbol = function (reflectSymbol) {
      this.reflectSymbol = reflectSymbol;
  };
  var reflectSymbol = function (dict) {
      return dict.reflectSymbol;
  };
  exports["IsSymbol"] = IsSymbol;
  exports["reflectSymbol"] = reflectSymbol;
})(PS);
(function(exports) {
  "use strict";

  exports.unsafeGet = function (label) {
    return function (rec) {
      return rec[label];
    };
  };
})(PS["Record.Unsafe"] = PS["Record.Unsafe"] || {});
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Record.Unsafe"] = $PS["Record.Unsafe"] || {};
  var exports = $PS["Record.Unsafe"];
  var $foreign = $PS["Record.Unsafe"];
  exports["unsafeGet"] = $foreign.unsafeGet;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Type.Proxy"] = $PS["Type.Proxy"] || {};
  var exports = $PS["Type.Proxy"];
  var $$Proxy = (function () {
      function $$Proxy() {

      };
      $$Proxy.value = new $$Proxy();
      return $$Proxy;
  })();
  exports["Proxy"] = $$Proxy;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Data.Show"] = $PS["Data.Show"] || {};
  var exports = $PS["Data.Show"];
  var $foreign = $PS["Data.Show"];
  var Data_Symbol = $PS["Data.Symbol"];
  var Record_Unsafe = $PS["Record.Unsafe"];
  var Type_Proxy = $PS["Type.Proxy"];                
  var ShowRecordFields = function (showRecordFields) {
      this.showRecordFields = showRecordFields;
  };
  var Show = function (show) {
      this.show = show;
  };                                                 
  var showRecordFieldsNil = new ShowRecordFields(function (v) {
      return function (v1) {
          return [  ];
      };
  });
  var showRecordFields = function (dict) {
      return dict.showRecordFields;
  };
  var showRecord = function (dictRowToList) {
      return function (dictShowRecordFields) {
          return new Show(function (record) {
              var v = showRecordFields(dictShowRecordFields)(Type_Proxy["Proxy"].value)(record);
              if (v.length === 0) {
                  return "{}";
              };
              return $foreign.join(" ")([ "{", $foreign.join(", ")(v), "}" ]);
          });
      };
  }; 
  var showNumber = new Show($foreign.showNumberImpl);
  var show = function (dict) {
      return dict.show;
  };
  var showRecordFieldsCons = function (dictIsSymbol) {
      return function (dictShowRecordFields) {
          return function (dictShow) {
              return new ShowRecordFields(function (v) {
                  return function (record) {
                      var tail = showRecordFields(dictShowRecordFields)(Type_Proxy["Proxy"].value)(record);
                      var key = Data_Symbol.reflectSymbol(dictIsSymbol)(Type_Proxy["Proxy"].value);
                      var focus = Record_Unsafe.unsafeGet(key)(record);
                      return $foreign.cons($foreign.join(": ")([ key, show(dictShow)(focus) ]))(tail);
                  };
              });
          };
      };
  };
  exports["Show"] = Show;
  exports["show"] = show;
  exports["showNumber"] = showNumber;
  exports["showRecord"] = showRecord;
  exports["showRecordFieldsNil"] = showRecordFieldsNil;
  exports["showRecordFieldsCons"] = showRecordFieldsCons;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Data.JSDate"] = $PS["Data.JSDate"] || {};
  var exports = $PS["Data.JSDate"];
  var $foreign = $PS["Data.JSDate"];
  var Data_Eq = $PS["Data.Eq"];
  var Data_Ord = $PS["Data.Ord"];
  var Data_Show = $PS["Data.Show"];                                                                                                                 
  var toDateString = function (dt) {
      return $foreign.dateMethod("toDateString", dt);
  };
  var getTime = function (dt) {
      return $foreign.dateMethod("getTime", dt);
  };
  var showJSDate = new Data_Show.Show(function (a) {
      return "(fromTime " + (Data_Show.show(Data_Show.showNumber)(getTime(a)) + ")");
  });
  var eqJSDate = new Data_Eq.Eq(function (a) {
      return function (b) {
          return getTime(a) === getTime(b);
      };
  });
  var ordJSDate = new Data_Ord.Ord(function () {
      return eqJSDate;
  }, function (a) {
      return function (b) {
          return Data_Ord.compare(Data_Ord.ordNumber)(getTime(a))(getTime(b));
      };
  });
  exports["getTime"] = getTime;
  exports["toDateString"] = toDateString;
  exports["ordJSDate"] = ordJSDate;
  exports["showJSDate"] = showJSDate;
  exports["parse"] = $foreign.parse;
})(PS);
(function(exports) {
  /* eslint-disable no-eq-null, eqeqeq */

  "use strict";          

  exports.nullable = function (a, r, f) {
    return a == null ? r : f(a);
  };
})(PS["Data.Nullable"] = PS["Data.Nullable"] || {});
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Data.Nullable"] = $PS["Data.Nullable"] || {};
  var exports = $PS["Data.Nullable"];
  var $foreign = $PS["Data.Nullable"];
  var Data_Maybe = $PS["Data.Maybe"];                                   
  var toMaybe = function (n) {
      return $foreign.nullable(n, Data_Maybe.Nothing.value, Data_Maybe.Just.create);
  };
  exports["toMaybe"] = toMaybe;
})(PS);
(function(exports) {
  "use strict";

  exports.intercalate = function (separator) {
    return function (xs) {
      var len = xs.length;
      if (len === 0) return "";

      var res = xs[0];
      for (var i = 1; i < len; i++) {
        res = res + separator + xs[i];
      }
      return res;
    };
  };
})(PS["Data.Show.Generic"] = PS["Data.Show.Generic"] || {});
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Data.Show.Generic"] = $PS["Data.Show.Generic"] || {};
  var exports = $PS["Data.Show.Generic"];
  var $foreign = $PS["Data.Show.Generic"];
  var Data_Generic_Rep = $PS["Data.Generic.Rep"];
  var Data_Semigroup = $PS["Data.Semigroup"];
  var Data_Show = $PS["Data.Show"];
  var Data_Symbol = $PS["Data.Symbol"];
  var Type_Proxy = $PS["Type.Proxy"];                
  var GenericShowArgs = function (genericShowArgs) {
      this.genericShowArgs = genericShowArgs;
  };
  var GenericShow = function (genericShow$prime) {
      this["genericShow'"] = genericShow$prime;
  }; 
  var genericShowArgsArgument = function (dictShow) {
      return new GenericShowArgs(function (v) {
          return [ Data_Show.show(dictShow)(v) ];
      });
  };
  var genericShowArgs = function (dict) {
      return dict.genericShowArgs;
  };
  var genericShowArgsProduct = function (dictGenericShowArgs) {
      return function (dictGenericShowArgs1) {
          return new GenericShowArgs(function (v) {
              return Data_Semigroup.append(Data_Semigroup.semigroupArray)(genericShowArgs(dictGenericShowArgs)(v.value0))(genericShowArgs(dictGenericShowArgs1)(v.value1));
          });
      };
  };
  var genericShowConstructor = function (dictGenericShowArgs) {
      return function (dictIsSymbol) {
          return new GenericShow(function (v) {
              var ctor = Data_Symbol.reflectSymbol(dictIsSymbol)(Type_Proxy["Proxy"].value);
              var v1 = genericShowArgs(dictGenericShowArgs)(v);
              if (v1.length === 0) {
                  return ctor;
              };
              return "(" + ($foreign.intercalate(" ")(Data_Semigroup.append(Data_Semigroup.semigroupArray)([ ctor ])(v1)) + ")");
          });
      };
  };
  var genericShow$prime = function (dict) {
      return dict["genericShow'"];
  }; 
  var genericShowSum = function (dictGenericShow) {
      return function (dictGenericShow1) {
          return new GenericShow(function (v) {
              if (v instanceof Data_Generic_Rep.Inl) {
                  return genericShow$prime(dictGenericShow)(v.value0);
              };
              if (v instanceof Data_Generic_Rep.Inr) {
                  return genericShow$prime(dictGenericShow1)(v.value0);
              };
              throw new Error("Failed pattern match at Data.Show.Generic (line 26, column 1 - line 28, column 40): " + [ v.constructor.name ]);
          });
      };
  };
  var genericShow = function (dictGeneric) {
      return function (dictGenericShow) {
          return function (x) {
              return genericShow$prime(dictGenericShow)(Data_Generic_Rep.from(dictGeneric)(x));
          };
      };
  };
  exports["genericShow"] = genericShow;
  exports["genericShowSum"] = genericShowSum;
  exports["genericShowArgsProduct"] = genericShowArgsProduct;
  exports["genericShowConstructor"] = genericShowConstructor;
  exports["genericShowArgsArgument"] = genericShowArgsArgument;
})(PS);
(function(exports) {
  "use strict";

  exports.trim = function (s) {
    return s.trim();
  };
})(PS["Data.String.Common"] = PS["Data.String.Common"] || {});
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Data.String.Common"] = $PS["Data.String.Common"] || {};
  var exports = $PS["Data.String.Common"];
  var $foreign = $PS["Data.String.Common"];
  exports["trim"] = $foreign.trim;
})(PS);
(function(exports) {
  "use strict";

  // jshint maxparams: 3

  exports.traverseArrayImpl = (function () {
    function array1(a) {
      return [a];
    }

    function array2(a) {
      return function (b) {
        return [a, b];
      };
    }

    function array3(a) {
      return function (b) {
        return function (c) {
          return [a, b, c];
        };
      };
    }

    function concat2(xs) {
      return function (ys) {
        return xs.concat(ys);
      };
    }

    return function (apply) {
      return function (map) {
        return function (pure) {
          return function (f) {
            return function (array) {
              function go(bot, top) {
                switch (top - bot) {
                case 0: return pure([]);
                case 1: return map(array1)(f(array[bot]));
                case 2: return apply(map(array2)(f(array[bot])))(f(array[bot + 1]));
                case 3: return apply(apply(map(array3)(f(array[bot])))(f(array[bot + 1])))(f(array[bot + 2]));
                default:
                  // This slightly tricky pivot selection aims to produce two
                  // even-length partitions where possible.
                  var pivot = bot + Math.floor((top - bot) / 4) * 2;
                  return apply(map(concat2)(go(bot, pivot)))(go(pivot, top));
                }
              }
              return go(0, array.length);
            };
          };
        };
      };
    };
  })();
})(PS["Data.Traversable"] = PS["Data.Traversable"] || {});
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Data.Traversable"] = $PS["Data.Traversable"] || {};
  var exports = $PS["Data.Traversable"];
  var $foreign = $PS["Data.Traversable"];
  var Control_Applicative = $PS["Control.Applicative"];
  var Control_Apply = $PS["Control.Apply"];
  var Control_Category = $PS["Control.Category"];
  var Data_Foldable = $PS["Data.Foldable"];
  var Data_Functor = $PS["Data.Functor"];            
  var Traversable = function (Foldable1, Functor0, sequence, traverse) {
      this.Foldable1 = Foldable1;
      this.Functor0 = Functor0;
      this.sequence = sequence;
      this.traverse = traverse;
  };
  var traverse = function (dict) {
      return dict.traverse;
  }; 
  var sequenceDefault = function (dictTraversable) {
      return function (dictApplicative) {
          return traverse(dictTraversable)(dictApplicative)(Control_Category.identity(Control_Category.categoryFn));
      };
  };
  var traversableArray = new Traversable(function () {
      return Data_Foldable.foldableArray;
  }, function () {
      return Data_Functor.functorArray;
  }, function (dictApplicative) {
      return sequenceDefault(traversableArray)(dictApplicative);
  }, function (dictApplicative) {
      return $foreign.traverseArrayImpl(Control_Apply.apply(dictApplicative.Apply0()))(Data_Functor.map((dictApplicative.Apply0()).Functor0()))(Control_Applicative.pure(dictApplicative));
  });
  exports["traverse"] = traverse;
  exports["traversableArray"] = traversableArray;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Data.Tuple"] = $PS["Data.Tuple"] || {};
  var exports = $PS["Data.Tuple"];                 
  var Tuple = (function () {
      function Tuple(value0, value1) {
          this.value0 = value0;
          this.value1 = value1;
      };
      Tuple.create = function (value0) {
          return function (value1) {
              return new Tuple(value0, value1);
          };
      };
      return Tuple;
  })();
  var uncurry = function (f) {
      return function (v) {
          return f(v.value0)(v.value1);
      };
  };
  var snd = function (v) {
      return v.value1;
  };
  exports["Tuple"] = Tuple;
  exports["snd"] = snd;
  exports["uncurry"] = uncurry;
})(PS);
(function(exports) {
  "use strict";

  exports.pureE = function (a) {
    return function () {
      return a;
    };
  };

  exports.bindE = function (a) {
    return function (f) {
      return function () {
        return f(a())();
      };
    };
  };
})(PS["Effect"] = PS["Effect"] || {});
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Effect"] = $PS["Effect"] || {};
  var exports = $PS["Effect"];
  var $foreign = $PS["Effect"];
  var Control_Applicative = $PS["Control.Applicative"];
  var Control_Apply = $PS["Control.Apply"];
  var Control_Bind = $PS["Control.Bind"];
  var Control_Monad = $PS["Control.Monad"];
  var Data_Functor = $PS["Data.Functor"];                    
  var monadEffect = new Control_Monad.Monad(function () {
      return applicativeEffect;
  }, function () {
      return bindEffect;
  });
  var bindEffect = new Control_Bind.Bind(function () {
      return applyEffect;
  }, $foreign.bindE);
  var applyEffect = new Control_Apply.Apply(function () {
      return functorEffect;
  }, Control_Monad.ap(monadEffect));
  var applicativeEffect = new Control_Applicative.Applicative(function () {
      return applyEffect;
  }, $foreign.pureE);
  var functorEffect = new Data_Functor.Functor(Control_Applicative.liftA1(applicativeEffect));
  exports["functorEffect"] = functorEffect;
  exports["applicativeEffect"] = applicativeEffect;
  exports["bindEffect"] = bindEffect;
})(PS);
(function(exports) {
  "use strict";

  exports.error = function (msg) {
    return new Error(msg);
  };

  exports.throwException = function (e) {
    return function () {
      throw e;
    };
  };
})(PS["Effect.Exception"] = PS["Effect.Exception"] || {});
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Effect.Exception"] = $PS["Effect.Exception"] || {};
  var exports = $PS["Effect.Exception"];
  var $foreign = $PS["Effect.Exception"];
  var $$throw = function ($2) {
      return $foreign.throwException($foreign.error($2));
  };
  exports["throw"] = $$throw;
})(PS);
(function(exports) {
  "use strict";

  exports.innerText = function(element) {
      return function() {
          return element.innerText;
      };
  };

  exports.renderDateTime = function(date) {
      return function() {
          return date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
      };
  };
})(PS["Main"] = PS["Main"] || {});
(function(exports) {
  "use strict";

  exports.remove = function (node) {
    return function () {
      return node.remove();
    };
  };
})(PS["Web.DOM.ChildNode"] = PS["Web.DOM.ChildNode"] || {});
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Web.DOM.ChildNode"] = $PS["Web.DOM.ChildNode"] || {};
  var exports = $PS["Web.DOM.ChildNode"];
  var $foreign = $PS["Web.DOM.ChildNode"];
  exports["remove"] = $foreign.remove;
})(PS);
(function(exports) {
  "use strict";

  exports.createElement = function (localName) {
    return function (doc) {
      return function () {
        return doc.createElement(localName);
      };
    };
  };
})(PS["Web.DOM.Document"] = PS["Web.DOM.Document"] || {});
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Web.DOM.Document"] = $PS["Web.DOM.Document"] || {};
  var exports = $PS["Web.DOM.Document"];
  var $foreign = $PS["Web.DOM.Document"];
  exports["createElement"] = $foreign.createElement;
})(PS);
(function(exports) {
  "use strict";

  exports.setAttribute = function (name) {
    return function (value) {
      return function (element) {
        return function () {
          element.setAttribute(name, value);
        };
      };
    };
  };
})(PS["Web.DOM.Element"] = PS["Web.DOM.Element"] || {});
(function(exports) {
  "use strict";

  // module Unsafe.Coerce

  exports.unsafeCoerce = function (x) {
    return x;
  };
})(PS["Unsafe.Coerce"] = PS["Unsafe.Coerce"] || {});
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Unsafe.Coerce"] = $PS["Unsafe.Coerce"] || {};
  var exports = $PS["Unsafe.Coerce"];
  var $foreign = $PS["Unsafe.Coerce"];
  exports["unsafeCoerce"] = $foreign.unsafeCoerce;
})(PS);
(function(exports) {
  "use strict";

  exports._unsafeReadProtoTagged = function (nothing, just, name, value) {
    if (typeof window !== "undefined") {
      var ty = window[name];
      if (ty != null && value instanceof ty) {
        return just(value);
      }
    }
    var obj = value;
    while (obj != null) {
      var proto = Object.getPrototypeOf(obj);
      var constructorName = proto.constructor.name;
      if (constructorName === name) {
        return just(value);
      } else if (constructorName === "Object") {
        return nothing;
      }
      obj = proto;
    }
    return nothing;
  };
})(PS["Web.Internal.FFI"] = PS["Web.Internal.FFI"] || {});
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Web.Internal.FFI"] = $PS["Web.Internal.FFI"] || {};
  var exports = $PS["Web.Internal.FFI"];
  var $foreign = $PS["Web.Internal.FFI"];
  var Data_Maybe = $PS["Data.Maybe"];                
  var unsafeReadProtoTagged = function (name) {
      return function (value) {
          return $foreign["_unsafeReadProtoTagged"](Data_Maybe.Nothing.value, Data_Maybe.Just.create, name, value);
      };
  };
  exports["unsafeReadProtoTagged"] = unsafeReadProtoTagged;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Web.DOM.Element"] = $PS["Web.DOM.Element"] || {};
  var exports = $PS["Web.DOM.Element"];
  var $foreign = $PS["Web.DOM.Element"];
  var Unsafe_Coerce = $PS["Unsafe.Coerce"];
  var Web_Internal_FFI = $PS["Web.Internal.FFI"];                
  var toParentNode = Unsafe_Coerce.unsafeCoerce;              
  var toNode = Unsafe_Coerce.unsafeCoerce;       
  var toChildNode = Unsafe_Coerce.unsafeCoerce;                                        
  var fromNode = Web_Internal_FFI.unsafeReadProtoTagged("Element");
  exports["fromNode"] = fromNode;
  exports["toNode"] = toNode;
  exports["toChildNode"] = toChildNode;
  exports["toParentNode"] = toParentNode;
  exports["setAttribute"] = $foreign.setAttribute;
})(PS);
(function(exports) {
  "use strict";

  exports.toArray = function (list) {
    return function () {
      return [].slice.call(list);
    };
  };
})(PS["Web.DOM.HTMLCollection"] = PS["Web.DOM.HTMLCollection"] || {});
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Web.DOM.HTMLCollection"] = $PS["Web.DOM.HTMLCollection"] || {};
  var exports = $PS["Web.DOM.HTMLCollection"];
  var $foreign = $PS["Web.DOM.HTMLCollection"];
  exports["toArray"] = $foreign.toArray;
})(PS);
(function(exports) {
  "use strict";                                   

  exports.setTextContent = function (value) {
    return function (node) {
      return function () {
        node.textContent = value;
      };
    };
  };

  exports.appendChild = function (node) {
    return function (parent) {
      return function () {
        parent.appendChild(node);
      };
    };
  };
})(PS["Web.DOM.Node"] = PS["Web.DOM.Node"] || {});
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Web.DOM.Node"] = $PS["Web.DOM.Node"] || {};
  var exports = $PS["Web.DOM.Node"];
  var $foreign = $PS["Web.DOM.Node"];
  exports["setTextContent"] = $foreign.setTextContent;
  exports["appendChild"] = $foreign.appendChild;
})(PS);
(function(exports) {
  "use strict";

  exports.toArray = function (list) {
    return function () {
      return [].slice.call(list);
    };
  };
})(PS["Web.DOM.NodeList"] = PS["Web.DOM.NodeList"] || {});
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Web.DOM.NodeList"] = $PS["Web.DOM.NodeList"] || {};
  var exports = $PS["Web.DOM.NodeList"];
  var $foreign = $PS["Web.DOM.NodeList"];
  exports["toArray"] = $foreign.toArray;
})(PS);
(function(exports) {
  "use strict";

  var getEffProp = function (name) {
    return function (node) {
      return function () {
        return node[name];
      };
    };
  };

  exports.children = getEffProp("children");                  

  exports._querySelector = function (selector) {
    return function (node) {
      return function () {
        return node.querySelector(selector);
      };
    };
  };

  exports.querySelectorAll = function (selector) {
    return function (node) {
      return function () {
        return node.querySelectorAll(selector);
      };
    };
  };
})(PS["Web.DOM.ParentNode"] = PS["Web.DOM.ParentNode"] || {});
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Web.DOM.ParentNode"] = $PS["Web.DOM.ParentNode"] || {};
  var exports = $PS["Web.DOM.ParentNode"];
  var $foreign = $PS["Web.DOM.ParentNode"];
  var Data_Functor = $PS["Data.Functor"];
  var Data_Nullable = $PS["Data.Nullable"];
  var Effect = $PS["Effect"];
  var querySelector = function (qs) {
      var $0 = Data_Functor.map(Effect.functorEffect)(Data_Nullable.toMaybe);
      var $1 = $foreign["_querySelector"](qs);
      return function ($2) {
          return $0($1($2));
      };
  };
  exports["querySelector"] = querySelector;
  exports["children"] = $foreign.children;
  exports["querySelectorAll"] = $foreign.querySelectorAll;
})(PS);
(function(exports) {
  "use strict";

  exports.window = function () {
    return window;
  };
})(PS["Web.HTML"] = PS["Web.HTML"] || {});
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Web.HTML"] = $PS["Web.HTML"] || {};
  var exports = $PS["Web.HTML"];
  var $foreign = $PS["Web.HTML"];
  exports["window"] = $foreign.window;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Web.HTML.HTMLDocument"] = $PS["Web.HTML.HTMLDocument"] || {};
  var exports = $PS["Web.HTML.HTMLDocument"];
  var Unsafe_Coerce = $PS["Unsafe.Coerce"];                      
  var toParentNode = Unsafe_Coerce.unsafeCoerce; 
  var toDocument = Unsafe_Coerce.unsafeCoerce;
  exports["toDocument"] = toDocument;
  exports["toParentNode"] = toParentNode;
})(PS);
(function(exports) {
  "use strict";

  exports._read = function (nothing, just, value) {
    var tag = Object.prototype.toString.call(value);
    if (tag.indexOf("[object HTML") === 0 && tag.indexOf("Element]") === tag.length - 8) {
      return just(value);
    } else {
      return nothing;
    }
  };
})(PS["Web.HTML.HTMLElement"] = PS["Web.HTML.HTMLElement"] || {});
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Web.HTML.HTMLElement"] = $PS["Web.HTML.HTMLElement"] || {};
  var exports = $PS["Web.HTML.HTMLElement"];
  var $foreign = $PS["Web.HTML.HTMLElement"];
  var Data_Maybe = $PS["Data.Maybe"];
  var fromNode = function (x) {
      return $foreign["_read"](Data_Maybe.Nothing.value, Data_Maybe.Just.create, x);
  };
  exports["fromNode"] = fromNode;
})(PS);
(function(exports) {
  "use strict";

  exports.document = function (window) {
    return function () {
      return window.document;
    };
  };
})(PS["Web.HTML.Window"] = PS["Web.HTML.Window"] || {});
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Web.HTML.Window"] = $PS["Web.HTML.Window"] || {};
  var exports = $PS["Web.HTML.Window"];
  var $foreign = $PS["Web.HTML.Window"];
  exports["document"] = $foreign.document;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Main"] = $PS["Main"] || {};
  var exports = $PS["Main"];
  var $foreign = $PS["Main"];
  var Control_Applicative = $PS["Control.Applicative"];
  var Control_Bind = $PS["Control.Bind"];
  var Data_Array = $PS["Data.Array"];
  var Data_Boolean = $PS["Data.Boolean"];
  var Data_Foldable = $PS["Data.Foldable"];
  var Data_Function = $PS["Data.Function"];
  var Data_Functor = $PS["Data.Functor"];
  var Data_Generic_Rep = $PS["Data.Generic.Rep"];
  var Data_HashMap = $PS["Data.HashMap"];
  var Data_Hashable = $PS["Data.Hashable"];
  var Data_Int = $PS["Data.Int"];
  var Data_JSDate = $PS["Data.JSDate"];
  var Data_Maybe = $PS["Data.Maybe"];
  var Data_Ord = $PS["Data.Ord"];
  var Data_Show = $PS["Data.Show"];
  var Data_Show_Generic = $PS["Data.Show.Generic"];
  var Data_String_Common = $PS["Data.String.Common"];
  var Data_Symbol = $PS["Data.Symbol"];
  var Data_Traversable = $PS["Data.Traversable"];
  var Data_Tuple = $PS["Data.Tuple"];
  var Effect = $PS["Effect"];
  var Effect_Exception = $PS["Effect.Exception"];
  var Web_DOM_ChildNode = $PS["Web.DOM.ChildNode"];
  var Web_DOM_Document = $PS["Web.DOM.Document"];
  var Web_DOM_Element = $PS["Web.DOM.Element"];
  var Web_DOM_HTMLCollection = $PS["Web.DOM.HTMLCollection"];
  var Web_DOM_Node = $PS["Web.DOM.Node"];
  var Web_DOM_NodeList = $PS["Web.DOM.NodeList"];
  var Web_DOM_ParentNode = $PS["Web.DOM.ParentNode"];
  var Web_HTML = $PS["Web.HTML"];
  var Web_HTML_HTMLDocument = $PS["Web.HTML.HTMLDocument"];
  var Web_HTML_HTMLElement = $PS["Web.HTML.HTMLElement"];
  var Web_HTML_Window = $PS["Web.HTML.Window"];                
  var Single = (function () {
      function Single(value0) {
          this.value0 = value0;
      };
      Single.create = function (value0) {
          return new Single(value0);
      };
      return Single;
  })();
  var After = (function () {
      function After(value0, value1) {
          this.value0 = value0;
          this.value1 = value1;
      };
      After.create = function (value0) {
          return function (value1) {
              return new After(value0, value1);
          };
      };
      return After;
  })();
  var Parallel = (function () {
      function Parallel(value0, value1) {
          this.value0 = value0;
          this.value1 = value1;
      };
      Parallel.create = function (value0) {
          return function (value1) {
              return new Parallel(value0, value1);
          };
      };
      return Parallel;
  })();
  var scheduleStart = function (v) {
      if (v instanceof Single) {
          return v.value0.start;
      };
      if (v instanceof After) {
          return scheduleStart(v.value0);
      };
      if (v instanceof Parallel) {
          return Data_Ord.min(Data_JSDate.ordJSDate)(scheduleStart(v.value0))(scheduleStart(v.value1));
      };
      throw new Error("Failed pattern match at Main (line 50, column 1 - line 50, column 53): " + [ v.constructor.name ]);
  };
  var scheduleParallelism = function (v) {
      if (v instanceof Single) {
          return 1;
      };
      if (v instanceof After) {
          return Data_Ord.max(Data_Ord.ordInt)(scheduleParallelism(v.value0))(scheduleParallelism(v.value1));
      };
      if (v instanceof Parallel) {
          return scheduleParallelism(v.value0) + scheduleParallelism(v.value1) | 0;
      };
      throw new Error("Failed pattern match at Main (line 60, column 1 - line 60, column 51): " + [ v.constructor.name ]);
  };
  var scheduleEnd = function (v) {
      if (v instanceof Single) {
          return v.value0.end;
      };
      if (v instanceof After) {
          return scheduleEnd(v.value1);
      };
      if (v instanceof Parallel) {
          return Data_Ord.max(Data_JSDate.ordJSDate)(scheduleEnd(v.value0))(scheduleEnd(v.value1));
      };
      throw new Error("Failed pattern match at Main (line 55, column 1 - line 55, column 51): " + [ v.constructor.name ]);
  };
  var scheduleInsert = function (entry) {
      return function (schedule) {
          if (Data_Ord.greaterThanOrEq(Data_JSDate.ordJSDate)(entry.start)(scheduleEnd(schedule))) {
              return new After(schedule, new Single(entry));
          };
          if (Data_Ord.lessThanOrEq(Data_JSDate.ordJSDate)(entry.end)(scheduleStart(schedule))) {
              return new After(new Single(entry), schedule);
          };
          if (Data_Boolean.otherwise) {
              if (schedule instanceof Single) {
                  return new Parallel(new Single(schedule.value0), new Single(entry));
              };
              if (schedule instanceof After && (schedule.value0 instanceof After && Data_Ord.greaterThanOrEq(Data_JSDate.ordJSDate)(entry.start)(scheduleEnd(schedule.value0.value0)))) {
                  return new After(schedule.value0.value0, scheduleInsert(entry)(new After(schedule.value0.value1, schedule.value1)));
              };
              if (schedule instanceof After) {
                  if (Data_Ord.greaterThanOrEq(Data_JSDate.ordJSDate)(entry.start)(scheduleEnd(schedule.value0))) {
                      return new After(schedule.value0, scheduleInsert(entry)(schedule.value1));
                  };
                  if (Data_Ord.lessThanOrEq(Data_JSDate.ordJSDate)(entry.end)(scheduleStart(schedule.value1))) {
                      return new After(scheduleInsert(entry)(schedule.value0), schedule.value1);
                  };
                  if (Data_Boolean.otherwise) {
                      return new Parallel(new After(schedule.value0, schedule.value1), new Single(entry));
                  };
              };
              if (schedule instanceof Parallel) {
                  var y$prime = scheduleInsert(entry)(schedule.value1);
                  var x$prime = scheduleInsert(entry)(schedule.value0);
                  var r = scheduleParallelism(schedule.value0) + scheduleParallelism(y$prime) | 0;
                  var l = scheduleParallelism(x$prime) + scheduleParallelism(schedule.value1) | 0;
                  var $40 = l < r;
                  if ($40) {
                      return new Parallel(x$prime, schedule.value1);
                  };
                  return new Parallel(schedule.value0, y$prime);
              };
              throw new Error("Failed pattern match at Main (line 73, column 19 - line 89, column 59): " + [ schedule.constructor.name ]);
          };
          throw new Error("Failed pattern match at Main (line 67, column 1 - line 67, column 64): " + [ entry.constructor.name, schedule.constructor.name ]);
      };
  };
  var scheduleRender = function (doc) {
      return function (day) {
          return function (schedule0) {
              var zero = scheduleStart(schedule0);
              var ticks = function (date) {
                  return Data_JSDate.getTime(date) / 1000.0 / 60.0;
              };
              var go = function (container) {
                  return function (left) {
                      return function (width) {
                          return function (schedule) {
                              if (schedule instanceof Single) {
                                  var y = (ticks(schedule.value0.start) - ticks(zero)) + Data_Int.toNumber(30);
                                  var height = ticks(schedule.value0.end) - ticks(schedule.value0.start);
                                  return function __do() {
                                      var div = (function () {
                                          var v = Data_String_Common.trim(schedule.value0.content.link);
                                          if (v === "") {
                                              return Web_DOM_Document.createElement("div")(doc)();
                                          };
                                          var a = Web_DOM_Document.createElement("a")(doc)();
                                          Web_DOM_Element.setAttribute("href")(v)(a)();
                                          return a;
                                      })();
                                      Web_DOM_Element.setAttribute("class")("entry " + schedule.value0.content.kind)(div)();
                                      Web_DOM_Element.setAttribute("style")("position: absolute;" + ("top: " + (Data_Show.show(Data_Show.showNumber)(y) + ("px;" + ("left: " + (Data_Show.show(Data_Show.showNumber)(left) + ("%; " + ("width: " + (Data_Show.show(Data_Show.showNumber)(width) + ("%; " + ("height: " + (Data_Show.show(Data_Show.showNumber)(height) + "px;"))))))))))))(div)();
                                      var timeSpan = Web_DOM_Document.createElement("span")(doc)();
                                      Web_DOM_Element.setAttribute("class")("time")(timeSpan)();
                                      var startStr = $foreign.renderDateTime(schedule.value0.start)();
                                      var endStr = $foreign.renderDateTime(schedule.value0.end)();
                                      Web_DOM_Node.setTextContent(startStr + (" - " + (endStr + ":")))(Web_DOM_Element.toNode(timeSpan))();
                                      Web_DOM_Node.appendChild(Web_DOM_Element.toNode(timeSpan))(Web_DOM_Element.toNode(div))();
                                      var titleSpan = Web_DOM_Document.createElement("span")(doc)();
                                      Web_DOM_Element.setAttribute("class")("title")(titleSpan)();
                                      Web_DOM_Node.setTextContent(schedule.value0.content.title)(Web_DOM_Element.toNode(titleSpan))();
                                      Web_DOM_Node.appendChild(Web_DOM_Element.toNode(titleSpan))(Web_DOM_Element.toNode(div))();
                                      return Web_DOM_Node.appendChild(Web_DOM_Element.toNode(div))(Web_DOM_Element.toNode(container))();
                                  };
                              };
                              if (schedule instanceof After) {
                                  return function __do() {
                                      go(container)(left)(width)(schedule.value0)();
                                      return go(container)(left)(width)(schedule.value1)();
                                  };
                              };
                              if (schedule instanceof Parallel) {
                                  var yp = Data_Int.toNumber(scheduleParallelism(schedule.value1));
                                  var xp = Data_Int.toNumber(scheduleParallelism(schedule.value0));
                                  var unitWidth = width / (xp + yp);
                                  return function __do() {
                                      go(container)(left)(xp * unitWidth)(schedule.value0)();
                                      return go(container)(left + xp * unitWidth)(yp * unitWidth)(schedule.value1)();
                                  };
                              };
                              throw new Error("Failed pattern match at Main (line 115, column 40 - line 160, column 68): " + [ schedule.constructor.name ]);
                          };
                      };
                  };
              };
              return function __do() {
                  var container = Web_DOM_Document.createElement("div")(doc)();
                  var start = ticks(scheduleStart(schedule0));
                  var end = ticks(scheduleEnd(schedule0));
                  var height = (end - start) + Data_Int.toNumber(30);
                  Web_DOM_Element.setAttribute("class")("day")(container)();
                  Web_DOM_Element.setAttribute("style")("position: relative; height: " + (Data_Show.show(Data_Show.showNumber)(height) + "px;"))(container)();
                  var div = Web_DOM_Document.createElement("div")(doc)();
                  Web_DOM_Element.setAttribute("class")("date")(div)();
                  Web_DOM_Node.setTextContent(day)(Web_DOM_Element.toNode(div))();
                  Web_DOM_Node.appendChild(Web_DOM_Element.toNode(div))(Web_DOM_Element.toNode(container))();
                  go(container)(0.0)(100.0)(schedule0)();
                  return container;
              };
          };
      };
  };
  var parseEntry = function (element) {
      return function __do() {
          var cells = Control_Bind.bind(Effect.bindEffect)(Control_Bind.bind(Effect.bindEffect)(Control_Bind.bind(Effect.bindEffect)(Web_DOM_ParentNode.querySelectorAll("td")(Web_DOM_Element.toParentNode(element)))(Web_DOM_NodeList.toArray))((function () {
              var $80 = Control_Applicative.pure(Effect.applicativeEffect);
              var $81 = Data_Array.mapMaybe(Web_HTML_HTMLElement.fromNode);
              return function ($82) {
                  return $80($81($82));
              };
          })()))(Data_Traversable.traverse(Data_Traversable.traversableArray)(Effect.applicativeEffect)($foreign.innerText))();
          if (cells.length === 5) {
              var start = Data_JSDate.parse(cells[0])();
              var end = Data_JSDate.parse(cells[1])();
              return new Data_Maybe.Just({
                  start: start,
                  end: end,
                  content: {
                      kind: cells[2],
                      link: cells[3],
                      title: cells[4]
                  }
              });
          };
          return Data_Maybe.Nothing.value;
      };
  };
  var parseEntries = function (schedule) {
      return function __do() {
          var trs = Control_Bind.bind(Effect.bindEffect)(Web_DOM_ParentNode.querySelectorAll("tr")(Web_DOM_Element.toParentNode(schedule)))(Web_DOM_NodeList.toArray)();
          return Data_Functor.map(Effect.functorEffect)(Data_Array.catMaybes)(Data_Traversable.traverse(Data_Traversable.traversableArray)(Effect.applicativeEffect)(parseEntry)(Data_Array.mapMaybe(Web_DOM_Element.fromNode)(trs)))();
      };
  };
  var genericSchedule = new Data_Generic_Rep.Generic(function (x) {
      if (x instanceof Single) {
          return new Data_Generic_Rep.Inl(x.value0);
      };
      if (x instanceof After) {
          return new Data_Generic_Rep.Inr(new Data_Generic_Rep.Inl(new Data_Generic_Rep.Product(x.value0, x.value1)));
      };
      if (x instanceof Parallel) {
          return new Data_Generic_Rep.Inr(new Data_Generic_Rep.Inr(new Data_Generic_Rep.Product(x.value0, x.value1)));
      };
      throw new Error("Failed pattern match at Main (line 45, column 1 - line 45, column 58): " + [ x.constructor.name ]);
  }, function (x) {
      if (x instanceof Data_Generic_Rep.Inl) {
          return new Single(x.value0);
      };
      if (x instanceof Data_Generic_Rep.Inr && x.value0 instanceof Data_Generic_Rep.Inl) {
          return new After(x.value0.value0.value0, x.value0.value0.value1);
      };
      if (x instanceof Data_Generic_Rep.Inr && x.value0 instanceof Data_Generic_Rep.Inr) {
          return new Parallel(x.value0.value0.value0, x.value0.value0.value1);
      };
      throw new Error("Failed pattern match at Main (line 45, column 1 - line 45, column 58): " + [ x.constructor.name ]);
  });
  var showSchedule = function (dictShow) {
      return new Data_Show.Show(function (x) {
          return Data_Show_Generic.genericShow(genericSchedule)(Data_Show_Generic.genericShowSum(Data_Show_Generic.genericShowConstructor(Data_Show_Generic.genericShowArgsArgument(Data_Show.showRecord()(Data_Show.showRecordFieldsCons(new Data_Symbol.IsSymbol(function () {
              return "content";
          }))(Data_Show.showRecordFieldsCons(new Data_Symbol.IsSymbol(function () {
              return "end";
          }))(Data_Show.showRecordFieldsCons(new Data_Symbol.IsSymbol(function () {
              return "start";
          }))(Data_Show.showRecordFieldsNil)(Data_JSDate.showJSDate))(Data_JSDate.showJSDate))(dictShow))))(new Data_Symbol.IsSymbol(function () {
              return "Single";
          })))(Data_Show_Generic.genericShowSum(Data_Show_Generic.genericShowConstructor(Data_Show_Generic.genericShowArgsProduct(Data_Show_Generic.genericShowArgsArgument(showSchedule(dictShow)))(Data_Show_Generic.genericShowArgsArgument(showSchedule(dictShow))))(new Data_Symbol.IsSymbol(function () {
              return "After";
          })))(Data_Show_Generic.genericShowConstructor(Data_Show_Generic.genericShowArgsProduct(Data_Show_Generic.genericShowArgsArgument(showSchedule(dictShow)))(Data_Show_Generic.genericShowArgsArgument(showSchedule(dictShow))))(new Data_Symbol.IsSymbol(function () {
              return "Parallel";
          })))))(x);
      });
  };
  var calendarRender = function (doc) {
      return function (calendar) {
          return Data_Traversable.traverse(Data_Traversable.traversableArray)(Effect.applicativeEffect)(Data_Tuple.uncurry(scheduleRender(doc)))(Data_Array.sortWith(Data_JSDate.ordJSDate)(function ($83) {
              return scheduleStart(Data_Tuple.snd($83));
          })(Data_HashMap.toArrayBy(Data_Tuple.Tuple.create)(calendar)));
      };
  };
  var calendarInsert = function (entry) {
      return function (calendar) {
          var day = Data_JSDate.toDateString(entry.start);
          var v = Data_HashMap.lookup(Data_Hashable.hashableString)(day)(calendar);
          if (v instanceof Data_Maybe.Nothing) {
              return Data_HashMap.insert(Data_Hashable.hashableString)(day)(new Single(entry))(calendar);
          };
          if (v instanceof Data_Maybe.Just) {
              return Data_HashMap.insert(Data_Hashable.hashableString)(day)(scheduleInsert(entry)(v.value0))(calendar);
          };
          throw new Error("Failed pattern match at Main (line 170, column 33 - line 172, column 72): " + [ v.constructor.name ]);
      };
  };
  var calendarFromEntries = Data_Array.foldl(Data_Function.flip(calendarInsert))(Data_HashMap.empty);
  var main = function __do() {
      var window = Web_HTML.window();
      var doc = Web_HTML_Window.document(window)();
      var schedule = Control_Bind.bind(Effect.bindEffect)(Web_DOM_ParentNode.querySelector(".schedule")(Web_HTML_HTMLDocument.toParentNode(doc)))(Data_Maybe.maybe(Effect_Exception["throw"]("no schedule"))(Control_Applicative.pure(Effect.applicativeEffect)))();
      var calendar = Data_Functor.map(Effect.functorEffect)(calendarFromEntries)(parseEntries(schedule))();
      Control_Bind.bind(Effect.bindEffect)(Control_Bind.bind(Effect.bindEffect)(Web_DOM_ParentNode.children(Web_DOM_Element.toParentNode(schedule)))(Web_DOM_HTMLCollection.toArray))(Data_Foldable.traverse_(Effect.applicativeEffect)(Data_Foldable.foldableArray)(function ($84) {
          return Web_DOM_ChildNode.remove(Web_DOM_Element.toChildNode($84));
      }))();
      var rendered = calendarRender(Web_HTML_HTMLDocument.toDocument(doc))(calendar)();
      return Data_Foldable.for_(Effect.applicativeEffect)(Data_Foldable.foldableArray)(rendered)(function (c) {
          return Web_DOM_Node.appendChild(Web_DOM_Element.toNode(c))(Web_DOM_Element.toNode(schedule));
      })();
  };
  exports["Single"] = Single;
  exports["After"] = After;
  exports["Parallel"] = Parallel;
  exports["scheduleStart"] = scheduleStart;
  exports["scheduleEnd"] = scheduleEnd;
  exports["scheduleParallelism"] = scheduleParallelism;
  exports["scheduleInsert"] = scheduleInsert;
  exports["scheduleRender"] = scheduleRender;
  exports["calendarInsert"] = calendarInsert;
  exports["calendarFromEntries"] = calendarFromEntries;
  exports["calendarRender"] = calendarRender;
  exports["parseEntry"] = parseEntry;
  exports["parseEntries"] = parseEntries;
  exports["main"] = main;
  exports["genericSchedule"] = genericSchedule;
  exports["showSchedule"] = showSchedule;
  exports["innerText"] = $foreign.innerText;
  exports["renderDateTime"] = $foreign.renderDateTime;
})(PS);
PS["Main"].main();
</script>

<section>
  <details open class="widget-dark1">
    <summary>
      ðŸ§‘â€ðŸ« Speakers
    </summary>
    <div class="content">
      <div class="speakers">
        <div class="speaker">
          <div class="anchor" id="speaker-gabriele-keller"></div>
          <div class="details">
            <img src="/images/speakers/gabriele-keller.jpg" alt="Gabriele Keller" class="avatar">
            <div>
              <span class="name">Gabriele Keller</span>
              <div class="links">
                <a class="web" href="https://uu.nl/staff/gkkeller"></a>
                <a class="twitter" href="https://twitter.com/gckeller"></a>
              </div>
            </div>
          </div>
          <p>
            Gabriele is a professor of Software Technology at
            <a href="https://www.uu.nl/en">Utrecht University</a>.
            Her interests include functional programming (and teaching
            functional programming), type systems,
            <a href="http://www.acceleratehs.org/">high-performance computing</a>,
            and programming language based approaches to verification.
          </p>
          <p>
            Gabriele will talk about
            <a href="http://www.acceleratehs.org/">Accelerate</a>.
          </p>
        </div>
        <div class="speaker">
          <div class="anchor" id="speaker-andrew-lelechenko"></div>
          <div class="details">
            <img src="/images/speakers/andrew-lelechenko.jpg" alt="Andrew Lelechenko" class="avatar">
            <div>
              <span class="name">Andrew Lelechenko</span>
              <div class="links">
                <a class="github" href="https://github.com/Bodigrim"></a>
              </div>
            </div>
          </div>
          <p>
            bytestring, logict, random, smallcheck, text, vector...
            if you've ever worked on a Haskell project, there's a good chance
            it depended on some code that Andrew wrote.  Also known as
            <em>Bodigrim</em>, he's one of the most
            prolific open source contributors in Haskell, board member of the
            <a href="https://haskell.foundation">Haskell Foundation</a>, and
            chair of the
            <a href="https://wiki.haskell.org/Core_Libraries_Committee">CLC</a>.
          </p>
          <p>
            He will talk about recent efforts to modernize the
            <a href="https://hackage.haskell.org/package/text">text</a> package.
          </p>
        </div>
        <div class="speaker">
          <div class="anchor" id="speaker-simon-peyton-jones"></div>
          <div class="details">
            <img src="/images/speakers/simon-peyton-jones.jpg" alt="Simon Peyton Jones" class="avatar">
            <div>
              <span class="name">Simon Peyton Jones</span>
              <div class="links">
                <a class="web" href="https://simon.peytonjones.org/"></a>
              </div>
            </div>
          </div>
          <p>
            Simon is one of the designers of the Haskell language, an inspiring
            leader for the whole Haskell community,
            a <a href="https://www.microsoft.com/en-us/research/people/simonpj/publications/">prolific researcher</a>,
            and one of the main authors
            of <a href="https://www.haskell.org/ghc/">GHC</a>, the de facto
            standard Haskell compiler.  He also chairs the
            <a href="https://www.computingatschool.org.uk/">Computing At School</a>
            group, which promotes the teaching of computer science at school.
          </p>
          <p>
            Simon's will talk to us about <em>The Mighty Simplifier: into the
            heart of GHC</em>.
          </p>
        </div>
        <div class="speaker">
          <div class="anchor" id="speaker-alejandro-serrano"></div>
          <div class="details">
            <img src="/images/speakers/alejandro-serrano.jpg" alt="Alejandro Serrano" class="avatar">
            <div>
              <span class="name">Alejandro Serrano</span>
              <div class="links">
                <a class="twitter" href="https://twitter.com/trupill"></a>
                <a class="github" href="https://github.com/serras"></a>
              </div>
            </div>
          </div>
          <p>
            Alejandro embodies the combination of research and industry
            experience that makes the Haskell community so interesting.
            He co-hosts the
            <a href="https://haskell.foundation/podcast">Haskell Interlude</a>
            podcast and has written three books about Haskell:
            <a href="https://leanpub.com/haskell-stdlibs/">Haskell (Almost) Standard Libraries</a>,
            <a href="https://leanpub.com/book-of-monads">The Book of Monads</a>, and
            <a href="https://link.springer.com/book/10.1007/978-1-4842-4480-7">Practical Haskell</a>.
          </p>
          <p>
            Together with Alejandro we'll program a trading card game.
            This will be interactive so charge your laptop ðŸ”‹!
          </p>
        </div>
      </div>
    </div>
  </div>
</section>

<h1 id="venue">Venue</h1>
<section>
  <div class="tooltip">
    <p>
      The hackathon takes place at the
      <a href="https://www.ost.ch/en/university-of-applied-sciences/campus/rapperswil-jona-campus">beautiful
      Rapperswil-Jona campus of OST (formerly HSR)</a>,
      about 40 minutes outside of ZÃ¼rich city:
    </p>
    <p style="font-weight: bold; padding-left: 2em;">
      OST, Campus Rapperswil<br>
      Oberseestrasse 10<br>
      8640 Rapperswil
    </p>
    <p>
      The venue is located right next to the lake, and weather has been superb
      (25Â°C, 77â„‰) during the pre-COVID19 years, so feel free to bring your
      swimming gear!
    </p>
  </div>
  <img style="max-width: 100%; border: 4px solid var(--widget-border-color);"
      src="/images/zurihac2022/campus-rapperswil.jpg">

  <details>
    <summary>ðŸš‰ï¸ Getting There</summary>
    <div class="content">
      <h2>By Train</h3>
      <p>
        You can take the S5, S7 or S15 to get from the ZÃ¼rich main station to
        Rapperswil. These trains run regularly in 30 minute intervals. Google
        maps works well for directions if you use the "public transport" tab.
      </p>

      <p>
        If you arrive at the ZÃ¼rich airport, first take the train to the ZÃ¼rich main
        station and then continue with S5, S7 or S15. Trains from the airport towards
        the city run every few minutes.
      </p>

      <h3>Train tickets</h3>
      <p>
        If you stay in ZÃ¼rich city, the easiest option is to get a 24 hour pass
        for <strong>all zones</strong>. It's good for all public transportation
        around ZÃ¼rich, up to Rapperswil. A one-way ticket costs 17.20CHF, the 24
        hour pass 34.40CHF.
      </p>

      <p>
        Please note that the 24 hour pass is literally a 24 hour pass and can
        be used over multiple days: e.g. if you buy one on the first day of the
        Hackathon at e.g. 9.00 AM, you can still use it to take the train at
        8.00 AM the next day. This way, it is possible to buy only two tickets
        for the three-day conference.
      </p>

      <p>
        A lightly cheaper alternative to the 24 hour pass is the
        <a href="https://www.zvv.ch/zvv/en/travelcards-and-tickets/tickets/9-oclock-daypass.html">9 O&#39;Clock day pass</a>
        which works more like a regular day pass.  However, this requires you to
        take the train to Rapperswil after 09:00 AM on weekdays, as described on
        the website.
      </p>
      <p>
        You can buy tickets from the SBB or ZVV vending machines, which have a
        button to use them in English rather than German on the home screen.

        Alternatively, you can use the
        <a target="_blank" href="https://www.sbb.ch/en/buying/pages/fahrplan/fahrplan.xhtml">SBB website</a>,
        <a target="_blank" href="https://www.sbb.ch/en/timetable/mobile-apps/sbb-mobile.html">SBB mobile app</a>
        on
        <a href="https://play.google.com/store/apps/details?id=ch.sbb.mobile.android.b2c">Android</a>
        or
        <a href="https://apps.apple.com/ch/app/sbb-mobile/id294855237">iOS</a>.
      </p>

      <div class="anchor" id="getting-there-by-car"></div>
      <h2>By Car</h2>
      <p>
        There are some paid public parking lots in walking distance from the
        campus
        (<a href="https://www.ost.ch/de/die-ost/campus/campus-rapperswil-jona">see
        here for a map</a>).  It can be difficult to find a free parking spot
        in these lots, and you can expect to pay about CHF 20 per day.  We
        therefore recommend that you come via public transport if possible.
      </p>
    </div>
  </details>

  <details class="widget-light1">
    <summary>ðŸ¨ Accomodation</summary>
    <div class="content">
      <p>
        As for accomodation, there are two options.  You can either stay
        in ZÃ¼rich, or in Rapperswil itself.  Both have advantages and
        disadvantages: there are more things to do in ZÃ¼rich, but you can save
        time and transportation costs by staying in Rapperswil.
      </p>

      <p>Here are some hotels close to the venue:</p>
      <ul>
        <li>
          Rapperswil:
          <ul>
            <li><a href="https://www.sorellhotels.com/de/speer/rapperswil">Sorell Hotel Speer</a></li>
            <li><a href="https://www.jakob-rapperswil.ch/">Hotel Jakob</a></li>
            <li><a href="https://www.youthhostel.ch/en/hostels/rapperswil-jona/">Youth hostel Jona</a></li>
          </ul>
        </li>
        <li>
          Hurden:
          <ul>
            <li><a href="http://www.hotel-restaurant-roessli.ch">Hotel RÃ¶ssli</a></li>
            <li><a href="https://www.gasthofseefeld.ch/">Hotel Seefeld</a></li>
          </ul>
        </li>
      </ul>

      <p>
        During previous years, attendees have also shared accomodation (e.g. on
        <a href="https://airbnb.com">Airbnb</a>).  In order to get in touch with
        fellow attendees, we recommend using the <code>#accomodation</code> channel
        in our Discord (which you can join upon registration).
      </p>

      <p>
        If weather allows for it, camping is also a very affordable and beautiful
        option for the ultimate grassroots ZuriHac festival fans.  Several people
        have stayed at
        <a href="https://www.rapperswil-zuerichsee.ch/de/besuchen/unterkunft/camping-im-strandbad-stampf">this campsite</a>
        in 2017, 2018 and 2019.
      </p>
    </div>
  </details>

  <details id="food">
    <summary>ðŸ½ï¸ Food</summary>
    <div class="content">
      <h2>Food Trucks</h2>
      <p>
        On Saturday and Sunday from 11.00 to 15.00, the food trucks from
        <a href="https://www.tabliya.ch/">Tabliya (Egyptian)</a> and
        <a href="https://www.acapulcogrill.ch/">Acapulco (Mexican)</a> will
        be right outside the building for us.
      </p>
      <h2>Barbecue</h2>
      <p>
        On Saturday and Sunday evening, we will host a barbeque.  This is
        a bring-your-own-grillables event.  There will be a possibility to
        store stuff we didn't grill in a large fridge to reuse on Sunday and
        reduce food waste.
      </p>
      <h2>Mensa</h2>
      <p>
        During lunch hours on Monday, the Mensa restaurant at OST will be open.
      </p>
    </div>
  </details>

  <details class="widget-light2">
    <summary>ðŸ—ºï¸ Getting around</summary>
    <div class="content">
      <p>
        See <a target='_blank' href='https://www.google.com/maps/d/u/0/viewer?mid=1OmDEXl-VKylIyv2Or-yH0nqah38'>this map</a>
        for more information on accomodation, grocery stores, and other useful
        places.
      </p>
      <p>
        We also recommend the
        <a href="https://en.wikivoyage.org/wiki/Zurich">Wikivoyage page on ZÃ¼rich</a>.
      </p>
    </div>
  </details>
</section>

<h1>Registration</h1>
<section>
  <details open class="widget-dark2">
    <summary id="registration">ðŸ“ Registration</summary>
    <div class="content">
      <p>
        We are currently planning to hold ZuriHac 2022 as an in-person event.
        This means that visitors will need to comply with the
        <a href="https://www.bag.admin.ch/bag/en/home/krankheiten/ausbrueche-epidemien-pandemien/aktuelle-ausbrueche-epidemien/novel-cov/empfehlungen-fuer-reisende/quarantaene-einreisende.html">COVID-19 travel regulations</a>
        in place at the time of the conference.
      </p>
      <p>
        <strong><a href="https://zureg.zfoh.ch/register">To the registration!</a></strong>
      </p>
    </div>
  </details>
  <details>
    <summary id="scholarships">ðŸŽ“ Scholarships</summary>
    <div class="content">
      <p>
        Switzerland can be expensive for people visiting from abroad. ZuriHac
        is a free event, but transportation, lodging, and food might discourage
        somebody without a good income from attending.  We want to make it
        easier for anyone to come, and contribute towards making the Haskell
        community exciting and diverse.
      </p>
      <p>
        For that reason, we will provide a small number of scholarships.
        Because we do not charge anything for tickets, our budget
        is limited, so we'll distribute them on a first come, first serve basis.
        Anybody accepted will be supported with an amount between 100.-
        and 500.- Swiss Francs, depending on your expenses.
      </p>
      <p>
        Our focus is on people with limited financial means and underrepresented
        groups in tech -- the latter includes, but is not limited to: people of
        colour, anyone identifying as LGBTQIA+, women, and disabled people.
      </p>
      <p>
        You can apply by sending an email to
        <a href="mailto:scholarships@zfoh.ch">scholarships@zfoh.ch</a>, and
        tell us why are you are interested in joining the event and how a
        scholarship would help?
        Don't write an essay, a couple of sentences are enough :)
      </p>
      <p>
        After we confirm your scholarship, please book your transport and
        accomodation, and send us the receipts and IBAN information for the
        wire transfer. Once we get your receipts, we'll wire you the money.
      </p>
      <p>
        We will not disclose the recipients of these scholarships, in order to
        protect their privacy.  The amount you estimate for your expenses will
        not be a factor when we consider your application.
      </p>
      <p>
        Don't be shy and just contact us if you feel that this can make a
        difference to you. There is no downside to applying, and we will never
        disclose your identity.
      </p>
    </div>
  </details>
</section>

<h1 id="sponsors">Sponsors</h1>
<div class="partners">
  <a href="https://www.digitalasset.com/" target="_blank"><img alt="Digital Asset" src="/images/s43/digitalasset.svg"></a>

  <a href="https://genlambda.com/" target="_blank"><img alt="Generation Lambda" src="/images/s43/gen-lambda.svg"></a>

  <a href="https://opensource.google.com/" target="_blank"><img alt="Google" src="/images/s43/google.svg"></a>

  <a href="https://hasura.io/" target="_blank"><img alt="Hasura" src="/images/s43/hasura.png"></a>

  <!-- This SVG needs explit width / height. -->
  <a href="https://mlabs.city/careers.html" target="_blank"><img style="max-height: none; width: 130px;" alt="MLabs" src="/images/s43/mlabs.svg"></a>

  <a href="https://www.ost.ch/en/" target="_blank"><img alt="OST" src="/images/s43/ost.svg"></a>

  <a href="https://platonic.systems/" target="_blank"><img alt="Platonic Systems" src="/images/s43/platonic-systems.svg"></a>

  <a href="https://serokell.io/" target="_blank"><img alt="Serokell" src="/images/s43/serokell.svg"></a>

  <a href="https://www.tweag.io/" target="_blank"><img alt="Tweag I/O" src="/images/s43/tweag-2022.svg"></a>

  <a href="https://www.well-typed.com/" target="_blank"><img alt="Well-Typed" src="/images/s43/well-typed.svg"></a>
</div>

<h1>About</h1>
<section>
  <details open>
    <summary id="contact">ðŸ“® Contact</summary>
    <div class="content">
      <p>
        The <strong>main organizers</strong> for ZuriHac 2022 are Jasper Van der
        Jeugt, Juri ChomÃ©, Farhad Mehta and Bieke Hoefkens.
        Additional key people include Adam Bratschi-Kaye, Andreas Herrmann,
        Lukas Buchli, Niklas HambÃ¼chen and Silvio BÃ¶hler.
      </p>
      <p>
        If you have any questions before the event, please reach out to
        <a href="mailto:m@jaspervdj.be,juri.chome@gmail.com,farhad.mehta@ost.ch">to the organizers</a>.
        We also monitor our official
        <a href="https://twitter.com/zurihac">Twitter account</a>.
      </p>
    </div>
  </details>

  <details class="widget-light2">
    <summary>âš–ï¸ Terms &amp; Conditions</summary>
    <div class="content">
      <p>
        Each participant will retain ownership of any and all intellectual and
        industrial property rights to his or her work created or used during the
        Hackathon.
      </p>
      <p>
        ZuriHac uses the
        <a href="https://berlincodeofconduct.org/">Berlin Code of Conduct</a>.
      </p>
    </div>
  </details>
</section>

    <footer>
      Copyright Â© 2018 - 2022 ZÃ¼rich Friends of Haskell Â·
      <a href="https://github.com/zfoh/zfoh.ch">Source code available</a>
      Â·
      <a href="/terms-and-conditions.html">Terms and Conditions</a>
      Â·
      <a href="/privacy-policy.html">Privacy Policy</a>
    </footer>
  </body>
  <script type="text/JavaScript">
    function hashChange() {
      var hash = window.location.hash.substr(1);
      if(hash) {
        var element = document.getElementById(hash);
        while(element) {
          if(element.tagName.toLowerCase() == "details" && !element.open) {
            // We need to scroll after opening because otherwise we would
            // first scholl and then open, so it may not be in view.
            element.open = true;
            element.scrollIntoView();
            element = null;
          } else {
            element = element.parentElement;
          }
        }
      }
    }
    window.addEventListener('hashchange', hashChange, false);
    hashChange();
  </script>
</html>
