// Generated by purs bundle 0.14.1
var PS = {};
(function(exports) {
  "use strict";

  exports.arrayApply = function (fs) {
    return function (xs) {
      var l = fs.length;
      var k = xs.length;
      var result = new Array(l*k);
      var n = 0;
      for (var i = 0; i < l; i++) {
        var f = fs[i];
        for (var j = 0; j < k; j++) {
          result[n++] = f(xs[j]);
        }
      }
      return result;
    };
  };
})(PS["Control.Apply"] = PS["Control.Apply"] || {});
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Control.Semigroupoid"] = $PS["Control.Semigroupoid"] || {};
  var exports = $PS["Control.Semigroupoid"];
  var Semigroupoid = function (compose) {
      this.compose = compose;
  };
  var semigroupoidFn = new Semigroupoid(function (f) {
      return function (g) {
          return function (x) {
              return f(g(x));
          };
      };
  });
  exports["semigroupoidFn"] = semigroupoidFn;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Control.Category"] = $PS["Control.Category"] || {};
  var exports = $PS["Control.Category"];
  var Control_Semigroupoid = $PS["Control.Semigroupoid"];                
  var Category = function (Semigroupoid0, identity) {
      this.Semigroupoid0 = Semigroupoid0;
      this.identity = identity;
  };
  var identity = function (dict) {
      return dict.identity;
  };
  var categoryFn = new Category(function () {
      return Control_Semigroupoid.semigroupoidFn;
  }, function (x) {
      return x;
  });
  exports["identity"] = identity;
  exports["categoryFn"] = categoryFn;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Data.Function"] = $PS["Data.Function"] || {};
  var exports = $PS["Data.Function"];
  var flip = function (f) {
      return function (b) {
          return function (a) {
              return f(a)(b);
          };
      };
  };
  var $$const = function (a) {
      return function (v) {
          return a;
      };
  };
  exports["flip"] = flip;
  exports["const"] = $$const;
})(PS);
(function(exports) {
  "use strict";

  exports.arrayMap = function (f) {
    return function (arr) {
      var l = arr.length;
      var result = new Array(l);
      for (var i = 0; i < l; i++) {
        result[i] = f(arr[i]);
      }
      return result;
    };
  };
})(PS["Data.Functor"] = PS["Data.Functor"] || {});
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Data.Functor"] = $PS["Data.Functor"] || {};
  var exports = $PS["Data.Functor"];
  var $foreign = $PS["Data.Functor"];                
  var Functor = function (map) {
      this.map = map;
  };
  var map = function (dict) {
      return dict.map;
  };                                                                                             
  var functorArray = new Functor($foreign.arrayMap);
  exports["Functor"] = Functor;
  exports["map"] = map;
  exports["functorArray"] = functorArray;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Control.Apply"] = $PS["Control.Apply"] || {};
  var exports = $PS["Control.Apply"];
  var $foreign = $PS["Control.Apply"];
  var Control_Category = $PS["Control.Category"];
  var Data_Function = $PS["Data.Function"];
  var Data_Functor = $PS["Data.Functor"];            
  var Apply = function (Functor0, apply) {
      this.Functor0 = Functor0;
      this.apply = apply;
  }; 
  var applyArray = new Apply(function () {
      return Data_Functor.functorArray;
  }, $foreign.arrayApply);
  var apply = function (dict) {
      return dict.apply;
  };
  var applySecond = function (dictApply) {
      return function (a) {
          return function (b) {
              return apply(dictApply)(Data_Functor.map(dictApply.Functor0())(Data_Function["const"](Control_Category.identity(Control_Category.categoryFn)))(a))(b);
          };
      };
  };
  exports["Apply"] = Apply;
  exports["apply"] = apply;
  exports["applySecond"] = applySecond;
  exports["applyArray"] = applyArray;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Control.Applicative"] = $PS["Control.Applicative"] || {};
  var exports = $PS["Control.Applicative"];
  var Control_Apply = $PS["Control.Apply"];          
  var Applicative = function (Apply0, pure) {
      this.Apply0 = Apply0;
      this.pure = pure;
  };
  var pure = function (dict) {
      return dict.pure;
  };
  var liftA1 = function (dictApplicative) {
      return function (f) {
          return function (a) {
              return Control_Apply.apply(dictApplicative.Apply0())(pure(dictApplicative)(f))(a);
          };
      };
  };
  exports["Applicative"] = Applicative;
  exports["pure"] = pure;
  exports["liftA1"] = liftA1;
})(PS);
(function(exports) {
  "use strict";

  exports.arrayBind = function (arr) {
    return function (f) {
      var result = [];
      for (var i = 0, l = arr.length; i < l; i++) {
        Array.prototype.push.apply(result, f(arr[i]));
      }
      return result;
    };
  };
})(PS["Control.Bind"] = PS["Control.Bind"] || {});
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Control.Bind"] = $PS["Control.Bind"] || {};
  var exports = $PS["Control.Bind"];
  var $foreign = $PS["Control.Bind"];
  var Control_Apply = $PS["Control.Apply"];          
  var Bind = function (Apply0, bind) {
      this.Apply0 = Apply0;
      this.bind = bind;
  }; 
  var bindArray = new Bind(function () {
      return Control_Apply.applyArray;
  }, $foreign.arrayBind);
  var bind = function (dict) {
      return dict.bind;
  };
  exports["Bind"] = Bind;
  exports["bind"] = bind;
  exports["bindArray"] = bindArray;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Control.Monad"] = $PS["Control.Monad"] || {};
  var exports = $PS["Control.Monad"];
  var Control_Applicative = $PS["Control.Applicative"];
  var Control_Bind = $PS["Control.Bind"];                
  var Monad = function (Applicative0, Bind1) {
      this.Applicative0 = Applicative0;
      this.Bind1 = Bind1;
  };
  var ap = function (dictMonad) {
      return function (f) {
          return function (a) {
              return Control_Bind.bind(dictMonad.Bind1())(f)(function (f$prime) {
                  return Control_Bind.bind(dictMonad.Bind1())(a)(function (a$prime) {
                      return Control_Applicative.pure(dictMonad.Applicative0())(f$prime(a$prime));
                  });
              });
          };
      };
  };
  exports["Monad"] = Monad;
  exports["ap"] = ap;
})(PS);
(function(exports) {
  "use strict";

  //------------------------------------------------------------------------------
  // Sorting ---------------------------------------------------------------------
  //------------------------------------------------------------------------------

  exports.sortByImpl = (function () {
    function mergeFromTo(compare, fromOrdering, xs1, xs2, from, to) {
      var mid;
      var i;
      var j;
      var k;
      var x;
      var y;
      var c;

      mid = from + ((to - from) >> 1);
      if (mid - from > 1) mergeFromTo(compare, fromOrdering, xs2, xs1, from, mid);
      if (to - mid > 1) mergeFromTo(compare, fromOrdering, xs2, xs1, mid, to);

      i = from;
      j = mid;
      k = from;
      while (i < mid && j < to) {
        x = xs2[i];
        y = xs2[j];
        c = fromOrdering(compare(x)(y));
        if (c > 0) {
          xs1[k++] = y;
          ++j;
        }
        else {
          xs1[k++] = x;
          ++i;
        }
      }
      while (i < mid) {
        xs1[k++] = xs2[i++];
      }
      while (j < to) {
        xs1[k++] = xs2[j++];
      }
    }

    return function (compare) {
      return function (fromOrdering) {
        return function (xs) {
          var out;

          if (xs.length < 2) return xs;

          out = xs.slice(0);
          mergeFromTo(compare, fromOrdering, out, xs.slice(0), 0, xs.length);

          return out;
        };
      };
    };
  })();
})(PS["Data.Array"] = PS["Data.Array"] || {});
(function(exports) {
  "use strict";

  exports.foldrArray = function (f) {
    return function (init) {
      return function (xs) {
        var acc = init;
        var len = xs.length;
        for (var i = len - 1; i >= 0; i--) {
          acc = f(xs[i])(acc);
        }
        return acc;
      };
    };
  };

  exports.foldlArray = function (f) {
    return function (init) {
      return function (xs) {
        var acc = init;
        var len = xs.length;
        for (var i = 0; i < len; i++) {
          acc = f(acc)(xs[i]);
        }
        return acc;
      };
    };
  };
})(PS["Data.Foldable"] = PS["Data.Foldable"] || {});
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Data.Monoid"] = $PS["Data.Monoid"] || {};
  var exports = $PS["Data.Monoid"];
  var mempty = function (dict) {
      return dict.mempty;
  };
  exports["mempty"] = mempty;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Data.Semigroup"] = $PS["Data.Semigroup"] || {};
  var exports = $PS["Data.Semigroup"];
  var append = function (dict) {
      return dict.append;
  };
  exports["append"] = append;
})(PS);
(function(exports) {
  "use strict";

  exports.unit = {};
})(PS["Data.Unit"] = PS["Data.Unit"] || {});
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Data.Unit"] = $PS["Data.Unit"] || {};
  var exports = $PS["Data.Unit"];
  var $foreign = $PS["Data.Unit"];
  exports["unit"] = $foreign.unit;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Data.Foldable"] = $PS["Data.Foldable"] || {};
  var exports = $PS["Data.Foldable"];
  var $foreign = $PS["Data.Foldable"];
  var Control_Applicative = $PS["Control.Applicative"];
  var Control_Apply = $PS["Control.Apply"];
  var Data_Function = $PS["Data.Function"];
  var Data_Monoid = $PS["Data.Monoid"];
  var Data_Semigroup = $PS["Data.Semigroup"];
  var Data_Unit = $PS["Data.Unit"];                
  var Foldable = function (foldMap, foldl, foldr) {
      this.foldMap = foldMap;
      this.foldl = foldl;
      this.foldr = foldr;
  };
  var foldr = function (dict) {
      return dict.foldr;
  };
  var traverse_ = function (dictApplicative) {
      return function (dictFoldable) {
          return function (f) {
              return foldr(dictFoldable)((function () {
                  var $313 = Control_Apply.applySecond(dictApplicative.Apply0());
                  return function ($314) {
                      return $313(f($314));
                  };
              })())(Control_Applicative.pure(dictApplicative)(Data_Unit.unit));
          };
      };
  };
  var for_ = function (dictApplicative) {
      return function (dictFoldable) {
          return Data_Function.flip(traverse_(dictApplicative)(dictFoldable));
      };
  };
  var foldl = function (dict) {
      return dict.foldl;
  }; 
  var foldMapDefaultR = function (dictFoldable) {
      return function (dictMonoid) {
          return function (f) {
              return foldr(dictFoldable)(function (x) {
                  return function (acc) {
                      return Data_Semigroup.append(dictMonoid.Semigroup0())(f(x))(acc);
                  };
              })(Data_Monoid.mempty(dictMonoid));
          };
      };
  };
  var foldableArray = new Foldable(function (dictMonoid) {
      return foldMapDefaultR(foldableArray)(dictMonoid);
  }, $foreign.foldlArray, $foreign.foldrArray);
  exports["foldl"] = foldl;
  exports["traverse_"] = traverse_;
  exports["for_"] = for_;
  exports["foldableArray"] = foldableArray;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Data.Maybe"] = $PS["Data.Maybe"] || {};
  var exports = $PS["Data.Maybe"];                 
  var Nothing = (function () {
      function Nothing() {

      };
      Nothing.value = new Nothing();
      return Nothing;
  })();
  var Just = (function () {
      function Just(value0) {
          this.value0 = value0;
      };
      Just.create = function (value0) {
          return new Just(value0);
      };
      return Just;
  })();
  var maybe = function (v) {
      return function (v1) {
          return function (v2) {
              if (v2 instanceof Nothing) {
                  return v;
              };
              if (v2 instanceof Just) {
                  return v1(v2.value0);
              };
              throw new Error("Failed pattern match at Data.Maybe (line 230, column 1 - line 230, column 51): " + [ v.constructor.name, v1.constructor.name, v2.constructor.name ]);
          };
      };
  };
  exports["Nothing"] = Nothing;
  exports["Just"] = Just;
  exports["maybe"] = maybe;
})(PS);
(function(exports) {
  "use strict";

  var unsafeCompareImpl = function (lt) {
    return function (eq) {
      return function (gt) {
        return function (x) {
          return function (y) {
            return x < y ? lt : x === y ? eq : gt;
          };
        };
      };
    };
  };                                         
  exports.ordIntImpl = unsafeCompareImpl;
  exports.ordNumberImpl = unsafeCompareImpl;
})(PS["Data.Ord"] = PS["Data.Ord"] || {});
(function(exports) {
  "use strict";

  var refEq = function (r1) {
    return function (r2) {
      return r1 === r2;
    };
  };                            
  exports.eqIntImpl = refEq;
  exports.eqNumberImpl = refEq;
  exports.eqStringImpl = refEq;
})(PS["Data.Eq"] = PS["Data.Eq"] || {});
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Data.Eq"] = $PS["Data.Eq"] || {};
  var exports = $PS["Data.Eq"];
  var $foreign = $PS["Data.Eq"];
  var Eq = function (eq) {
      this.eq = eq;
  }; 
  var eqString = new Eq($foreign.eqStringImpl);
  var eqNumber = new Eq($foreign.eqNumberImpl);
  var eqInt = new Eq($foreign.eqIntImpl);
  var eq = function (dict) {
      return dict.eq;
  };
  exports["Eq"] = Eq;
  exports["eq"] = eq;
  exports["eqInt"] = eqInt;
  exports["eqNumber"] = eqNumber;
  exports["eqString"] = eqString;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Data.Ordering"] = $PS["Data.Ordering"] || {};
  var exports = $PS["Data.Ordering"];              
  var LT = (function () {
      function LT() {

      };
      LT.value = new LT();
      return LT;
  })();
  var GT = (function () {
      function GT() {

      };
      GT.value = new GT();
      return GT;
  })();
  var EQ = (function () {
      function EQ() {

      };
      EQ.value = new EQ();
      return EQ;
  })();
  exports["LT"] = LT;
  exports["GT"] = GT;
  exports["EQ"] = EQ;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Data.Ord"] = $PS["Data.Ord"] || {};
  var exports = $PS["Data.Ord"];
  var $foreign = $PS["Data.Ord"];
  var Data_Eq = $PS["Data.Eq"];
  var Data_Ordering = $PS["Data.Ordering"];
  var Ord = function (Eq0, compare) {
      this.Eq0 = Eq0;
      this.compare = compare;
  }; 
  var ordNumber = new Ord(function () {
      return Data_Eq.eqNumber;
  }, $foreign.ordNumberImpl(Data_Ordering.LT.value)(Data_Ordering.EQ.value)(Data_Ordering.GT.value));
  var ordInt = new Ord(function () {
      return Data_Eq.eqInt;
  }, $foreign.ordIntImpl(Data_Ordering.LT.value)(Data_Ordering.EQ.value)(Data_Ordering.GT.value));
  var compare = function (dict) {
      return dict.compare;
  };
  var comparing = function (dictOrd) {
      return function (f) {
          return function (x) {
              return function (y) {
                  return compare(dictOrd)(f(x))(f(y));
              };
          };
      };
  };
  var greaterThanOrEq = function (dictOrd) {
      return function (a1) {
          return function (a2) {
              var v = compare(dictOrd)(a1)(a2);
              if (v instanceof Data_Ordering.LT) {
                  return false;
              };
              return true;
          };
      };
  };
  var lessThanOrEq = function (dictOrd) {
      return function (a1) {
          return function (a2) {
              var v = compare(dictOrd)(a1)(a2);
              if (v instanceof Data_Ordering.GT) {
                  return false;
              };
              return true;
          };
      };
  };
  var max = function (dictOrd) {
      return function (x) {
          return function (y) {
              var v = compare(dictOrd)(x)(y);
              if (v instanceof Data_Ordering.LT) {
                  return y;
              };
              if (v instanceof Data_Ordering.EQ) {
                  return x;
              };
              if (v instanceof Data_Ordering.GT) {
                  return x;
              };
              throw new Error("Failed pattern match at Data.Ord (line 176, column 3 - line 179, column 12): " + [ v.constructor.name ]);
          };
      };
  };
  var min = function (dictOrd) {
      return function (x) {
          return function (y) {
              var v = compare(dictOrd)(x)(y);
              if (v instanceof Data_Ordering.LT) {
                  return x;
              };
              if (v instanceof Data_Ordering.EQ) {
                  return x;
              };
              if (v instanceof Data_Ordering.GT) {
                  return y;
              };
              throw new Error("Failed pattern match at Data.Ord (line 167, column 3 - line 170, column 12): " + [ v.constructor.name ]);
          };
      };
  };
  exports["Ord"] = Ord;
  exports["compare"] = compare;
  exports["lessThanOrEq"] = lessThanOrEq;
  exports["greaterThanOrEq"] = greaterThanOrEq;
  exports["comparing"] = comparing;
  exports["min"] = min;
  exports["max"] = max;
  exports["ordInt"] = ordInt;
  exports["ordNumber"] = ordNumber;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Data.Array"] = $PS["Data.Array"] || {};
  var exports = $PS["Data.Array"];
  var $foreign = $PS["Data.Array"];
  var Control_Bind = $PS["Control.Bind"];
  var Control_Category = $PS["Control.Category"];
  var Data_Foldable = $PS["Data.Foldable"];
  var Data_Function = $PS["Data.Function"];
  var Data_Maybe = $PS["Data.Maybe"];
  var Data_Ord = $PS["Data.Ord"];
  var Data_Ordering = $PS["Data.Ordering"];
  var sortBy = function (comp) {
      return $foreign.sortByImpl(comp)(function (v) {
          if (v instanceof Data_Ordering.GT) {
              return 1;
          };
          if (v instanceof Data_Ordering.EQ) {
              return 0;
          };
          if (v instanceof Data_Ordering.LT) {
              return -1 | 0;
          };
          throw new Error("Failed pattern match at Data.Array (line 831, column 31 - line 834, column 11): " + [ v.constructor.name ]);
      });
  };
  var sortWith = function (dictOrd) {
      return function (f) {
          return sortBy(Data_Ord.comparing(dictOrd)(f));
      };
  };
  var singleton = function (a) {
      return [ a ];
  };                                                           
  var foldl = Data_Foldable.foldl(Data_Foldable.foldableArray);
  var concatMap = Data_Function.flip(Control_Bind.bind(Control_Bind.bindArray));
  var mapMaybe = function (f) {
      return concatMap((function () {
          var $109 = Data_Maybe.maybe([  ])(singleton);
          return function ($110) {
              return $109(f($110));
          };
      })());
  };
  var catMaybes = mapMaybe(Control_Category.identity(Control_Category.categoryFn));
  exports["mapMaybe"] = mapMaybe;
  exports["catMaybes"] = catMaybes;
  exports["foldl"] = foldl;
  exports["sortWith"] = sortWith;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Data.Boolean"] = $PS["Data.Boolean"] || {};
  var exports = $PS["Data.Boolean"];
  var otherwise = true;
  exports["otherwise"] = otherwise;
})(PS);
(function(exports) {
  // This Source Code Form is subject to the terms of the Mozilla Public
  // License, v. 2.0. If a copy of the MPL was not distributed with this
  // file, You can obtain one at http://mozilla.org/MPL/2.0/.

  "use strict";

  /** @constructor */
  function MapNode(datamap, nodemap, content) {
      this.datamap = datamap;
      this.nodemap = nodemap;
      this.content = content;
  }

  MapNode.prototype.lookup = function lookup(Nothing, Just, keyEquals, key, keyHash, shift) {
      var bit = mask(keyHash, shift);
      if ((this.datamap & bit) !== 0) {
          var i = index(this.datamap, bit);
          if (keyEquals(key)(this.content[i * 2]))
              return new Just(this.content[i * 2 + 1]);
          return Nothing;
      }
      if ((this.nodemap & bit) !== 0) {
          return this.content[this.content.length - 1 - index(this.nodemap, bit)].lookup(Nothing, Just, keyEquals, key, keyHash, shift + 5);
      }
      return Nothing;
  }

  function remove2insert1Mut(a, removeIndex, insertIndex, v1) {
      for (var i = removeIndex; i < insertIndex; i++) a[i] = a[i+2];
      a[i++] = v1;
      for (; i < a.length - 1; i++) a[i] = a[i+1];
      a.length = a.length - 1;
  }

  MapNode.prototype.insertMut = function insertMut(keyEquals, hashFunction, key, keyHash, value, shift) {
      var bit = mask(keyHash, shift);
      var i = index(this.datamap, bit);
      if ((this.datamap & bit) !== 0) {
          var k = this.content[i * 2];
          if (keyEquals(k)(key)) {
              this.content[i*2+1] = value;
          } else {
              var newNode = binaryNode(k, hashFunction(k), this.content[i*2+1], key, keyHash, value, shift + 5);
              this.datamap = this.datamap ^ bit;
              this.nodemap = this.nodemap | bit;
              remove2insert1Mut(this.content, i*2, this.content.length - index(this.nodemap, bit) - 2, newNode);
          }
      } else if ((this.nodemap & bit) !== 0) {
          var n = this.content.length - 1 - index(this.nodemap, bit);
          this.content[n].insertMut(keyEquals, hashFunction, key, keyHash, value, shift + 5);
      } else {
          this.datamap = this.datamap | bit;
          this.content.splice(i*2, 0, key, value);
      }
  }

  MapNode.prototype.insert = function insert(keyEquals, hashFunction, key, keyHash, value, shift) {
      var bit = mask(keyHash, shift);
      var i = index(this.datamap, bit);
      if ((this.datamap & bit) !== 0) {
          var k = this.content[i * 2];
          if (keyEquals(k)(key))
              return new MapNode(this.datamap, this.nodemap, overwriteTwoElements(this.content, i*2, key, value));
          var newNode = binaryNode(k, hashFunction(k), this.content[i*2+1], key, keyHash, value, shift + 5);
          return new MapNode(this.datamap ^ bit, this.nodemap | bit, remove2insert1(this.content, i * 2, this.content.length - index(this.nodemap, bit) - 2, newNode));
      }
      if ((this.nodemap & bit) !== 0) {
          var n = this.content.length - 1 - index(this.nodemap, bit);
          return new MapNode(this.datamap, this.nodemap,
                             copyAndOverwriteOrExtend1(this.content, n,
                                              this.content[n].insert(keyEquals, hashFunction, key, keyHash, value, shift + 5)));
      }
      return new MapNode(this.datamap | bit, this.nodemap, insert2(this.content, i*2, key, value));
  }

  MapNode.prototype.insertWith = function insertWith(keyEquals, hashFunction, f, key, keyHash, value, shift) {
      var bit = mask(keyHash, shift);
      var i = index(this.datamap, bit);
      if ((this.datamap & bit) !== 0) {
          var k = this.content[i * 2];
          if (keyEquals(k)(key))
              return new MapNode(this.datamap, this.nodemap, overwriteTwoElements(this.content, i*2, key, f(this.content[i*2+1])(value)));
          var newNode = binaryNode(k, hashFunction(k), this.content[i*2+1], key, keyHash, value, shift + 5);
          return new MapNode(this.datamap ^ bit, this.nodemap | bit, remove2insert1(this.content, i * 2, this.content.length - index(this.nodemap, bit) - 2, newNode));
      }
      if ((this.nodemap & bit) !== 0) {
          var n = this.content.length - 1 - index(this.nodemap, bit);
          return new MapNode(this.datamap, this.nodemap,
                             copyAndOverwriteOrExtend1(this.content, n,
                                              this.content[n].insertWith(keyEquals, hashFunction, f, key, keyHash, value, shift + 5)));
      }
      return new MapNode(this.datamap | bit, this.nodemap, insert2(this.content, i*2, key, value));
  }

  MapNode.prototype.delet = function delet(keyEquals, key, keyHash, shift) {
      var bit = mask(keyHash, shift);
      if ((this.datamap & bit) !== 0) {
          var dataIndex = index(this.datamap, bit);
          if (keyEquals(this.content[dataIndex*2])(key)) {
              if (this.nodemap === 0 && this.content.length === 2) return empty;
              return new MapNode(this.datamap ^ bit, this.nodemap, remove2(this.content, dataIndex * 2));
          }
          return this;
      }
      if ((this.nodemap & bit) !== 0) {
          var nodeIndex = index(this.nodemap,bit);
          var recNode = this.content[this.content.length - 1 - nodeIndex];
          var recRes = recNode.delet(keyEquals, key, keyHash, shift + 5);
          if (recNode === recRes) return this;
          if (recRes.isSingleton()) {
              if (this.content.length === 1) {
                  recRes.datamap = this.nodemap;
                  return recRes;
              }
              return new MapNode(this.datamap | bit, this.nodemap ^ bit,
                                 insert2remove1(this.content, 2 * index(this.datamap, bit), recRes.content[0], recRes.content[1], this.content.length - 1 - nodeIndex));
          }
          return new MapNode(this.datamap, this.nodemap, copyAndOverwriteOrExtend1(this.content, this.content.length - 1 - nodeIndex, recRes));
      }
      return this;
  }

  MapNode.prototype.toArrayBy = function (f, res) {
      for (var i = 0; i < popCount(this.datamap) * 2;) {
          var k = this.content[i++];
          var v = this.content[i++];
          res.push(f(k)(v));
      }
      for (; i < this.content.length; i++)
          this.content[i].toArrayBy(f, res);
  }

  MapNode.prototype.isSingleton = function () {
      return this.nodemap === 0 && this.content.length === 2;
  }

  MapNode.prototype.eq = function(kf, vf, that) {
      if (this === that) return true;
      if (this.constructor !== that.constructor || this.nodemap !== that.nodemap || this.datamap !== that.datamap) return false;
      for (var i = 0; i < popCount(this.datamap) * 2;) {
          if (kf(this.content[i])(that.content[i])) i++; else return false;
          if (vf(this.content[i])(that.content[i])) i++; else return false;
      }
      for (; i < this.content.length; i++)
          if (!this.content[i].eq(kf, vf, that.content[i])) return false;
      return true;
  }

  MapNode.prototype.hash = function (vhash) {
      var h = this.datamap;
      for (var i = 0; i < popCount(this.datamap); i++)
          h = (h * 31 + vhash(this.content[i * 2 + 1])) | 0;
      for (var j = 0; j < popCount(this.nodemap); j++)
          h = (h * 31 + this.content[this.content.length - j - 1].hash(vhash)) | 0;
      return h;
  }

  MapNode.prototype.size = function () {
      var res = popCount(this.datamap);
      for (var i = res * 2; i < this.content.length; i++) res += this.content[i].size();
      return res;
  }

  MapNode.prototype.imap = function (f) {
      var newContent = this.content.slice();
      for (var i = 0; i < popCount(this.datamap) * 2;) {
          var k = this.content[i++];
          var v = this.content[i++];
          newContent[i-2] = k;
          newContent[i-1] = f(k)(v);
      }
      for (; i < this.content.length; i++)
          newContent[i] = this.content[i].imap(f);
      return new MapNode(this.datamap, this.nodemap, newContent);
  }

  MapNode.prototype.ifoldMap = function (m, mappend, f) {
      for (var i = 0; i < popCount(this.datamap) * 2;) {
          var k = this.content[i++];
          var v = this.content[i++];
          m = mappend(m)(f(k)(v));
      }
      for (; i < this.content.length; i++)
          m = this.content[i].ifoldMap(m, mappend, f);
      return m;
  }

  function lowestBit(n) { return n & -n; }

  function mergeState(bit, thisnode, thisdata, thatnode, thatdata) {
      /* Returns one of these constants:

       const NONE_NONE = 0;
       const NODE_NONE = 1;
       const DATA_NONE = 2;
       const NONE_NODE = 4;
       const NONE_DATA = 8;
       const DATA_NODE = DATA_NONE | NONE_NODE;
       const NODE_DATA = NODE_NONE | NONE_DATA;
       const DATA_DATA = DATA_NONE | NONE_DATA;
       const NODE_NODE = NODE_NONE | NONE_NODE;

       I would love to declare them in the file, but purs compile
       complains about `const` and purs bundle removes variables.
    */  

      var state = 0;
      state |= (bit & thisnode) !== 0 ? 1 : 0;
      state |= (bit & thisdata) !== 0 ? 2 : 0;
      state |= (bit & thatnode) !== 0 ? 4 : 0;
      state |= (bit & thatdata) !== 0 ? 8 : 0;
      return state;
  }

  MapNode.prototype.unionWith = function (eq, hash, f, that, shift) {
      if (this.constructor !== that.constructor)
          throw "Trying to union a MapNode with something else";

      // I'd rather declare these locally in the branches, but purs
      // compile complains about `const`.
      var thisDataIndex, thatDataIndex, thisNodeIndex, thatNodeIndex;

      var datamap = 0;
      var nodemap = 0;
      var data = [];
      var nodes = [];

      // Conceptually, we go through all of the 32 bits in the result
      // and then handle the (in/notin + left/right + data/node)
      // combinations. With this clever trick, we get to skip the 0 bits.
      var skipmap = this.datamap | this.nodemap | that.datamap | that.nodemap;
      while (skipmap !== 0) {
          var bit = lowestBit(skipmap);
          skipmap &= ~bit;

          switch (mergeState(bit, this.nodemap, this.datamap, that.nodemap, that.datamap)) {
          case 1 /* NODE_NONE */:
              thisNodeIndex = index(this.nodemap, bit);
              nodemap |= bit;
              nodes.push(this.content[this.content.length - thisNodeIndex - 1]);
              break;
          case 2 /* DATA_NONE */:
              thisDataIndex = index(this.datamap, bit);
              datamap |= bit;
              data.push(this.content[thisDataIndex * 2], this.content[thisDataIndex * 2 + 1]);
              break;
          case 4 /* NONE_NODE */:
              thatNodeIndex = index(that.nodemap, bit);
              nodemap |= bit;
              nodes.push(that.content[that.content.length - thatNodeIndex - 1]);
              break;
          case 5 /* NODE_NODE */:
              thisNodeIndex = index(this.nodemap, bit);
              thatNodeIndex = index(that.nodemap, bit);
              nodemap |= bit;
              nodes.push(
                  this.content[this.content.length - thisNodeIndex - 1].
                       unionWith(eq, hash, f, that.content[that.content.length - thatNodeIndex - 1], shift + 5));
              break;
          case 6 /* DATA_NODE */:
              thisDataIndex = index(this.datamap, bit);
              thatNodeIndex = index(that.nodemap, bit);
              var k = this.content[thisDataIndex * 2];
              var v = this.content[thisDataIndex * 2 + 1];
              var hk = hash(k);
              var flippedF = function (a) { return function (b) { return f(b)(a); }; };
              nodemap |= bit;
              nodes.push(that.content[that.content.length - thatNodeIndex - 1].insertWith(eq, hash, flippedF, k, hk, v, shift + 5));
              break;
          case 8 /* NONE_DATA */:
              thatDataIndex = index(that.datamap, bit);
              datamap |= bit;
              data.push(that.content[thatDataIndex * 2], that.content[thatDataIndex * 2 + 1]);
              break;
          case 9 /* NODE_DATA */:
              thatDataIndex = index(that.datamap, bit);
              thisNodeIndex = index(this.nodemap, bit);
              var k = that.content[thatDataIndex * 2];
              var v = that.content[thatDataIndex * 2 + 1];
              var hk = hash(k);
              nodemap |= bit;
              nodes.push(this.content[this.content.length - thisNodeIndex - 1].insertWith(eq, hash, f, k, hk, v, shift + 5));
              break;
          case 10 /* DATA_DATA */:
              thisDataIndex = index(this.datamap, bit);
              thatDataIndex = index(that.datamap, bit);
              if (eq(this.content[thisDataIndex * 2])(that.content[thatDataIndex * 2])) {
                  // equal, merge with f
                  datamap |= bit;
                  data.push(this.content[thisDataIndex * 2], f(this.content[thisDataIndex * 2 + 1])(that.content[thatDataIndex * 2 + 1]));
              } else {
                  // key hashes equal at this level, merge into node
                  nodemap |= bit;
                  nodes.push(binaryNode(
                      this.content[thisDataIndex * 2],
                      hash(this.content[thisDataIndex * 2]),
                      this.content[thisDataIndex*2+1],
                      that.content[thatDataIndex * 2],
                      hash(that.content[thatDataIndex * 2]),
                      that.content[thatDataIndex*2+1],
                      shift + 5));
              }
              break;
          }
      }
      return new MapNode(datamap, nodemap, data.concat(nodes.reverse()));
  }

  MapNode.prototype.intersectionWith = function (Nothing, Just, eq, hash, f, that, shift) {
      if (this.constructor !== that.constructor)
          throw "Trying to intersect a MapNode with something else";

      // I'd rather declare these locally in the branches, but purs
      // compile complains about `const`.
      var thisDataIndex, thatDataIndex, thisNodeIndex, thatNodeIndex;

      var datamap = 0;
      var nodemap = 0;
      var data = [];
      var nodes = [];

      // Conceptually, we go through all of the 32 bits in the result
      // and then handle the (in/notin + left/right + data/node)
      // combinations. With this clever trick, we get to skip the 0 bits.
      var skipmap = (this.datamap | this.nodemap) & (that.datamap | that.nodemap);
      while (skipmap !== 0) {
          var bit = lowestBit(skipmap);
          skipmap &= ~bit;

          switch (mergeState(bit, this.nodemap, this.datamap, that.nodemap, that.datamap)) {
          case 5 /* NODE_NODE */:
              thisNodeIndex = index(this.nodemap, bit);
              thatNodeIndex = index(that.nodemap, bit);
              var recRes = this.content[this.content.length - thisNodeIndex - 1].
                   intersectionWith(Nothing, Just, eq, hash, f, that.content[that.content.length - thatNodeIndex - 1], shift + 5);
              if (isEmpty(recRes)) continue;
              if (recRes.isSingleton()) {
                  datamap |= bit;
                  data.push(recRes.content[0], recRes.content[1]);
              } else {
                  nodemap |= bit;
                  nodes.push(recRes);
              }
              break;
          case 6 /* DATA_NODE */:
              thisDataIndex = index(this.datamap, bit);
              thatNodeIndex = index(that.nodemap, bit);
              var k = this.content[thisDataIndex * 2];
              var v = this.content[thisDataIndex * 2 + 1];
              var hk = hash(k);
              var res = that.content[that.content.length - thatNodeIndex - 1].lookup(Nothing, Just, eq, k, hk, shift + 5);
              if (res !== Nothing) {
                  datamap |= bit;
                  data.push(k, f(v)(res.value0));
              }
              break;
          case 9 /* NODE_DATA */:
              thatDataIndex = index(that.datamap, bit);
              thisNodeIndex = index(this.nodemap, bit);
              var k = that.content[thatDataIndex * 2];
              var v = that.content[thatDataIndex * 2 + 1];
              var hk = hash(k);
              var res = this.content[this.content.length - thisNodeIndex - 1].lookup(Nothing, Just, eq, k, hk, shift + 5);
              if (res !== Nothing) {
                  datamap |= bit;
                  data.push(k, f(res.value0)(v));
              }
              break;
          case 10 /* DATA_DATA */:
              thisDataIndex = index(this.datamap, bit);
              thatDataIndex = index(that.datamap, bit);
              if (eq(this.content[thisDataIndex * 2])(that.content[thatDataIndex * 2])) {
                  datamap |= bit;
                  data.push(this.content[thisDataIndex * 2], f(this.content[thisDataIndex * 2 + 1])(that.content[thatDataIndex * 2 + 1]));
              }
              break;
          }
      }
      return new MapNode(datamap, nodemap, data.concat(nodes.reverse()));
  }

  MapNode.prototype.filterWithKey = function filterWithKey(f) {
      var datamap = 0;
      var nodemap = 0;
      var data = [];
      var nodes = [];
      var skipmap = this.datamap | this.nodemap;
      while (skipmap !== 0) {
          var bit = lowestBit(skipmap);
          skipmap &= ~bit;
          if ((this.datamap & bit) !== 0) {
              var dataIndex = index(this.datamap, bit);
              var k = this.content[dataIndex * 2];
              var v = this.content[dataIndex * 2 + 1];
              if (f(k)(v)) {
                  datamap |= bit;
                  data.push(k, v);
              }
          } else { // assert (this.nodemap & bit) !== 0
              var nodeIndex = index(this.nodemap, bit);
              var node = this.content[this.content.length - nodeIndex - 1].filterWithKey(f);
              if (isEmpty(node)) continue;
              if (node.isSingleton()) {
                  datamap |= bit;
                  data.push(node.content[0], node.content[1]);
              } else {
                  nodemap |= bit;
                  nodes.push(node);
              }
          }
      }
      return new MapNode(datamap, nodemap, data.concat(nodes.reverse()));
  }

  // This builds an n-ary curried function that takes all values and all
  // subnodes as arguments and places them in a copy of the hashmap
  // preserving the keys, datamap, and nodemap. Basically, a (Hashmap k
  // v) with s key-value pairs and t nodes turns into a function:
  //
  // k_0 -> .. -> k_s -> HashMap_0 k v -> .. -> HashMap_t k v -> HashMap k v
  //
  // Indices here are to be understood as count.
  //
  // The main use for this is the as the partial hashmap constructor in
  // place of the hole in this concept of an implementation of
  // traverseWithKey:
  //
  // pure ?here <*> f k1 v1 <*> f k2 v2 <*> traverseWithKey f n1 <*> traverseWithKey f n2
  MapNode.prototype.travHelper = function () {
      // TODO could have two helpers that basically switch mode from
      // setting values to setting nodes. That way branches would be
      // more predictable. Because the value branch is essentially
      // unpredictable.
      function go(vi, vm, ni, nm, copy) {
          if (vi < vm)
              return function (v) {
                  return go(vi + 1, vm, ni, nm, function () { var res = copy();
                                                              res.content[vi * 2 + 1] = v;
                                                              return res;
                                                            });
              }
          if (ni < nm)
              return function (n) {
                  return go(vi, vm, ni+1, nm, function () { var res = copy();
                                                            // order of parameters must match stored order
                                                            res.content[vm*2 + ni] = n;
                                                            return res;
                                                          });
              }
          return copy();
      }
      var vm = popCount(this.datamap);
      var self = this;
      return go(0, vm, 0, this.content.length - vm * 2, function () { return new MapNode(self.datamap, self.nodemap, self.content.slice()); });
  }

  MapNode.prototype.ifoldMap = function (m, mappend, f) {
      for (var i = 0; i < popCount(this.datamap) * 2;) {
          var k = this.content[i++];
          var v = this.content[i++];
          m = mappend(m)(f(k)(v));
      }
      for (; i < this.content.length; i++)
          m = this.content[i].ifoldMap(m, mappend, f);
      return m;
  }

  MapNode.prototype.itraverse = function (pure, apply, f) {
      var m = pure(this.travHelper());
      for (var i = 0; i < popCount(this.datamap) * 2;) {
          var k = this.content[i++];
          var v = this.content[i++];
          m = apply(m)(f(k)(v));
      }
      for (; i < this.content.length; i++)
          m = apply(m)(this.content[i].itraverse(pure, apply, f));
      return m;
  }

  /** @constructor */
  function Collision(keys, values) {
      this.keys = keys;
      this.values = values;
  }

  Collision.prototype.lookup = function collisionLookup(Nothing, Just, keyEquals, key, keyHash, shift) {
      for (var i = 0; i < this.keys.length; i++)
          if (keyEquals(key)(this.keys[i]))
              return new Just(this.values[i]);
      return Nothing;
  };

  Collision.prototype.insert = function collisionInsert(keyEquals, hashFunction, key, keyHash, value, shift) {
      var i = 0;
      for (; i < this.keys.length; i++)
          if (keyEquals(key)(this.keys[i]))
              break;
      return new Collision(copyAndOverwriteOrExtend1(this.keys, i, key),
                           copyAndOverwriteOrExtend1(this.values, i, value));
  };

  Collision.prototype.insertMut = function collisionInsertMut(keyEquals, hashFunction, key, keyHash, value, shift) {
      var i = 0;
      for (; i < this.keys.length; i++)
          if (keyEquals(key)(this.keys[i]))
              break;
      // i may be *after* the last element, if the key is not already in the map
      this.keys[i] = key;
      this.values[i] = value;
  };

  Collision.prototype.insertWith = function collisionInsert(keyEquals, hashFunction, f, key, keyHash, value, shift) {
      var i = 0;
      for (; i < this.keys.length; i++)
          if (keyEquals(key)(this.keys[i]))
              return new Collision(copyAndOverwriteOrExtend1(this.keys, i, key),
                                   copyAndOverwriteOrExtend1(this.values, i, f(this.values[i])(value)));
      return new Collision(copyAndOverwriteOrExtend1(this.keys, i, key),
                           copyAndOverwriteOrExtend1(this.values, i, value));
  };

  Collision.prototype.delet = function collisionDelete(keyEquals, key, keyHash, shift) {
      var i = 0;
      for (; i < this.keys.length; i++)
          if (keyEquals(key)(this.keys[i]))
              break;
      if (i === this.keys.length) return this;
      if (this.keys.length === 2)
          return new MapNode(1 << (keyHash & 31), 0, [this.keys[1 - i], this.values[1 - i]]);
      return new Collision(remove1(this.keys, i), remove1(this.values, i));
  }

  Collision.prototype.toArrayBy = function (f, res) {
      for (var i = 0; i < this.keys.length; i++)
          res.push(f(this.keys[i])(this.values[i]));
  }

  Collision.prototype.isSingleton = function () { return false; }

  Collision.prototype.eq = function(kf, vf, that) {
      if (this.constructor !== that.constructor || this.keys.length !== that.keys.length) return false;
      outer:
      for (var i = 0; i < this.keys.length; i++) {
          for (var j = 0; j < that.keys.length; j++) {
              if (kf(this.keys[i])(that.keys[j])) {
                  if (vf(this.values[i])(that.values[j]))
                      continue outer;
                  else
                      return false;
              }
          }
      }
      return true;
  }

  Collision.prototype.hash = function (vhash) {
      // We ignore keys because they have all the same hash anyways
      // (we're in a collision node!)
      var h = 0;
      // We use just + here, not multiply&add, because order in
      // collision nodes is undefined. A commutative combining operation
      // allows us to simply ignore the order.
      for (var i = 0; i < this.values.length; i++)
          h += vhash(this.values[i]);
      return h;
  }

  Collision.prototype.size = function () {
      return this.keys.length;
  }

  Collision.prototype.imap = function (f) {
      var newValues = this.values.slice();
      for (var i = 0; i < this.values.length; i++)
          newValues[i] = f(this.keys[i])(this.values[i]);
      return new Collision(this.keys, newValues);
  }

  Collision.prototype.ifoldMap = function (m, mappend, f) {
      for (var i = 0; i < this.keys.length; i++)
          m = mappend(m)(f(this.keys[i])(this.values[i]));
      return m;
  }

  Collision.prototype.travHelper = function () {
      function go(i, m, copy) {
          if (i < m)
              return function (v) {
                  return go(i + 1, m, function () { var res = copy();
                                                    res.values[i] = v;
                                                    return res;
                                                  });
              }
          return copy();
      }
      var self = this;
      return go(0, this.keys.length, function () { return new Collision(self.keys, self.values.slice()); });
  }

  Collision.prototype.itraverse = function (pure, apply, f) {
      var m = pure(this.travHelper());
      for (var i = 0; i < this.keys.length; i++)
          m = apply(m)(f(this.keys[i])(this.values[i]));
      return m;
  }

  Collision.prototype.unionWith = function (eq, hash, f, that, shift) {
      if (that.constructor !== Collision)
          throw "Trying to union a Collision with something else";
      var keys = [];
      var values = [];
      var added = Array(that.keys.length).fill(false);
      outer:
      for (var i = 0; i < this.keys.length; i++) {
          for (var j = 0; j < that.keys.length; j++) {
              if (eq(this.keys[i])(that.keys[j])) {
                  keys.push(this.keys[i]);
                  values.push(f(this.values[i])(that.values[j]));
                  added[j] = true;
                  continue outer;
              }
          }
          keys.push(this.keys[i]);
          values.push(this.values[i]);
          added[j] = true;
      }
      for (var k = 0; k < that.keys.length; k++) {
          if (!added[k]) {
              keys.push(that.keys[k]);
              values.push(that.values[k]);
          }
      }
      return new Collision(keys, values);
  }

  Collision.prototype.intersectionWith = function (Nothing, Just, eq, hash, f, that, shift) {
      if (that.constructor !== Collision)
          throw "Trying to intersect a Collision with something else";
      var keys = [];
      var values = [];
      outer:
      for (var i = 0; i < this.keys.length; i++) {
          for (var j = 0; j < that.keys.length; j++) {
              if (eq(this.keys[i])(that.keys[j])) {
                  keys.push(this.keys[i]);
                  values.push(f(this.values[i])(that.values[j]));
                  continue outer;
              }
          }
      }
      if (keys.length === 0)
          return empty;
      // This is a bit dodgy. We return a fake MapNode (wrong datamap
      // (WHICH CANNOT BE 0, OTHERWISE isEmpty THINKS IT'S EMPTY!) and
      // nodemap), but it's okay, because we will immediately
      // deconstruct it in the MapNode.intersectionWith.
      if (keys.length === 1)
          return new MapNode(1, 0, [keys[0], values[0]]);
      return new Collision(keys, values);
  }

  Collision.prototype.filterWithKey = function collisionFilterWithKey(f) {
      var keys = [];
      var values = [];
      for (var i = 0; i < this.keys.length; i++) {
          var k = this.keys[i];
          var v = this.values[i];
          if (f(k)(v)) {
              keys.push(k);
              values.push(v);
          }
      }
      if (keys.length === 0) return empty;
      // This is a bit dodgy. We return a fake MapNode (wrong datamap
      // (WHICH CANNOT BE 0, OTHERWISE isEmpty THINKS IT'S EMPTY!) and
      // nodemap), but it's okay, because we will immediately
      // deconstruct it in MapNode's filterWithKey.
      if (keys.length === 1) return new MapNode(1, 0, [keys[0], values[0]]);
      return new Collision(keys, values);
  }

  function mask(keyHash, shift) {
      return 1 << ((keyHash >>> shift) & 31);
  }

  function index(map, bit) {
      return popCount(map & (bit - 1));
  }

  function popCount (n) {
      n = n - ((n >> 1) & 0x55555555);
      n = (n & 0x33333333) + ((n >> 2) & 0x33333333);
      return ((n + (n >> 4) & 0xF0F0F0F) * 0x1010101) >> 24;
  }

  function binaryNode(k1, kh1, v1, k2, kh2, v2, s) {
      if (s >= 32) return new Collision([k1, k2], [v1, v2]);

      var b1 = (kh1 >>> s) & 31;
      var b2 = (kh2 >>> s) & 31;

      if (b1 !== b2) return new MapNode((1 << b1) | (1 << b2), 0, (b1 >>> 0) < (b2 >>> 0) ? [k1, v1, k2, v2] : [k2, v2, k1, v1]);

      return new MapNode(0, 1 << b1, [binaryNode(k1, kh1, v1, k2, kh2, v2, s + 5)]);
  }

  function overwriteTwoElements(a, index, v1, v2) {
      var res = a.slice();
      res[index] = v1;
      res[index+1] = v2;
      return res;
  }

  // TODO benchmark some alternative implementations (manual copy, slice
  // left + copy?, slice both + concat?, ...)
  function remove2(a, index) {
      var res = a.slice();
      res.splice(index, 2);
      return res;
  }

  // I think this is always called with a node index? Therefore, the
  // left will often be larger than the right. Does that help?
  function remove1(a, index) {
      var res = a.slice();
      res.splice(index, 1);
      return res;
  }

  // Make a copy while overwriting the element at index, or adding one element if index == a.length
  function copyAndOverwriteOrExtend1(a, index, v) {
      var res = a.slice();
      res[index] = v;
      return res;
  }

  function remove2insert1(a, removeIndex, insertIndex, v1) {
      var res = new Array(a.length - 1);
      for (var i = 0; i < removeIndex; i++) res[i] = a[i];
      for (; i < insertIndex; i++) res[i] = a[i+2];
      res[i++] = v1;
      for (; i < res.length; i++) res[i] = a[i+1];
      return res;
  }

  function insert2(a, index, v1, v2) {
      var res = new Array(a.length + 2);
      for (var i = 0; i < index; i++) res[i] = a[i];
      res[i++] = v1;
      res[i++] = v2;
      for (; i < res.length; i++) res[i] = a[i - 2];
      return res;
  }

  function insert2remove1(a, insertIndex, v1, v2, removeIndex) {
      var res = new Array(a.length + 1);
      for (var i = 0; i < insertIndex; i++) res[i] = a[i];
      res[i++] = v1;
      res[i++] = v2;
      for (; i < removeIndex + 2; i++) res[i] = a[i-2];
      for (; i < res.length; i++) res[i] = a[i-1];
      return res;
  }

  var empty = new MapNode(0,0,[]);

  exports.empty = empty;

  exports.lookupPurs = function (Nothing, Just, keyEquals, key, keyHash) {
      return function (m) {
          return m.lookup(Nothing, Just, keyEquals, key, keyHash, 0);
      };
  };

  exports.insertPurs = function (keyEquals, hashFunction) {
      return function (key) {
          return function (value) {
              return function (m) {
                  return m.insert(keyEquals, hashFunction, key, hashFunction(key), value, 0);
              };
          };
      };
  };

  exports.toArrayBy = function (f) {
      return function (m) {
          var res = [];
          m.toArrayBy(f, res);
          return res;
      };
  };

  function isEmpty (m) {
      return m.datamap === 0 && m.nodemap === 0;
  }
})(PS["Data.HashMap"] = PS["Data.HashMap"] || {});
(function(exports) {
  // This Source Code Form is subject to the terms of the Mozilla Public
  // License, v. 2.0. If a copy of the MPL was not distributed with this
  // file, You can obtain one at http://mozilla.org/MPL/2.0/.

  "use strict";

  exports.hashString = function (s) {
      var h = 0;
      for (var i = 0; i < s.length; i++) {
          h = (31 * h + s.charCodeAt(i)) | 0;
      }
      return h;
  };
})(PS["Data.Hashable"] = PS["Data.Hashable"] || {});
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Data.Hashable"] = $PS["Data.Hashable"] || {};
  var exports = $PS["Data.Hashable"];
  var $foreign = $PS["Data.Hashable"];
  var Data_Eq = $PS["Data.Eq"];
  var Hashable = function (Eq0, hash) {
      this.Eq0 = Eq0;
      this.hash = hash;
  }; 
  var hashableString = new Hashable(function () {
      return Data_Eq.eqString;
  }, $foreign.hashString);
  var hash = function (dict) {
      return dict.hash;
  };
  exports["hash"] = hash;
  exports["hashableString"] = hashableString;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Data.HashMap"] = $PS["Data.HashMap"] || {};
  var exports = $PS["Data.HashMap"];
  var $foreign = $PS["Data.HashMap"];
  var Data_Eq = $PS["Data.Eq"];
  var Data_Hashable = $PS["Data.Hashable"];
  var Data_Maybe = $PS["Data.Maybe"];
  var lookup = function (dictHashable) {
      return function (k) {
          return $foreign.lookupPurs(Data_Maybe.Nothing.value, Data_Maybe.Just.create, Data_Eq.eq(dictHashable.Eq0()), k, Data_Hashable.hash(dictHashable)(k));
      };
  };
  var insert = function (dictHashable) {
      return $foreign.insertPurs(Data_Eq.eq(dictHashable.Eq0()), Data_Hashable.hash(dictHashable));
  };
  exports["lookup"] = lookup;
  exports["insert"] = insert;
  exports["empty"] = $foreign.empty;
  exports["toArrayBy"] = $foreign.toArrayBy;
})(PS);
(function(exports) {
  "use strict";

  exports.toNumber = function (n) {
    return n;
  };
})(PS["Data.Int"] = PS["Data.Int"] || {});
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Data.Int"] = $PS["Data.Int"] || {};
  var exports = $PS["Data.Int"];
  var $foreign = $PS["Data.Int"];
  exports["toNumber"] = $foreign.toNumber;
})(PS);
(function(exports) {
  // global exports
  "use strict";

  exports.dateMethod = function(method, date) {
    return date[method]();
  };

  exports.parse = function(dateString) {
    return function() {
      return new Date(dateString);
    };
  };
})(PS["Data.JSDate"] = PS["Data.JSDate"] || {});
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Data.JSDate"] = $PS["Data.JSDate"] || {};
  var exports = $PS["Data.JSDate"];
  var $foreign = $PS["Data.JSDate"];
  var Data_Eq = $PS["Data.Eq"];
  var Data_Ord = $PS["Data.Ord"];                                                                                                                   
  var toDateString = function (dt) {
      return $foreign.dateMethod("toDateString", dt);
  };
  var getTime = function (dt) {
      return $foreign.dateMethod("getTime", dt);
  };
  var eqJSDate = new Data_Eq.Eq(function (a) {
      return function (b) {
          return getTime(a) === getTime(b);
      };
  });
  var ordJSDate = new Data_Ord.Ord(function () {
      return eqJSDate;
  }, function (a) {
      return function (b) {
          return Data_Ord.compare(Data_Ord.ordNumber)(getTime(a))(getTime(b));
      };
  });
  exports["getTime"] = getTime;
  exports["toDateString"] = toDateString;
  exports["ordJSDate"] = ordJSDate;
  exports["parse"] = $foreign.parse;
})(PS);
(function(exports) {
  /* eslint-disable no-eq-null, eqeqeq */

  "use strict";          

  exports.nullable = function (a, r, f) {
    return a == null ? r : f(a);
  };
})(PS["Data.Nullable"] = PS["Data.Nullable"] || {});
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Data.Nullable"] = $PS["Data.Nullable"] || {};
  var exports = $PS["Data.Nullable"];
  var $foreign = $PS["Data.Nullable"];
  var Data_Maybe = $PS["Data.Maybe"];                                   
  var toMaybe = function (n) {
      return $foreign.nullable(n, Data_Maybe.Nothing.value, Data_Maybe.Just.create);
  };
  exports["toMaybe"] = toMaybe;
})(PS);
(function(exports) {
  "use strict";

  exports.showNumberImpl = function (n) {
    var str = n.toString();
    return isNaN(str + ".0") ? str : str + ".0";
  };
})(PS["Data.Show"] = PS["Data.Show"] || {});
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Data.Show"] = $PS["Data.Show"] || {};
  var exports = $PS["Data.Show"];
  var $foreign = $PS["Data.Show"];
  var Show = function (show) {
      this.show = show;
  }; 
  var showNumber = new Show($foreign.showNumberImpl);
  var show = function (dict) {
      return dict.show;
  };
  exports["show"] = show;
  exports["showNumber"] = showNumber;
})(PS);
(function(exports) {
  "use strict";

  exports.trim = function (s) {
    return s.trim();
  };
})(PS["Data.String.Common"] = PS["Data.String.Common"] || {});
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Data.String.Common"] = $PS["Data.String.Common"] || {};
  var exports = $PS["Data.String.Common"];
  var $foreign = $PS["Data.String.Common"];
  exports["trim"] = $foreign.trim;
})(PS);
(function(exports) {
  "use strict";

  // jshint maxparams: 3

  exports.traverseArrayImpl = (function () {
    function array1(a) {
      return [a];
    }

    function array2(a) {
      return function (b) {
        return [a, b];
      };
    }

    function array3(a) {
      return function (b) {
        return function (c) {
          return [a, b, c];
        };
      };
    }

    function concat2(xs) {
      return function (ys) {
        return xs.concat(ys);
      };
    }

    return function (apply) {
      return function (map) {
        return function (pure) {
          return function (f) {
            return function (array) {
              function go(bot, top) {
                switch (top - bot) {
                case 0: return pure([]);
                case 1: return map(array1)(f(array[bot]));
                case 2: return apply(map(array2)(f(array[bot])))(f(array[bot + 1]));
                case 3: return apply(apply(map(array3)(f(array[bot])))(f(array[bot + 1])))(f(array[bot + 2]));
                default:
                  // This slightly tricky pivot selection aims to produce two
                  // even-length partitions where possible.
                  var pivot = bot + Math.floor((top - bot) / 4) * 2;
                  return apply(map(concat2)(go(bot, pivot)))(go(pivot, top));
                }
              }
              return go(0, array.length);
            };
          };
        };
      };
    };
  })();
})(PS["Data.Traversable"] = PS["Data.Traversable"] || {});
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Data.Traversable"] = $PS["Data.Traversable"] || {};
  var exports = $PS["Data.Traversable"];
  var $foreign = $PS["Data.Traversable"];
  var Control_Applicative = $PS["Control.Applicative"];
  var Control_Apply = $PS["Control.Apply"];
  var Control_Category = $PS["Control.Category"];
  var Data_Foldable = $PS["Data.Foldable"];
  var Data_Functor = $PS["Data.Functor"];            
  var Traversable = function (Foldable1, Functor0, sequence, traverse) {
      this.Foldable1 = Foldable1;
      this.Functor0 = Functor0;
      this.sequence = sequence;
      this.traverse = traverse;
  };
  var traverse = function (dict) {
      return dict.traverse;
  }; 
  var sequenceDefault = function (dictTraversable) {
      return function (dictApplicative) {
          return traverse(dictTraversable)(dictApplicative)(Control_Category.identity(Control_Category.categoryFn));
      };
  };
  var traversableArray = new Traversable(function () {
      return Data_Foldable.foldableArray;
  }, function () {
      return Data_Functor.functorArray;
  }, function (dictApplicative) {
      return sequenceDefault(traversableArray)(dictApplicative);
  }, function (dictApplicative) {
      return $foreign.traverseArrayImpl(Control_Apply.apply(dictApplicative.Apply0()))(Data_Functor.map((dictApplicative.Apply0()).Functor0()))(Control_Applicative.pure(dictApplicative));
  });
  exports["traverse"] = traverse;
  exports["traversableArray"] = traversableArray;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Data.Tuple"] = $PS["Data.Tuple"] || {};
  var exports = $PS["Data.Tuple"];                 
  var Tuple = (function () {
      function Tuple(value0, value1) {
          this.value0 = value0;
          this.value1 = value1;
      };
      Tuple.create = function (value0) {
          return function (value1) {
              return new Tuple(value0, value1);
          };
      };
      return Tuple;
  })();
  var uncurry = function (f) {
      return function (v) {
          return f(v.value0)(v.value1);
      };
  };
  var snd = function (v) {
      return v.value1;
  };
  exports["Tuple"] = Tuple;
  exports["snd"] = snd;
  exports["uncurry"] = uncurry;
})(PS);
(function(exports) {
  "use strict";

  exports.pureE = function (a) {
    return function () {
      return a;
    };
  };

  exports.bindE = function (a) {
    return function (f) {
      return function () {
        return f(a())();
      };
    };
  };
})(PS["Effect"] = PS["Effect"] || {});
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Effect"] = $PS["Effect"] || {};
  var exports = $PS["Effect"];
  var $foreign = $PS["Effect"];
  var Control_Applicative = $PS["Control.Applicative"];
  var Control_Apply = $PS["Control.Apply"];
  var Control_Bind = $PS["Control.Bind"];
  var Control_Monad = $PS["Control.Monad"];
  var Data_Functor = $PS["Data.Functor"];                    
  var monadEffect = new Control_Monad.Monad(function () {
      return applicativeEffect;
  }, function () {
      return bindEffect;
  });
  var bindEffect = new Control_Bind.Bind(function () {
      return applyEffect;
  }, $foreign.bindE);
  var applyEffect = new Control_Apply.Apply(function () {
      return functorEffect;
  }, Control_Monad.ap(monadEffect));
  var applicativeEffect = new Control_Applicative.Applicative(function () {
      return applyEffect;
  }, $foreign.pureE);
  var functorEffect = new Data_Functor.Functor(Control_Applicative.liftA1(applicativeEffect));
  exports["functorEffect"] = functorEffect;
  exports["applicativeEffect"] = applicativeEffect;
  exports["bindEffect"] = bindEffect;
})(PS);
(function(exports) {
  "use strict";

  exports.error = function (msg) {
    return new Error(msg);
  };

  exports.throwException = function (e) {
    return function () {
      throw e;
    };
  };
})(PS["Effect.Exception"] = PS["Effect.Exception"] || {});
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Effect.Exception"] = $PS["Effect.Exception"] || {};
  var exports = $PS["Effect.Exception"];
  var $foreign = $PS["Effect.Exception"];
  var $$throw = function ($2) {
      return $foreign.throwException($foreign.error($2));
  };
  exports["throw"] = $$throw;
})(PS);
(function(exports) {
  "use strict";

  exports.innerText = function(element) {
      return function() {
          return element.innerText;
      };
  };

  exports.renderDateTime = function(date) {
      return function() {
          return date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
      };
  };
})(PS["Main"] = PS["Main"] || {});
(function(exports) {
  "use strict";

  exports.remove = function (node) {
    return function () {
      return node.remove();
    };
  };
})(PS["Web.DOM.ChildNode"] = PS["Web.DOM.ChildNode"] || {});
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Web.DOM.ChildNode"] = $PS["Web.DOM.ChildNode"] || {};
  var exports = $PS["Web.DOM.ChildNode"];
  var $foreign = $PS["Web.DOM.ChildNode"];
  exports["remove"] = $foreign.remove;
})(PS);
(function(exports) {
  "use strict";

  exports.createElement = function (localName) {
    return function (doc) {
      return function () {
        return doc.createElement(localName);
      };
    };
  };
})(PS["Web.DOM.Document"] = PS["Web.DOM.Document"] || {});
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Web.DOM.Document"] = $PS["Web.DOM.Document"] || {};
  var exports = $PS["Web.DOM.Document"];
  var $foreign = $PS["Web.DOM.Document"];
  exports["createElement"] = $foreign.createElement;
})(PS);
(function(exports) {
  "use strict";

  exports.setAttribute = function (name) {
    return function (value) {
      return function (element) {
        return function () {
          element.setAttribute(name, value);
        };
      };
    };
  };
})(PS["Web.DOM.Element"] = PS["Web.DOM.Element"] || {});
(function(exports) {
  "use strict";

  // module Unsafe.Coerce

  exports.unsafeCoerce = function (x) {
    return x;
  };
})(PS["Unsafe.Coerce"] = PS["Unsafe.Coerce"] || {});
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Unsafe.Coerce"] = $PS["Unsafe.Coerce"] || {};
  var exports = $PS["Unsafe.Coerce"];
  var $foreign = $PS["Unsafe.Coerce"];
  exports["unsafeCoerce"] = $foreign.unsafeCoerce;
})(PS);
(function(exports) {
  "use strict";

  exports._unsafeReadProtoTagged = function (nothing, just, name, value) {
    if (typeof window !== "undefined") {
      var ty = window[name];
      if (ty != null && value instanceof ty) {
        return just(value);
      }
    }
    var obj = value;
    while (obj != null) {
      var proto = Object.getPrototypeOf(obj);
      var constructorName = proto.constructor.name;
      if (constructorName === name) {
        return just(value);
      } else if (constructorName === "Object") {
        return nothing;
      }
      obj = proto;
    }
    return nothing;
  };
})(PS["Web.Internal.FFI"] = PS["Web.Internal.FFI"] || {});
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Web.Internal.FFI"] = $PS["Web.Internal.FFI"] || {};
  var exports = $PS["Web.Internal.FFI"];
  var $foreign = $PS["Web.Internal.FFI"];
  var Data_Maybe = $PS["Data.Maybe"];                
  var unsafeReadProtoTagged = function (name) {
      return function (value) {
          return $foreign["_unsafeReadProtoTagged"](Data_Maybe.Nothing.value, Data_Maybe.Just.create, name, value);
      };
  };
  exports["unsafeReadProtoTagged"] = unsafeReadProtoTagged;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Web.DOM.Element"] = $PS["Web.DOM.Element"] || {};
  var exports = $PS["Web.DOM.Element"];
  var $foreign = $PS["Web.DOM.Element"];
  var Unsafe_Coerce = $PS["Unsafe.Coerce"];
  var Web_Internal_FFI = $PS["Web.Internal.FFI"];                
  var toParentNode = Unsafe_Coerce.unsafeCoerce;              
  var toNode = Unsafe_Coerce.unsafeCoerce;       
  var toChildNode = Unsafe_Coerce.unsafeCoerce;                                        
  var fromNode = Web_Internal_FFI.unsafeReadProtoTagged("Element");
  exports["fromNode"] = fromNode;
  exports["toNode"] = toNode;
  exports["toChildNode"] = toChildNode;
  exports["toParentNode"] = toParentNode;
  exports["setAttribute"] = $foreign.setAttribute;
})(PS);
(function(exports) {
  "use strict";

  exports.toArray = function (list) {
    return function () {
      return [].slice.call(list);
    };
  };
})(PS["Web.DOM.HTMLCollection"] = PS["Web.DOM.HTMLCollection"] || {});
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Web.DOM.HTMLCollection"] = $PS["Web.DOM.HTMLCollection"] || {};
  var exports = $PS["Web.DOM.HTMLCollection"];
  var $foreign = $PS["Web.DOM.HTMLCollection"];
  exports["toArray"] = $foreign.toArray;
})(PS);
(function(exports) {
  "use strict";                                   

  exports.setTextContent = function (value) {
    return function (node) {
      return function () {
        node.textContent = value;
      };
    };
  };

  exports.appendChild = function (node) {
    return function (parent) {
      return function () {
        parent.appendChild(node);
      };
    };
  };
})(PS["Web.DOM.Node"] = PS["Web.DOM.Node"] || {});
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Web.DOM.Node"] = $PS["Web.DOM.Node"] || {};
  var exports = $PS["Web.DOM.Node"];
  var $foreign = $PS["Web.DOM.Node"];
  exports["setTextContent"] = $foreign.setTextContent;
  exports["appendChild"] = $foreign.appendChild;
})(PS);
(function(exports) {
  "use strict";

  exports.toArray = function (list) {
    return function () {
      return [].slice.call(list);
    };
  };
})(PS["Web.DOM.NodeList"] = PS["Web.DOM.NodeList"] || {});
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Web.DOM.NodeList"] = $PS["Web.DOM.NodeList"] || {};
  var exports = $PS["Web.DOM.NodeList"];
  var $foreign = $PS["Web.DOM.NodeList"];
  exports["toArray"] = $foreign.toArray;
})(PS);
(function(exports) {
  "use strict";

  var getEffProp = function (name) {
    return function (node) {
      return function () {
        return node[name];
      };
    };
  };

  exports.children = getEffProp("children");                  

  exports._querySelector = function (selector) {
    return function (node) {
      return function () {
        return node.querySelector(selector);
      };
    };
  };

  exports.querySelectorAll = function (selector) {
    return function (node) {
      return function () {
        return node.querySelectorAll(selector);
      };
    };
  };
})(PS["Web.DOM.ParentNode"] = PS["Web.DOM.ParentNode"] || {});
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Web.DOM.ParentNode"] = $PS["Web.DOM.ParentNode"] || {};
  var exports = $PS["Web.DOM.ParentNode"];
  var $foreign = $PS["Web.DOM.ParentNode"];
  var Data_Functor = $PS["Data.Functor"];
  var Data_Nullable = $PS["Data.Nullable"];
  var Effect = $PS["Effect"];
  var querySelector = function (qs) {
      var $0 = Data_Functor.map(Effect.functorEffect)(Data_Nullable.toMaybe);
      var $1 = $foreign["_querySelector"](qs);
      return function ($2) {
          return $0($1($2));
      };
  };
  exports["querySelector"] = querySelector;
  exports["children"] = $foreign.children;
  exports["querySelectorAll"] = $foreign.querySelectorAll;
})(PS);
(function(exports) {
  "use strict";

  exports.window = function () {
    return window;
  };
})(PS["Web.HTML"] = PS["Web.HTML"] || {});
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Web.HTML"] = $PS["Web.HTML"] || {};
  var exports = $PS["Web.HTML"];
  var $foreign = $PS["Web.HTML"];
  exports["window"] = $foreign.window;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Web.HTML.HTMLDocument"] = $PS["Web.HTML.HTMLDocument"] || {};
  var exports = $PS["Web.HTML.HTMLDocument"];
  var Unsafe_Coerce = $PS["Unsafe.Coerce"];                      
  var toParentNode = Unsafe_Coerce.unsafeCoerce; 
  var toDocument = Unsafe_Coerce.unsafeCoerce;
  exports["toDocument"] = toDocument;
  exports["toParentNode"] = toParentNode;
})(PS);
(function(exports) {
  "use strict";

  exports._read = function (nothing, just, value) {
    var tag = Object.prototype.toString.call(value);
    if (tag.indexOf("[object HTML") === 0 && tag.indexOf("Element]") === tag.length - 8) {
      return just(value);
    } else {
      return nothing;
    }
  };
})(PS["Web.HTML.HTMLElement"] = PS["Web.HTML.HTMLElement"] || {});
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Web.HTML.HTMLElement"] = $PS["Web.HTML.HTMLElement"] || {};
  var exports = $PS["Web.HTML.HTMLElement"];
  var $foreign = $PS["Web.HTML.HTMLElement"];
  var Data_Maybe = $PS["Data.Maybe"];
  var fromNode = function (x) {
      return $foreign["_read"](Data_Maybe.Nothing.value, Data_Maybe.Just.create, x);
  };
  exports["fromNode"] = fromNode;
})(PS);
(function(exports) {
  "use strict";

  exports.document = function (window) {
    return function () {
      return window.document;
    };
  };
})(PS["Web.HTML.Window"] = PS["Web.HTML.Window"] || {});
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Web.HTML.Window"] = $PS["Web.HTML.Window"] || {};
  var exports = $PS["Web.HTML.Window"];
  var $foreign = $PS["Web.HTML.Window"];
  exports["document"] = $foreign.document;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Main"] = $PS["Main"] || {};
  var exports = $PS["Main"];
  var $foreign = $PS["Main"];
  var Control_Applicative = $PS["Control.Applicative"];
  var Control_Bind = $PS["Control.Bind"];
  var Data_Array = $PS["Data.Array"];
  var Data_Boolean = $PS["Data.Boolean"];
  var Data_Foldable = $PS["Data.Foldable"];
  var Data_Function = $PS["Data.Function"];
  var Data_Functor = $PS["Data.Functor"];
  var Data_HashMap = $PS["Data.HashMap"];
  var Data_Hashable = $PS["Data.Hashable"];
  var Data_Int = $PS["Data.Int"];
  var Data_JSDate = $PS["Data.JSDate"];
  var Data_Maybe = $PS["Data.Maybe"];
  var Data_Ord = $PS["Data.Ord"];
  var Data_Show = $PS["Data.Show"];
  var Data_String_Common = $PS["Data.String.Common"];
  var Data_Traversable = $PS["Data.Traversable"];
  var Data_Tuple = $PS["Data.Tuple"];
  var Effect = $PS["Effect"];
  var Effect_Exception = $PS["Effect.Exception"];
  var Web_DOM_ChildNode = $PS["Web.DOM.ChildNode"];
  var Web_DOM_Document = $PS["Web.DOM.Document"];
  var Web_DOM_Element = $PS["Web.DOM.Element"];
  var Web_DOM_HTMLCollection = $PS["Web.DOM.HTMLCollection"];
  var Web_DOM_Node = $PS["Web.DOM.Node"];
  var Web_DOM_NodeList = $PS["Web.DOM.NodeList"];
  var Web_DOM_ParentNode = $PS["Web.DOM.ParentNode"];
  var Web_HTML = $PS["Web.HTML"];
  var Web_HTML_HTMLDocument = $PS["Web.HTML.HTMLDocument"];
  var Web_HTML_HTMLElement = $PS["Web.HTML.HTMLElement"];
  var Web_HTML_Window = $PS["Web.HTML.Window"];                
  var Single = (function () {
      function Single(value0) {
          this.value0 = value0;
      };
      Single.create = function (value0) {
          return new Single(value0);
      };
      return Single;
  })();
  var After = (function () {
      function After(value0, value1) {
          this.value0 = value0;
          this.value1 = value1;
      };
      After.create = function (value0) {
          return function (value1) {
              return new After(value0, value1);
          };
      };
      return After;
  })();
  var Parallel = (function () {
      function Parallel(value0, value1) {
          this.value0 = value0;
          this.value1 = value1;
      };
      Parallel.create = function (value0) {
          return function (value1) {
              return new Parallel(value0, value1);
          };
      };
      return Parallel;
  })();
  var scheduleStart = function (v) {
      if (v instanceof Single) {
          return v.value0.start;
      };
      if (v instanceof After) {
          return scheduleStart(v.value0);
      };
      if (v instanceof Parallel) {
          return Data_Ord.min(Data_JSDate.ordJSDate)(scheduleStart(v.value0))(scheduleStart(v.value1));
      };
      throw new Error("Failed pattern match at Main (line 43, column 1 - line 43, column 53): " + [ v.constructor.name ]);
  };
  var scheduleParallelism = function (v) {
      if (v instanceof Single) {
          return 1;
      };
      if (v instanceof After) {
          return Data_Ord.max(Data_Ord.ordInt)(scheduleParallelism(v.value0))(scheduleParallelism(v.value1));
      };
      if (v instanceof Parallel) {
          return scheduleParallelism(v.value0) + scheduleParallelism(v.value1) | 0;
      };
      throw new Error("Failed pattern match at Main (line 53, column 1 - line 53, column 51): " + [ v.constructor.name ]);
  };
  var scheduleEnd = function (v) {
      if (v instanceof Single) {
          return v.value0.end;
      };
      if (v instanceof After) {
          return scheduleEnd(v.value1);
      };
      if (v instanceof Parallel) {
          return Data_Ord.max(Data_JSDate.ordJSDate)(scheduleEnd(v.value0))(scheduleEnd(v.value1));
      };
      throw new Error("Failed pattern match at Main (line 48, column 1 - line 48, column 51): " + [ v.constructor.name ]);
  };
  var scheduleInsert = function (entry) {
      return function (schedule) {
          if (Data_Ord.greaterThanOrEq(Data_JSDate.ordJSDate)(entry.start)(scheduleEnd(schedule))) {
              return new After(schedule, new Single(entry));
          };
          if (Data_Ord.lessThanOrEq(Data_JSDate.ordJSDate)(entry.end)(scheduleStart(schedule))) {
              return new After(new Single(entry), schedule);
          };
          if (Data_Boolean.otherwise) {
              if (schedule instanceof Single) {
                  return new Parallel(new Single(schedule.value0), new Single(entry));
              };
              if (schedule instanceof After) {
                  if (Data_Ord.greaterThanOrEq(Data_JSDate.ordJSDate)(entry.start)(scheduleEnd(schedule.value0))) {
                      return new After(schedule.value0, scheduleInsert(entry)(schedule.value1));
                  };
                  if (Data_Ord.lessThanOrEq(Data_JSDate.ordJSDate)(entry.end)(scheduleEnd(schedule.value1))) {
                      return new After(scheduleInsert(entry)(schedule.value0), schedule.value1);
                  };
                  if (Data_Boolean.otherwise) {
                      return new Parallel(new After(schedule.value0, schedule.value1), new Single(entry));
                  };
              };
              if (schedule instanceof Parallel) {
                  var y$prime = scheduleInsert(entry)(schedule.value1);
                  var x$prime = scheduleInsert(entry)(schedule.value0);
                  var r = scheduleParallelism(schedule.value0) + scheduleParallelism(y$prime) | 0;
                  var l = scheduleParallelism(x$prime) + scheduleParallelism(schedule.value1) | 0;
                  var $29 = l < r;
                  if ($29) {
                      return new Parallel(x$prime, schedule.value1);
                  };
                  return new Parallel(schedule.value0, y$prime);
              };
              throw new Error("Failed pattern match at Main (line 66, column 19 - line 79, column 59): " + [ schedule.constructor.name ]);
          };
          throw new Error("Failed pattern match at Main (line 60, column 1 - line 60, column 64): " + [ entry.constructor.name, schedule.constructor.name ]);
      };
  };
  var scheduleRender = function (doc) {
      return function (day) {
          return function (schedule0) {
              var zero = scheduleStart(schedule0);
              var ticks = function (date) {
                  return Data_JSDate.getTime(date) / 1000.0 / 60.0;
              };
              var go = function (container) {
                  return function (left) {
                      return function (width) {
                          return function (schedule) {
                              if (schedule instanceof Single) {
                                  var y = (ticks(schedule.value0.start) - ticks(zero)) + Data_Int.toNumber(30);
                                  var height = ticks(schedule.value0.end) - ticks(schedule.value0.start);
                                  return function __do() {
                                      var div = (function () {
                                          var v = Data_String_Common.trim(schedule.value0.content.link);
                                          if (v === "") {
                                              return Web_DOM_Document.createElement("div")(doc)();
                                          };
                                          var a = Web_DOM_Document.createElement("a")(doc)();
                                          Web_DOM_Element.setAttribute("href")(v)(a)();
                                          return a;
                                      })();
                                      Web_DOM_Element.setAttribute("class")("entry " + schedule.value0.content.kind)(div)();
                                      Web_DOM_Element.setAttribute("style")("position: absolute;" + ("top: " + (Data_Show.show(Data_Show.showNumber)(y) + ("px;" + ("left: " + (Data_Show.show(Data_Show.showNumber)(left) + ("%; " + ("width: " + (Data_Show.show(Data_Show.showNumber)(width) + ("%; " + ("height: " + (Data_Show.show(Data_Show.showNumber)(height) + "px;"))))))))))))(div)();
                                      var startStr = $foreign.renderDateTime(schedule.value0.start)();
                                      var endStr = $foreign.renderDateTime(schedule.value0.end)();
                                      Web_DOM_Node.setTextContent(startStr + (" - " + (endStr + (": " + schedule.value0.content.title))))(Web_DOM_Element.toNode(div))();
                                      return Web_DOM_Node.appendChild(Web_DOM_Element.toNode(div))(Web_DOM_Element.toNode(container))();
                                  };
                              };
                              if (schedule instanceof After) {
                                  return function __do() {
                                      go(container)(left)(width)(schedule.value0)();
                                      return go(container)(left)(width)(schedule.value1)();
                                  };
                              };
                              if (schedule instanceof Parallel) {
                                  var yp = Data_Int.toNumber(scheduleParallelism(schedule.value1));
                                  var xp = Data_Int.toNumber(scheduleParallelism(schedule.value0));
                                  var unitWidth = width / (xp + yp);
                                  return function __do() {
                                      go(container)(left)(xp * unitWidth)(schedule.value0)();
                                      return go(container)(left + xp * unitWidth)(yp * unitWidth)(schedule.value1)();
                                  };
                              };
                              throw new Error("Failed pattern match at Main (line 105, column 40 - line 141, column 68): " + [ schedule.constructor.name ]);
                          };
                      };
                  };
              };
              return function __do() {
                  var container = Web_DOM_Document.createElement("div")(doc)();
                  var start = ticks(scheduleStart(schedule0));
                  var end = ticks(scheduleEnd(schedule0));
                  var height = (end - start) + Data_Int.toNumber(30);
                  Web_DOM_Element.setAttribute("class")("day")(container)();
                  Web_DOM_Element.setAttribute("style")("position: relative; height: " + (Data_Show.show(Data_Show.showNumber)(height) + "px;"))(container)();
                  var div = Web_DOM_Document.createElement("div")(doc)();
                  Web_DOM_Element.setAttribute("class")("date")(div)();
                  Web_DOM_Node.setTextContent(day)(Web_DOM_Element.toNode(div))();
                  Web_DOM_Node.appendChild(Web_DOM_Element.toNode(div))(Web_DOM_Element.toNode(container))();
                  go(container)(0.0)(100.0)(schedule0)();
                  return container;
              };
          };
      };
  };
  var parseEntry = function (element) {
      return function __do() {
          var cells = Control_Bind.bind(Effect.bindEffect)(Control_Bind.bind(Effect.bindEffect)(Control_Bind.bind(Effect.bindEffect)(Web_DOM_ParentNode.querySelectorAll("td")(Web_DOM_Element.toParentNode(element)))(Web_DOM_NodeList.toArray))((function () {
              var $53 = Control_Applicative.pure(Effect.applicativeEffect);
              var $54 = Data_Array.mapMaybe(Web_HTML_HTMLElement.fromNode);
              return function ($55) {
                  return $53($54($55));
              };
          })()))(Data_Traversable.traverse(Data_Traversable.traversableArray)(Effect.applicativeEffect)($foreign.innerText))();
          if (cells.length === 5) {
              var start = Data_JSDate.parse(cells[0])();
              var end = Data_JSDate.parse(cells[1])();
              return new Data_Maybe.Just({
                  start: start,
                  end: end,
                  content: {
                      kind: cells[2],
                      link: cells[3],
                      title: cells[4]
                  }
              });
          };
          return Data_Maybe.Nothing.value;
      };
  };
  var parseEntries = function (schedule) {
      return function __do() {
          var trs = Control_Bind.bind(Effect.bindEffect)(Web_DOM_ParentNode.querySelectorAll("tr")(Web_DOM_Element.toParentNode(schedule)))(Web_DOM_NodeList.toArray)();
          return Data_Functor.map(Effect.functorEffect)(Data_Array.catMaybes)(Data_Traversable.traverse(Data_Traversable.traversableArray)(Effect.applicativeEffect)(parseEntry)(Data_Array.mapMaybe(Web_DOM_Element.fromNode)(trs)))();
      };
  };
  var calendarRender = function (doc) {
      return function (calendar) {
          return Data_Traversable.traverse(Data_Traversable.traversableArray)(Effect.applicativeEffect)(Data_Tuple.uncurry(scheduleRender(doc)))(Data_Array.sortWith(Data_JSDate.ordJSDate)(function ($56) {
              return scheduleStart(Data_Tuple.snd($56));
          })(Data_HashMap.toArrayBy(Data_Tuple.Tuple.create)(calendar)));
      };
  };
  var calendarInsert = function (entry) {
      return function (calendar) {
          var day = Data_JSDate.toDateString(entry.start);
          var v = Data_HashMap.lookup(Data_Hashable.hashableString)(day)(calendar);
          if (v instanceof Data_Maybe.Nothing) {
              return Data_HashMap.insert(Data_Hashable.hashableString)(day)(new Single(entry))(calendar);
          };
          if (v instanceof Data_Maybe.Just) {
              return Data_HashMap.insert(Data_Hashable.hashableString)(day)(scheduleInsert(entry)(v.value0))(calendar);
          };
          throw new Error("Failed pattern match at Main (line 151, column 33 - line 153, column 72): " + [ v.constructor.name ]);
      };
  };
  var calendarFromEntries = Data_Array.foldl(Data_Function.flip(calendarInsert))(Data_HashMap.empty);
  var main = function __do() {
      var window = Web_HTML.window();
      var doc = Web_HTML_Window.document(window)();
      var schedule = Control_Bind.bind(Effect.bindEffect)(Web_DOM_ParentNode.querySelector(".schedule")(Web_HTML_HTMLDocument.toParentNode(doc)))(Data_Maybe.maybe(Effect_Exception["throw"]("no schedule"))(Control_Applicative.pure(Effect.applicativeEffect)))();
      var calendar = Data_Functor.map(Effect.functorEffect)(calendarFromEntries)(parseEntries(schedule))();
      Control_Bind.bind(Effect.bindEffect)(Control_Bind.bind(Effect.bindEffect)(Web_DOM_ParentNode.children(Web_DOM_Element.toParentNode(schedule)))(Web_DOM_HTMLCollection.toArray))(Data_Foldable.traverse_(Effect.applicativeEffect)(Data_Foldable.foldableArray)(function ($57) {
          return Web_DOM_ChildNode.remove(Web_DOM_Element.toChildNode($57));
      }))();
      var rendered = calendarRender(Web_HTML_HTMLDocument.toDocument(doc))(calendar)();
      return Data_Foldable.for_(Effect.applicativeEffect)(Data_Foldable.foldableArray)(rendered)(function (c) {
          return Web_DOM_Node.appendChild(Web_DOM_Element.toNode(c))(Web_DOM_Element.toNode(schedule));
      })();
  };
  exports["Single"] = Single;
  exports["After"] = After;
  exports["Parallel"] = Parallel;
  exports["scheduleStart"] = scheduleStart;
  exports["scheduleEnd"] = scheduleEnd;
  exports["scheduleParallelism"] = scheduleParallelism;
  exports["scheduleInsert"] = scheduleInsert;
  exports["scheduleRender"] = scheduleRender;
  exports["calendarInsert"] = calendarInsert;
  exports["calendarFromEntries"] = calendarFromEntries;
  exports["calendarRender"] = calendarRender;
  exports["parseEntry"] = parseEntry;
  exports["parseEntries"] = parseEntries;
  exports["main"] = main;
  exports["innerText"] = $foreign.innerText;
  exports["renderDateTime"] = $foreign.renderDateTime;
})(PS);
PS["Main"].main();