<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ZuriHac 2021</title>
  <link rel="icon" type="image/png" href="/images/favicon.png" />
  <link rel="stylesheet" type="text/css" href="/css/zurihac2021.css?v=6" />

  <meta property="og:title" content="ZuriHac 2021" />
  <meta property="og:description"
    content="ZuriHac is a free annual Haskell event brought to you by «Zürich Friends of Haskell»" />
  <meta property="og:image" content="https://zfoh.ch/images/zurihac2021/header.png" />

  <meta name="twitter:title" content="ZuriHac 2021" />
  <meta name="twitter:description"
    content="ZuriHac is a free annual Haskell event brought to you by «Zürich Friends of Haskell»" />
  <meta name="twitter:image" content="https://zfoh.ch/images/zurihac2021/header.png" />

  <meta name="twitter:card" content="summary" />
  <style>
    :root {
      --ani-total-duration: 60s;
      --floater-y: 0;
      --floater-z: 1;
    }
    @media screen and (max-width: 768px) {
      :root{
        --ani-total-duration: 30s;
      }
    }

    header {
      position: relative;
      height: 400px;
      overflow-x: hidden;
      top: 0;
      left: 0;
      right: 0;
      background-image: url("/images/zurihac2021/header-fill.svg");
      background-size: auto 400px;
      background-repeat: repeat-x;
      background-position: center;
    }

    .floater {
      position: absolute;
      width: 300px;
      height: 300px;
      animation: moving calc(var(--ani-total-duration) / var(--floater-z)) linear infinite both;
    }

    .floater .logo,
    .floater .cloud {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }

    .floater .cloud {
      animation: cloud-frames var(--ani-total-duration) infinite both;
    }
    .floater .logo {
      animation: logo-frames var(--ani-total-duration) infinite both;
    }

    .floater.cloud-a,
    .floater.cloud-a .logo,
    .floater.cloud-a .cloud {
      animation-delay: 0s;
      --floater-z: 1;
      --floater-y: 40px;
    }

    .floater.cloud-b,
    .floater.cloud-b .logo,
    .floater.cloud-b .cloud {
      animation-delay: calc(var(--ani-total-duration) / -5);
      --floater-y: -100px;
      --floater-z: 2;
    }

    .floater.cloud-c,
    .floater.cloud-c .logo,
    .floater.cloud-c .cloud {
      animation-delay: calc(var(--ani-total-duration) / -3 * 2);
      --floater-z: 3;
      --floater-y: -50px;
    }

    @keyframes cloud-frames {
      0% {   filter: blur( 0px); opacity: 1.0; }
      20% {  filter: blur( 0px); opacity: 1.0; }
      50% {  filter: blur(25px); opacity: 0.0; }
      80% {  filter: blur( 0px); opacity: 1.0; }
      100% { filter: blur( 0px); opacity: 1.0; }
    }

    @keyframes logo-frames {
      0% {   filter: blur(25px); opacity: 0.0; }
      10% {  filter: blur(25px); opacity: 0.0; }
      45% {  filter: blur( 0px); opacity: 1.0; }
      55% {  filter: blur( 0px); opacity: 1.0; }
      90% {  filter: blur(25px); opacity: 0.0; }
      100% { filter: blur(25px); opacity: 0.0; }
    }

    @keyframes moving {
      0% {
        transform: translate3d(-100%,var(--floater-y),0) scale(calc(0.5 * var(--floater-z)));
      }
      100% {
        transform: translate3d(100vw,var(--floater-y),0) scale(calc(0.5 * var(--floater-z)));
      }
    }

    .header-background, .header-foreground{
      position: absolute;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-size: auto 400px;
      background-repeat: no-repeat;
      background-position: center;
    }

    .header-background {
      background-image: url("/images/zurihac2021/header-background.svg");
    }

    .header-foreground {
      background-image: url("/images/zurihac2021/header-foreground.svg");
    }

  </style>
</head>

<body>
  <header>
    <img class="header-background">
    <div class="floater cloud-a">
      <img src="/images/zurihac2021/cloud-a.svg" alt="abstract cloud" class="cloud">
      <img src="/images/zurihac2021/cloud-logo.svg" alt="zurihac2021 logo" class="logo">
    </div>
    <img class="header-foreground">
    <div class="floater cloud-b">
      <img src="/images/zurihac2021/cloud-b.svg" alt="abstract cloud" class="cloud">
      <img src="/images/zurihac2021/cloud-logo.svg" alt="zurihac2021 logo" class="logo">
    </div>
    <div class="floater cloud-c">
      <img src="/images/zurihac2021/cloud-c.svg" alt="abstract cloud" class="cloud">
      <img src="/images/zurihac2021/cloud-logo.svg" alt="zurihac2021 logo" class="logo">
    </div>
  </header>

  <main>
    <section>
  <h1>___ZURIHAC_2021___</h1>
  <a href="/zurihac2022/" target="_blank" class="retro">
    ZuriHac 2021 is over: go here for ZuriHac 2022!
  </a>
  <h2>WHAT_IS_ZURIHAC</h2>
  <p>
    ZuriHac is the biggest <a href="https://haskell.org">Haskell</a> Hackathon
    in the world: a <strong>completely free</strong>, three-day grassroots
    coding festival organized by
    <a href="https://zfoh.ch/">Zürich Friends of Haskell</a>.
    It features fantastic keynotes, hands-on tracks, and of course lots of
    hacking and socializing!
  </p>
  <p>
    ZuriHac takes place <strong>Friday 18 June — Sunday 20 June</strong> 2021.
  <p>

  <h2 id="covid19">COVID19_INFORMATION</h2>
  <div class="raise">
    <p>
      Due to the still ongoing pandemic, ZuriHac 2021 will be a
      <strong>virtual event</strong>.  We hope to return as a real-life event in
      2022.
    </p>
  </div>

  <h2 id="covid19">LIVE_VIDEOS</h2>
  <br>
  <!-- See <https://avexdesigns.com/blog/responsive-youtube-embed> -->
  <div style="position: relative; padding-bottom: 56.25%; padding-top: 30px; height: 0; overflow: hidden">
    <iframe style="position: absolute; top: 0; left: 0; width: 100%; height: 100%"
        width="560" height="315" src="https://www.youtube-nocookie.com/embed/videoseries?list=PLiU7KJ5_df6YhHefoPfUP1VSd1AbOC02R" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
  </div>
</section>

<h1 id="registration">___REGISTRATION___</h1>
<section>
  <p>
    ZuriHac 2021 is an online event, but we still require registration.  After
    registering, you will receive an invite to our Discord server, where we
    will host the Hackathon.
  </p>
  <p>
    <strong>Registration for ZuriHac 2021 is closed.</strong>
  </p>
  <a href="/zurihac2022/" target="_blank" class="retro">
    Go here for ZuriHac 2022!
  </a>
</section>

<h1 id="program">___PROGRAM___</h1>

<div class="inverted">
  <div id="schedule-description" style="margin: .5em auto; max-width: 1000px">
    It is also available as a
    <a href="https://calendar.google.com/calendar/embed?src=208isgf6m89473jiuk2pqme97g%40group.calendar.google.com">Public Google Calendar</a>,
    that you can e.g. add to your smartphone or personal calendar.
    <br><br>
  </div>

  <script type="text/JavaScript">
    const original = document.getElementById("schedule-description").innerHTML;
    document.getElementById("schedule-description").innerHTML =
        "The schedule is displayed in your browser's timezone (" +
        Intl.DateTimeFormat().resolvedOptions().timeZone + "). " +
        original ;
  </script>

  <div class="schedule" id="schedule">
    <table>
      <tr><th>Start                    </th><th>End                      </th><th>Kind    </th><th>Link                        </th><th>Title</th></tr>
      <tr><td>2021-06-18T18:00:00+02:00</td><td>2021-06-18T19:30:00+02:00</td><td>talk    </td><td>#speaker-john-hughes        </td><td>Opening &amp; Talk by John Hughes: Testing smart contracts with QuickCheck</td></tr></tr>
      <tr><td>2021-06-18T19:45:00+02:00</td><td>2021-06-18T20:45:00+02:00</td><td>partner </td><td>                            </td><td>Digital Asset: Haskell in the industry, DAML, Q&amp;A</td></tr></tr>

      <tr><td>2021-06-19T10:00:00+02:00</td><td>2021-06-19T11:15:00+02:00</td><td>talk    </td><td>#speaker-ollie-charles      </td><td>Talk by Ollie Charles: Rel8: A new database access library for Haskell</td></tr></tr>
      <tr><td>2021-06-19T11:30:00+02:00</td><td>2021-06-19T12:30:00+02:00</td><td>partner </td><td>                            </td><td>Fretlink: Fun haskell for regular stuff, Q&amp;A</td></tr></tr>
      <tr><td>2021-06-19T12:30:00+02:00</td><td>2021-06-19T13:30:00+02:00</td><td>partner </td><td>                            </td><td>Tweag: building Haskell with Bazel</td></tr></tr>
      <tr><td>2021-06-19T14:00:00+02:00</td><td>2021-06-19T15:00:00+02:00</td><td>beginner</td><td>                            </td><td>Haskell install party</td></tr></tr>
      <tr><td>2021-06-19T16:00:00+02:00</td><td>2021-06-19T17:30:00+02:00</td><td>beginner</td><td>#beginner-track             </td><td>Beginner Track</td></tr></tr>
      <tr><td>2021-06-19T14:00:00+02:00</td><td>2021-06-19T17:00:00+02:00</td><td>advanced</td><td>#advanced-track             </td><td>Advanced Track: Optics in the abstract</td></tr></tr>
      <tr><td>2021-06-19T17:00:00+02:00</td><td>2021-06-19T18:00:00+02:00</td><td>talk    </td><td>                            </td><td>GHC Panel Discussion with Simon Peyton Jones</td></tr></tr>
      <tr><td>2021-06-19T18:00:00+02:00</td><td>2021-06-19T19:15:00+02:00</td><td>talk    </td><td>#speaker-emily-pillmore     </td><td>Talk by Emily Pillmore: Haskell Foundation Progress Update</td></tr></tr>
      <tr><td>2021-06-19T19:30:00+02:00</td><td>2021-06-19T21:00:00+02:00</td><td>beginner</td><td>#ihp-workshop               </td><td>IHP Track</td></tr></tr>
      <tr><td>2021-06-19T19:30:00+02:00</td><td>2021-06-19T21:00:00+02:00</td><td>advanced</td><td>#unison-workshop            </td><td>Unison Track</td></tr></tr>

      <tr><td>2021-06-20T10:00:00+02:00</td><td>2021-06-20T11:15:00+02:00</td><td>talk    </td><td>#speaker-veronika-romashkina</td><td>Talk by Veronika Romashkina: Lift Unliftable (and unlift liftable)</td></tr></tr>
      <tr><td>2021-06-20T11:15:00+02:00</td><td>2021-06-20T12:00:00+02:00</td><td>advanced </td><td>#serokell-track            </td><td>GHC: Dependency Analysis of Haskell Declarations</td></tr></tr>
      <tr><td>2021-06-20T12:00:00+02:00</td><td>2021-06-20T13:00:00+02:00</td><td>advanced </td><td>#serokell-track            </td><td>How to make the most out of servant</td></tr></tr>
      <tr><td>2021-06-20T13:00:00+02:00</td><td>2021-06-20T15:00:00+02:00</td><td>beginner</td><td>#mob-programming            </td><td>Mob Programming</td></tr></tr>
      <tr><td>2021-06-20T16:00:00+02:00</td><td>2021-06-20T17:30:00+02:00</td><td>beginner</td><td>#beginner-track             </td><td>Beginner Track</td></tr></tr>
      <tr><td>2021-06-20T14:00:00+02:00</td><td>2021-06-20T17:00:00+02:00</td><td>advanced</td><td>#advanced-track             </td><td>Advanced Track: Understanding memory usage with eventlog2html and ghc-debug</td></tr></tr>
      <tr><td>2021-06-20T18:00:00+02:00</td><td>2021-06-20T19:15:00+02:00</td><td>talk    </td><td>#speaker-sandy-maguire      </td><td>Talk by Sandy Maguire: A New Kind of Programming: Tactic Metaprogramming in Haskell</td></tr></tr>
      <tr><td>2021-06-20T19:30:00+02:00</td><td>2021-06-20T21:00:00+02:00</td><td>beginner</td><td>#ihp-workshop               </td><td>IHP Track</td></tr></tr>
    </table>
  </div>
</div>


<section>
  <h2 id="speakers">OUR_SPEAKERS</h2>
  <div class="speakers">
    <div class="speaker">
      <div class="anchor" id="speaker-emily-pillmore"></div>
      <div class="details">
        <img src="/images/speakers/emily-pillmore.jpg" alt="Emily Pillmore" class="avatar">
        <div>
          <span class="name">EMILY_PILLMORE</span>
          <div class="links">
            <a class="web" href="http://cohomolo.gy/"></a>
            <a class="github" href="https://github.com/emilypi"></a>
            <a class="twitter" href="https://twitter.com/bkmlep"></a>
          </div>
        </div>
      </div>
      <p>
        Emily is a long-time functional programmer, Haskell developer and
        CTO of the <a href="https://haskell.foundation/">Haskell
        Foundation</a>.  Her research interests include Homotopy Theory,
        Category Theory and Topology, and she recently co-authored a paper about
        <a href="https://arxiv.org/abs/2001.07488">Profunctor optics</a>.
      </p>
    </div>
    <div class="speaker">
      <div class="anchor" id="speaker-john-hughes"></div>
      <div class="details">
        <img src="/images/speakers/john-hughes.jpg" alt="John Hughes" class="avatar">
        <div>
          <span class="name">JOHN_HUGHES</span>
          <div class="links">
            <a class="web" href="http://www.cse.chalmers.se/~rjmh/"></a>
          </div>
        </div>
      </div>
      <p>
        John Hughes holds a professor position at the
        <a href="http://www.chalmers.se/">Chalmers University of Technology</a>.
        In the Haskell community, he is mostly known for his work around
        <a href="http://www.cse.chalmers.se/~rjmh/QuickCheck/">QuickCheck</a>,
        that changed the way how functional programmers test programs.  He also
        leads <a href="http://www.quviq.com/">QuviQ</a>, a software testing
        consultancy.
      </p>
    </div>
    <div class="speaker">
      <div class="anchor" id="speaker-veronika-romashkina"></div>
      <div class="details">
        <img src="/images/speakers/veronika-romashkina.jpg" alt="Veronika Romashkina" class="avatar">
        <div>
          <span class="name">VERONIKA_ROMASHKINA</span>
          <div class="links">
            <a class="web" href="https://vrom911.github.io/"></a>
            <a class="github" href="https://github.com/vrom911"></a>
            <a class="twitter" href="https://twitter.com/vrom911"></a>
          </div>
        </div>
      </div>
      <p>
        Veronika is an enthusiastic functional programmer and uses Haskell
        for open source work as well as in production.  She co-founded
        <a href="https://kowainik.github.io/">Kowainik</a>,
        who've provided us host of a useful tools and tutorials.  On top of
        that, she is also one of the authors of the wonderful
        <a href="https://bindthegap.news/">Bind the Gap</a> magazine.
      </p>
      <div id="speaker-veronika-romashkina-abstract" class="hidden">
        <p class="hidden-show">
          <a href="#speaker-veronika-romashkina-abstract">show talk abstract...</a>
        </p>
        <div class="hidden-content">
          <p><strong>Lift Unliftable (and unlift liftable)</strong></p>
          <p>
            I love pure total functions because they usually do one concrete
            thing, don't throw exceptions and are easily testable. But when
            entering the real engineering world, you need to deal with a lot of
            nasty things aka side effects. The most efficient way to decrease
            accidental complexity is to decompose the side effect into smaller,
            more controllable and modular parts. Monad Transformers (MT) offer
            such a decompositional approach to solving these problems, and it
            is popular and widely used in production nowadays. However, using
            Monad Transformers is not a bed of roses. MT architecture could be
            considered harmful sometimes.
          </p>
          <p>
            In my talk, I'm going to examine how Monad Transformers took such
            a big role in applications, what problems they solve (and which
            don't), share common issues you can experience while working with
            an MT stack, and how you can overcome challenges introduced by
            them.
          </p>
        </div>
      </div>
    </div>
    <div class="speaker">
      <div class="anchor" id="speaker-sandy-maguire"></div>
      <div class="details">
        <img src="/images/speakers/sandy-maguire.jpg" alt="Sandy Maguire" class="avatar">
        <div>
          <span class="name">SANDY_MAGUIRE</span>
          <div class="links">
            <a class="web" href="https://sandymaguire.me/"></a>
            <a class="github" href="https://github.com/isovector"></a>
          </div>
        </div>
      </div>
      <p>
        Sandy is best described somewhere between independent researcher and
        voluntarily-unemployed bum.  He wrote two books about Haskell,
        <a href="https://leanpub.com/thinking-with-types">Thinking with Types</a>
        and
        <a href="https://leanpub.com/algebra-driven-design">Algebra-Driven Design</a>,
        as well as the library
        <a href="https://github.com/polysemy-research/polysemy">polysemy</a>.
      </p>
    </div>
    <div class="speaker">
      <div class="anchor" id="speaker-ollie-charles"></div>
      <div class="details">
        <img src="/images/speakers/ollie-charles.jpg" alt="Ollie Charles" class="avatar">
        <div>
          <span class="name">OLLIE_CHARLES</span>
          <div class="links">
            <a class="web" href="https://ocharles.org.uk/"></a>
            <a class="github" href="https://github.com/ocharles"></a>
            <a class="twitter" href="https://twitter.com/acid2"></a>
          </div>
        </div>
      </div>
      <p>
        Ollie is a Haskell Developer well known for his
        <a href="https://ocharles.org.uk/pages/2012-12-01-24-days-of-hackage.html">24 Days</a>
        <a href="https://ocharles.org.uk/pages/2013-12-01-24-days-of-hackage.html">of Hackage</a>
        and
        <a href="https://ocharles.org.uk/pages/2014-12-01-24-days-of-ghc-extensions.html">24 Days of GHC Extensions</a>
        series.  He also maintains a number of Haskell projects, including
        a really cool implementation of Quake 3 in Haskell &amp; Vulkan.
      </p>
    </div>
  </div>
</section>

<section>
  <h2 id="tracks">TRACK_INFO</h2>
  <p>
    We have a number of tracks for all you knowledge-hungry people.
  </p>
  <p>
    These cover any level between beginner and expert, and we've taken special care to have
    content for intermediate Haskell programmers. There has never been a better time
    to learn and apply some real-world Haskell skills!
  </p>
  <div class="tracks">

    <div class="track">
      <h3 id="beginner-track">Beginner Track</h3>
      <p>
        Julie Moronuki and Chris Martin of <a href="https://typeclasses.com/">Typeclasses</a> will teach a class for beginner Haskell programmers.
      </p>
      <p>
        No prior Haskell experience is necessary, and you will learn fundamentals as well as some applied skills
        over the course of the two sessions.
      </p>
      <p>
        For this track, you have to have a working Haskell installation.
        We'll hold an install party before the beginner track to help you with that.
        We recommend <a href="https://www.haskell.org/ghcup/">ghcup</a> to install the compiler and cabal, together with
        VSCode and the <a href="https://marketplace.visualstudio.com/items?itemName=haskell.haskell">Language Server extension</a>.
        Installing Haskell in 2021 is super easy!
      </p>
    </div>

    <div class="track">
      <div class="track-header">
        <!-- <img src="/images/zurihac2021/ihp.svg" class="track-icon"> -->
        <h3 id="ihp-workshop">IHP workshop</h3>
      </div>
      <p>
        The <a href="https://ihp.digitallyinduced.com/">IHP web framework</a> is a really cool
        Haskell web framework combines the productivity of Ruby-on-Rails with the performance and robustness
        of Haskell. The community around it is growing really fast,
        in part because it comes with highly polished tools
        and doesn't need deep technical knowledge to build useful websites very quickly.
      </p>
      <p>
        The creators of IHP, <a href="https://digitallyinduced.com/">digitally induced</a>,
        will hold tutorials that teach you how to get productive with the framework.
        We recommend that even total beginners check it out,
        as some people have learned Haskell simply through using IHP for a practical application.
      </p>
    </div>

    <div class="track">
      <h3 id="advanced-track">Advanced Track</h3>
      <p>
        Similar to last year, we have the privilege to get
        advanced Haskell training from our friends at
        <a href="https://www.well-typed.com/">Well-Typed</a>. This will take the
        form of two independent sessions, distributed over the course of two
        days.
      </p>
      <div id="advanced-track-1" class="hidden">
        <h4>Saturday: Optics in the abstract by Adam Gundry</h4>
        <p class="hidden-show">
          <a href="#advanced-track-1">show more...</a>
        </p>
        <div class="hidden-content">
          <p>
            Haskell programming often involves manipulating data structures.
            Optics are a compositional abstraction representing "notions of
            substructure" as first-class values.  For example, lenses capture
            the notion of one data structure containing another, and there
            are more general optics for read-only, write-only, optional or
            repeated substructures.  Judicious use of optics can lead to
            succinct, expressive code, yet optics also have a reputation of being
            impenetrable.
          </p>
          <p>
            In this workshop, we will explore optics-the-concept in general and
            the optics library in particular.  This library provides interfaces
            for defining, combining and using various kinds of optics.  Crucially,
            these interfaces are abstract, so they can be understood without
            reference to the underlying implementation.
          </p>
          <p>
            We will also discuss how optics can help in addressing the limitations
            of Haskell's record system, in conjunction with language extensions
            such as DuplicateRecordFields, OverloadedLabels and the forthcoming
            RecordDotSyntax and NoFieldSelectors.
          </p>
          <p>
            Finally, we will use optics as a case study to reflect on library
            design in Haskell.  How can we build libraries that capture powerful
            concepts and yet remain easy to use by Haskellers with a wide range of
            skill levels?
          </p>
          <p>
            This workshop will be suitable for Haskell programmers with a
            knowledge of basic Haskell concepts (polymorphic functions, data
            types, type classes).  It does not require familiarity with advanced
            type system features such as higher-rank types or type families.
          </p>
        </div>
      </div>
      <div id="advanced-track-2" class="hidden">
        <h4>Sunday: Understanding memory usage with eventlog2html
        and ghc-debug by Matthew Pickering and Ben Gamari</h4>
        <p class="hidden-show">
          <a href="#advanced-track-2">show more...</a>
        </p>
        <div class="hidden-content">
          <p>
            Profiling memory usage of applications has historically been a
            difficult task, thankfully in recent years the profiling tools have
            become more sophisticated and now it is quite easy to work out memory
            usage issues, if you know how to ask the right question.
          </p>
          <p>
            In this workshop, we will look at two profiling tools which can give
            you both high and low level insight into the memory usage of your
            application. Firstly, by using eventlog2html we will understand how to
            get a high-level overview of your program's memory usage. Then using
            these insights we will then learn how to use ghc-debug in order to
            answer some more precise questions about memory usage.
          </p>
          <p>
            The presentation will not require any advanced knowledge but we will
            be delving into the internals so you should be comfortable with
            that. The majority of the workshop will be given over to allowing
            participants to experiment with the tools themselves on our toy
            examples or their own projects.
          </p>
        </div>
      </div>
    </div>

    <div class="track">
      <div class="track-header">
        <img src="/images/zurihac2021/unison-icon.svg" class="track-icon">
        <h3 id="unison-workshop">Unison workshop</h3>
      </div>
      <p style="clear:both">
        Unison is an exciting new programming language that shares Haskell's syntax
        (in addition to being implemented in it).
        The big ideas in Unison are content-addressable code and a focus on creating a language
        in which it is natural to express distributed systems.
      </p>
      <p>
        Rúnar Bjarnason of <a href="https://www.unisonweb.org/unisoncomputing/">Unison Computing</a>
        will give you an intro to the language, and hold a hands-on tutorial.
      </p>
      <p>
        If you can't wait, check out the <a href="https://youtu.be/gCWtkvDQ2ZI">2019 Strangeloop</a>
        introduction to the language.
      </p>
    </div>

    <div class="track">
      <h3 id="serokell-track">Serokell Track</h3>
      <p>
        This year year we're delighted to have <a href="https://serokell.io/">Serokell</a>
        present two topics:

        <ul>
          <li>
            Dependency Analysis of Haskell Declarations in GHC.
          </li>
          <li>
            How to make the most out of servant.
          </li>
        </ul>
      <p>
        The servant talk is geared towards industrial practicioners, so please don't hesitate to join
        if you're excited about practical applications but don't consider yourself an expert.
      </p>
    </div>


    <div class="track">
      <div class="track-header">
        <img src="/images/zurihac2021/angry-lambda.png" class="track-icon">
        <h3 id="mob-programming">Mob Programming : Angry Lambdas</h3>
      </div>
      <div>
        <p>
          By <a href="https://twitter.com/akhesaCaro">Caroline Gaudreau</a> of <a href="https://tech.fretlink.com/">Fretlink</a>
          <br>
          and <a href="https://twitter.com/gael_deest">Gaël Deest</a> of <a href="https://www.tweag.io/">Tweag</a>
        </p>
        <p>
          Collectively implement a small Angry Birds clone in Haskell using the Gloss library
          for graphics and user interaction, and the Chiphunk library for physics simulation!
        </p>
        <p>
          This workshop is targeted at beginners with a basic understanding of Haskell.
          You only need to know algebraic datatypes, pattern-matching, and a bit of IO.
        </p>
        <p>
          Note: This is a mob programming event: participants will take turn at the (virtual) keyboard, while listening to suggestions and comments from the rest of the crowd.
        </p>
        <p>
          To participate, you will need <a href="https://code.visualstudio.com/">VSCode</a>
          with the <a href="https://marketplace.visualstudio.com/items?itemName=MS-vsliveshare.vsliveshare">LiveShare</a> extension,
          install these before joining the session.
        </p>
      </div>
    </div>
  </div>
</section>

<section>
  <h2 id="tracks">PROJECTS</h2>
  <p>
     Of course, it wouldn't be a Hackathon without projects to hack on!
     You can find <a href="/zurihac2021/projects.html">the list of projects
     here</a> and even add your own!
  </p>
</section>

<div class="inverted">
  <h1 id="partners">___PARTNERS___</h1>
  <div class="partners">
    <a href="https://www.digitalasset.com/" target="_blank"><img alt="Digital Asset" src="/images/s43/digitalasset.svg"></a>

    <a href="https://www.digitallyinduced.com/" target="_blank"><img alt="Digitally Induced" src="/images/s43/digitally-induced.svg"></a>

    <a href="https://www.fretlink.com/" target="_blank"><img alt="Fretlink" src="/images/s43/fretlink.svg"></a>

    <a href="https://www.hackworthltd.uk/" target="_blank"><img alt="Hackworth" src="/images/s43/hackworth.svg"></a>

    <!-- This SVG needs explit width / height. -->
    <a href="https://www.ost.ch/en/" target="_blank"><img alt="OST" src="/images/s43/ost.svg"></a>

    <a href="https://serokell.io/" target="_blank"><img alt="Serokell" src="/images/s43/serokell.svg"></a>

    <a href="https://www.tweag.io/" target="_blank"><img alt="Tweag I/O" src="/images/s43/tweag.png"></a>

    <a href="https://typeclasses.com/" target="_blank"><img alt="Type Classes" src="/images/s43/typeclasses.svg"></a>

    <a href="https://www.unisonweb.org/" target="_blank"><img alt="Unison" src="/images/s43/unison.svg"></a>

    <a href="https://www.well-typed.com/" target="_blank"><img alt="Well-Typed" src="/images/s43/well-typed.svg"></a>

  </div>
</div class="inverted">

<h1 id="about">___ABOUT___</h1>
<section>
  <h2 id="contact">CONTACT</h1>
  <p>
    If you have any questions before the event, please reach out to
    <a href="mailto:m@jaspervdj.be">Jasper Van der Jeugt</a>,
    <a href="mailto:juri.chome@gmail.com">Juri Chomé</a> or
    <a href="mailto:farhad.mehta@hsr.ch">Farhad Mehta</a>.
    We also monitor our official
    <a href="https://twitter.com/zurihac">Twitter account</a>.
  </p>

  <p>
    The primary medium to communicate with other participants is our
    <a href="https://discord.com">Discord</a> server.  You will receive an
    invite to that after you register.
    We use the hashtag <code>#zurihac</code> on Twitter.
  </p>
</section>

<section>
  <h2 id="who-are-we">WHO_ARE_WE?</h2>
  <p>
    The <strong>main organizers</strong> for ZuriHac 2021 are Jasper Van der
    Jeugt, Juri Chomé, Farhad Mehta and Bieke Hoefkens.
  </p>
  <p>
    Additional volunteers include
    Andreas Herrmann,
    Artem Chirkin,
    Arvin Moezzi,
    Charles Till,
    Gleb Peregud,
    Ingrid Vettiger,
    Ivan Kristo,
    Mathias Koerner,
    Niklas Hambüchen,
    Silvio Böhler,
    Simon Meier and
    Tomas Carnecky.
  </p>
</section>

<section>
  <h2 id="terms-and-conditions">TERMS_AND_CONDITIONS</h2>
  <p>
    Each participant will retain ownership of any and all intellectual and
    industrial property rights to his or her work created or used during the
    Hackathon.
  </p>
  <p>
    ZuriHac uses the
    <a href="https://berlincodeofconduct.org/">Berlin Code of Conduct</a>.
  </p>
</section>

<script type="text/JavaScript">
  // Generated by purs bundle 0.14.1
var PS = {};
(function(exports) {
  "use strict";

  exports.arrayApply = function (fs) {
    return function (xs) {
      var l = fs.length;
      var k = xs.length;
      var result = new Array(l*k);
      var n = 0;
      for (var i = 0; i < l; i++) {
        var f = fs[i];
        for (var j = 0; j < k; j++) {
          result[n++] = f(xs[j]);
        }
      }
      return result;
    };
  };
})(PS["Control.Apply"] = PS["Control.Apply"] || {});
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Control.Semigroupoid"] = $PS["Control.Semigroupoid"] || {};
  var exports = $PS["Control.Semigroupoid"];
  var Semigroupoid = function (compose) {
      this.compose = compose;
  };
  var semigroupoidFn = new Semigroupoid(function (f) {
      return function (g) {
          return function (x) {
              return f(g(x));
          };
      };
  });
  exports["semigroupoidFn"] = semigroupoidFn;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Control.Category"] = $PS["Control.Category"] || {};
  var exports = $PS["Control.Category"];
  var Control_Semigroupoid = $PS["Control.Semigroupoid"];                
  var Category = function (Semigroupoid0, identity) {
      this.Semigroupoid0 = Semigroupoid0;
      this.identity = identity;
  };
  var identity = function (dict) {
      return dict.identity;
  };
  var categoryFn = new Category(function () {
      return Control_Semigroupoid.semigroupoidFn;
  }, function (x) {
      return x;
  });
  exports["identity"] = identity;
  exports["categoryFn"] = categoryFn;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Data.Function"] = $PS["Data.Function"] || {};
  var exports = $PS["Data.Function"];
  var flip = function (f) {
      return function (b) {
          return function (a) {
              return f(a)(b);
          };
      };
  };
  var $$const = function (a) {
      return function (v) {
          return a;
      };
  };
  exports["flip"] = flip;
  exports["const"] = $$const;
})(PS);
(function(exports) {
  "use strict";

  exports.arrayMap = function (f) {
    return function (arr) {
      var l = arr.length;
      var result = new Array(l);
      for (var i = 0; i < l; i++) {
        result[i] = f(arr[i]);
      }
      return result;
    };
  };
})(PS["Data.Functor"] = PS["Data.Functor"] || {});
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Data.Functor"] = $PS["Data.Functor"] || {};
  var exports = $PS["Data.Functor"];
  var $foreign = $PS["Data.Functor"];                
  var Functor = function (map) {
      this.map = map;
  };
  var map = function (dict) {
      return dict.map;
  };                                                                                             
  var functorArray = new Functor($foreign.arrayMap);
  exports["Functor"] = Functor;
  exports["map"] = map;
  exports["functorArray"] = functorArray;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Control.Apply"] = $PS["Control.Apply"] || {};
  var exports = $PS["Control.Apply"];
  var $foreign = $PS["Control.Apply"];
  var Control_Category = $PS["Control.Category"];
  var Data_Function = $PS["Data.Function"];
  var Data_Functor = $PS["Data.Functor"];            
  var Apply = function (Functor0, apply) {
      this.Functor0 = Functor0;
      this.apply = apply;
  }; 
  var applyArray = new Apply(function () {
      return Data_Functor.functorArray;
  }, $foreign.arrayApply);
  var apply = function (dict) {
      return dict.apply;
  };
  var applySecond = function (dictApply) {
      return function (a) {
          return function (b) {
              return apply(dictApply)(Data_Functor.map(dictApply.Functor0())(Data_Function["const"](Control_Category.identity(Control_Category.categoryFn)))(a))(b);
          };
      };
  };
  exports["Apply"] = Apply;
  exports["apply"] = apply;
  exports["applySecond"] = applySecond;
  exports["applyArray"] = applyArray;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Control.Applicative"] = $PS["Control.Applicative"] || {};
  var exports = $PS["Control.Applicative"];
  var Control_Apply = $PS["Control.Apply"];          
  var Applicative = function (Apply0, pure) {
      this.Apply0 = Apply0;
      this.pure = pure;
  };
  var pure = function (dict) {
      return dict.pure;
  };
  var liftA1 = function (dictApplicative) {
      return function (f) {
          return function (a) {
              return Control_Apply.apply(dictApplicative.Apply0())(pure(dictApplicative)(f))(a);
          };
      };
  };
  exports["Applicative"] = Applicative;
  exports["pure"] = pure;
  exports["liftA1"] = liftA1;
})(PS);
(function(exports) {
  "use strict";

  exports.arrayBind = function (arr) {
    return function (f) {
      var result = [];
      for (var i = 0, l = arr.length; i < l; i++) {
        Array.prototype.push.apply(result, f(arr[i]));
      }
      return result;
    };
  };
})(PS["Control.Bind"] = PS["Control.Bind"] || {});
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Control.Bind"] = $PS["Control.Bind"] || {};
  var exports = $PS["Control.Bind"];
  var $foreign = $PS["Control.Bind"];
  var Control_Apply = $PS["Control.Apply"];          
  var Bind = function (Apply0, bind) {
      this.Apply0 = Apply0;
      this.bind = bind;
  }; 
  var bindArray = new Bind(function () {
      return Control_Apply.applyArray;
  }, $foreign.arrayBind);
  var bind = function (dict) {
      return dict.bind;
  };
  exports["Bind"] = Bind;
  exports["bind"] = bind;
  exports["bindArray"] = bindArray;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Control.Monad"] = $PS["Control.Monad"] || {};
  var exports = $PS["Control.Monad"];
  var Control_Applicative = $PS["Control.Applicative"];
  var Control_Bind = $PS["Control.Bind"];                
  var Monad = function (Applicative0, Bind1) {
      this.Applicative0 = Applicative0;
      this.Bind1 = Bind1;
  };
  var ap = function (dictMonad) {
      return function (f) {
          return function (a) {
              return Control_Bind.bind(dictMonad.Bind1())(f)(function (f$prime) {
                  return Control_Bind.bind(dictMonad.Bind1())(a)(function (a$prime) {
                      return Control_Applicative.pure(dictMonad.Applicative0())(f$prime(a$prime));
                  });
              });
          };
      };
  };
  exports["Monad"] = Monad;
  exports["ap"] = ap;
})(PS);
(function(exports) {
  "use strict";

  //------------------------------------------------------------------------------
  // Sorting ---------------------------------------------------------------------
  //------------------------------------------------------------------------------

  exports.sortByImpl = (function () {
    function mergeFromTo(compare, fromOrdering, xs1, xs2, from, to) {
      var mid;
      var i;
      var j;
      var k;
      var x;
      var y;
      var c;

      mid = from + ((to - from) >> 1);
      if (mid - from > 1) mergeFromTo(compare, fromOrdering, xs2, xs1, from, mid);
      if (to - mid > 1) mergeFromTo(compare, fromOrdering, xs2, xs1, mid, to);

      i = from;
      j = mid;
      k = from;
      while (i < mid && j < to) {
        x = xs2[i];
        y = xs2[j];
        c = fromOrdering(compare(x)(y));
        if (c > 0) {
          xs1[k++] = y;
          ++j;
        }
        else {
          xs1[k++] = x;
          ++i;
        }
      }
      while (i < mid) {
        xs1[k++] = xs2[i++];
      }
      while (j < to) {
        xs1[k++] = xs2[j++];
      }
    }

    return function (compare) {
      return function (fromOrdering) {
        return function (xs) {
          var out;

          if (xs.length < 2) return xs;

          out = xs.slice(0);
          mergeFromTo(compare, fromOrdering, out, xs.slice(0), 0, xs.length);

          return out;
        };
      };
    };
  })();
})(PS["Data.Array"] = PS["Data.Array"] || {});
(function(exports) {
  "use strict";

  exports.foldrArray = function (f) {
    return function (init) {
      return function (xs) {
        var acc = init;
        var len = xs.length;
        for (var i = len - 1; i >= 0; i--) {
          acc = f(xs[i])(acc);
        }
        return acc;
      };
    };
  };

  exports.foldlArray = function (f) {
    return function (init) {
      return function (xs) {
        var acc = init;
        var len = xs.length;
        for (var i = 0; i < len; i++) {
          acc = f(acc)(xs[i]);
        }
        return acc;
      };
    };
  };
})(PS["Data.Foldable"] = PS["Data.Foldable"] || {});
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Data.Monoid"] = $PS["Data.Monoid"] || {};
  var exports = $PS["Data.Monoid"];
  var mempty = function (dict) {
      return dict.mempty;
  };
  exports["mempty"] = mempty;
})(PS);
(function(exports) {
  "use strict";

  exports.concatArray = function (xs) {
    return function (ys) {
      if (xs.length === 0) return ys;
      if (ys.length === 0) return xs;
      return xs.concat(ys);
    };
  };
})(PS["Data.Semigroup"] = PS["Data.Semigroup"] || {});
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Data.Semigroup"] = $PS["Data.Semigroup"] || {};
  var exports = $PS["Data.Semigroup"];
  var $foreign = $PS["Data.Semigroup"];
  var Semigroup = function (append) {
      this.append = append;
  }; 
  var semigroupArray = new Semigroup($foreign.concatArray);
  var append = function (dict) {
      return dict.append;
  };
  exports["append"] = append;
  exports["semigroupArray"] = semigroupArray;
})(PS);
(function(exports) {
  "use strict";

  exports.unit = {};
})(PS["Data.Unit"] = PS["Data.Unit"] || {});
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Data.Unit"] = $PS["Data.Unit"] || {};
  var exports = $PS["Data.Unit"];
  var $foreign = $PS["Data.Unit"];
  exports["unit"] = $foreign.unit;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Data.Foldable"] = $PS["Data.Foldable"] || {};
  var exports = $PS["Data.Foldable"];
  var $foreign = $PS["Data.Foldable"];
  var Control_Applicative = $PS["Control.Applicative"];
  var Control_Apply = $PS["Control.Apply"];
  var Data_Function = $PS["Data.Function"];
  var Data_Monoid = $PS["Data.Monoid"];
  var Data_Semigroup = $PS["Data.Semigroup"];
  var Data_Unit = $PS["Data.Unit"];                
  var Foldable = function (foldMap, foldl, foldr) {
      this.foldMap = foldMap;
      this.foldl = foldl;
      this.foldr = foldr;
  };
  var foldr = function (dict) {
      return dict.foldr;
  };
  var traverse_ = function (dictApplicative) {
      return function (dictFoldable) {
          return function (f) {
              return foldr(dictFoldable)((function () {
                  var $313 = Control_Apply.applySecond(dictApplicative.Apply0());
                  return function ($314) {
                      return $313(f($314));
                  };
              })())(Control_Applicative.pure(dictApplicative)(Data_Unit.unit));
          };
      };
  };
  var for_ = function (dictApplicative) {
      return function (dictFoldable) {
          return Data_Function.flip(traverse_(dictApplicative)(dictFoldable));
      };
  };
  var foldl = function (dict) {
      return dict.foldl;
  }; 
  var foldMapDefaultR = function (dictFoldable) {
      return function (dictMonoid) {
          return function (f) {
              return foldr(dictFoldable)(function (x) {
                  return function (acc) {
                      return Data_Semigroup.append(dictMonoid.Semigroup0())(f(x))(acc);
                  };
              })(Data_Monoid.mempty(dictMonoid));
          };
      };
  };
  var foldableArray = new Foldable(function (dictMonoid) {
      return foldMapDefaultR(foldableArray)(dictMonoid);
  }, $foreign.foldlArray, $foreign.foldrArray);
  exports["foldl"] = foldl;
  exports["traverse_"] = traverse_;
  exports["for_"] = for_;
  exports["foldableArray"] = foldableArray;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Data.Maybe"] = $PS["Data.Maybe"] || {};
  var exports = $PS["Data.Maybe"];                 
  var Nothing = (function () {
      function Nothing() {

      };
      Nothing.value = new Nothing();
      return Nothing;
  })();
  var Just = (function () {
      function Just(value0) {
          this.value0 = value0;
      };
      Just.create = function (value0) {
          return new Just(value0);
      };
      return Just;
  })();
  var maybe = function (v) {
      return function (v1) {
          return function (v2) {
              if (v2 instanceof Nothing) {
                  return v;
              };
              if (v2 instanceof Just) {
                  return v1(v2.value0);
              };
              throw new Error("Failed pattern match at Data.Maybe (line 230, column 1 - line 230, column 51): " + [ v.constructor.name, v1.constructor.name, v2.constructor.name ]);
          };
      };
  };
  exports["Nothing"] = Nothing;
  exports["Just"] = Just;
  exports["maybe"] = maybe;
})(PS);
(function(exports) {
  "use strict";

  var unsafeCompareImpl = function (lt) {
    return function (eq) {
      return function (gt) {
        return function (x) {
          return function (y) {
            return x < y ? lt : x === y ? eq : gt;
          };
        };
      };
    };
  };                                         
  exports.ordIntImpl = unsafeCompareImpl;
  exports.ordNumberImpl = unsafeCompareImpl;
})(PS["Data.Ord"] = PS["Data.Ord"] || {});
(function(exports) {
  "use strict";

  var refEq = function (r1) {
    return function (r2) {
      return r1 === r2;
    };
  };                            
  exports.eqIntImpl = refEq;
  exports.eqNumberImpl = refEq;
  exports.eqStringImpl = refEq;
})(PS["Data.Eq"] = PS["Data.Eq"] || {});
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Data.Eq"] = $PS["Data.Eq"] || {};
  var exports = $PS["Data.Eq"];
  var $foreign = $PS["Data.Eq"];
  var Eq = function (eq) {
      this.eq = eq;
  }; 
  var eqString = new Eq($foreign.eqStringImpl);
  var eqNumber = new Eq($foreign.eqNumberImpl);
  var eqInt = new Eq($foreign.eqIntImpl);
  var eq = function (dict) {
      return dict.eq;
  };
  exports["Eq"] = Eq;
  exports["eq"] = eq;
  exports["eqInt"] = eqInt;
  exports["eqNumber"] = eqNumber;
  exports["eqString"] = eqString;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Data.Ordering"] = $PS["Data.Ordering"] || {};
  var exports = $PS["Data.Ordering"];              
  var LT = (function () {
      function LT() {

      };
      LT.value = new LT();
      return LT;
  })();
  var GT = (function () {
      function GT() {

      };
      GT.value = new GT();
      return GT;
  })();
  var EQ = (function () {
      function EQ() {

      };
      EQ.value = new EQ();
      return EQ;
  })();
  exports["LT"] = LT;
  exports["GT"] = GT;
  exports["EQ"] = EQ;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Data.Ord"] = $PS["Data.Ord"] || {};
  var exports = $PS["Data.Ord"];
  var $foreign = $PS["Data.Ord"];
  var Data_Eq = $PS["Data.Eq"];
  var Data_Ordering = $PS["Data.Ordering"];
  var Ord = function (Eq0, compare) {
      this.Eq0 = Eq0;
      this.compare = compare;
  }; 
  var ordNumber = new Ord(function () {
      return Data_Eq.eqNumber;
  }, $foreign.ordNumberImpl(Data_Ordering.LT.value)(Data_Ordering.EQ.value)(Data_Ordering.GT.value));
  var ordInt = new Ord(function () {
      return Data_Eq.eqInt;
  }, $foreign.ordIntImpl(Data_Ordering.LT.value)(Data_Ordering.EQ.value)(Data_Ordering.GT.value));
  var compare = function (dict) {
      return dict.compare;
  };
  var comparing = function (dictOrd) {
      return function (f) {
          return function (x) {
              return function (y) {
                  return compare(dictOrd)(f(x))(f(y));
              };
          };
      };
  };
  var greaterThanOrEq = function (dictOrd) {
      return function (a1) {
          return function (a2) {
              var v = compare(dictOrd)(a1)(a2);
              if (v instanceof Data_Ordering.LT) {
                  return false;
              };
              return true;
          };
      };
  };
  var lessThanOrEq = function (dictOrd) {
      return function (a1) {
          return function (a2) {
              var v = compare(dictOrd)(a1)(a2);
              if (v instanceof Data_Ordering.GT) {
                  return false;
              };
              return true;
          };
      };
  };
  var max = function (dictOrd) {
      return function (x) {
          return function (y) {
              var v = compare(dictOrd)(x)(y);
              if (v instanceof Data_Ordering.LT) {
                  return y;
              };
              if (v instanceof Data_Ordering.EQ) {
                  return x;
              };
              if (v instanceof Data_Ordering.GT) {
                  return x;
              };
              throw new Error("Failed pattern match at Data.Ord (line 176, column 3 - line 179, column 12): " + [ v.constructor.name ]);
          };
      };
  };
  var min = function (dictOrd) {
      return function (x) {
          return function (y) {
              var v = compare(dictOrd)(x)(y);
              if (v instanceof Data_Ordering.LT) {
                  return x;
              };
              if (v instanceof Data_Ordering.EQ) {
                  return x;
              };
              if (v instanceof Data_Ordering.GT) {
                  return y;
              };
              throw new Error("Failed pattern match at Data.Ord (line 167, column 3 - line 170, column 12): " + [ v.constructor.name ]);
          };
      };
  };
  exports["Ord"] = Ord;
  exports["compare"] = compare;
  exports["lessThanOrEq"] = lessThanOrEq;
  exports["greaterThanOrEq"] = greaterThanOrEq;
  exports["comparing"] = comparing;
  exports["min"] = min;
  exports["max"] = max;
  exports["ordInt"] = ordInt;
  exports["ordNumber"] = ordNumber;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Data.Array"] = $PS["Data.Array"] || {};
  var exports = $PS["Data.Array"];
  var $foreign = $PS["Data.Array"];
  var Control_Bind = $PS["Control.Bind"];
  var Control_Category = $PS["Control.Category"];
  var Data_Foldable = $PS["Data.Foldable"];
  var Data_Function = $PS["Data.Function"];
  var Data_Maybe = $PS["Data.Maybe"];
  var Data_Ord = $PS["Data.Ord"];
  var Data_Ordering = $PS["Data.Ordering"];
  var sortBy = function (comp) {
      return $foreign.sortByImpl(comp)(function (v) {
          if (v instanceof Data_Ordering.GT) {
              return 1;
          };
          if (v instanceof Data_Ordering.EQ) {
              return 0;
          };
          if (v instanceof Data_Ordering.LT) {
              return -1 | 0;
          };
          throw new Error("Failed pattern match at Data.Array (line 831, column 31 - line 834, column 11): " + [ v.constructor.name ]);
      });
  };
  var sortWith = function (dictOrd) {
      return function (f) {
          return sortBy(Data_Ord.comparing(dictOrd)(f));
      };
  };
  var singleton = function (a) {
      return [ a ];
  };                                                           
  var foldl = Data_Foldable.foldl(Data_Foldable.foldableArray);
  var concatMap = Data_Function.flip(Control_Bind.bind(Control_Bind.bindArray));
  var mapMaybe = function (f) {
      return concatMap((function () {
          var $109 = Data_Maybe.maybe([  ])(singleton);
          return function ($110) {
              return $109(f($110));
          };
      })());
  };
  var catMaybes = mapMaybe(Control_Category.identity(Control_Category.categoryFn));
  exports["mapMaybe"] = mapMaybe;
  exports["catMaybes"] = catMaybes;
  exports["foldl"] = foldl;
  exports["sortWith"] = sortWith;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Data.Boolean"] = $PS["Data.Boolean"] || {};
  var exports = $PS["Data.Boolean"];
  var otherwise = true;
  exports["otherwise"] = otherwise;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Data.Generic.Rep"] = $PS["Data.Generic.Rep"] || {};
  var exports = $PS["Data.Generic.Rep"];             
  var Inl = (function () {
      function Inl(value0) {
          this.value0 = value0;
      };
      Inl.create = function (value0) {
          return new Inl(value0);
      };
      return Inl;
  })();
  var Inr = (function () {
      function Inr(value0) {
          this.value0 = value0;
      };
      Inr.create = function (value0) {
          return new Inr(value0);
      };
      return Inr;
  })();
  var Product = (function () {
      function Product(value0, value1) {
          this.value0 = value0;
          this.value1 = value1;
      };
      Product.create = function (value0) {
          return function (value1) {
              return new Product(value0, value1);
          };
      };
      return Product;
  })();
  var Generic = function (from, to) {
      this.from = from;
      this.to = to;
  };
  var from = function (dict) {
      return dict.from;
  };
  exports["Generic"] = Generic;
  exports["from"] = from;
  exports["Inl"] = Inl;
  exports["Inr"] = Inr;
  exports["Product"] = Product;
})(PS);
(function(exports) {
  // This Source Code Form is subject to the terms of the Mozilla Public
  // License, v. 2.0. If a copy of the MPL was not distributed with this
  // file, You can obtain one at http://mozilla.org/MPL/2.0/.

  "use strict";

  /** @constructor */
  function MapNode(datamap, nodemap, content) {
      this.datamap = datamap;
      this.nodemap = nodemap;
      this.content = content;
  }

  MapNode.prototype.lookup = function lookup(Nothing, Just, keyEquals, key, keyHash, shift) {
      var bit = mask(keyHash, shift);
      if ((this.datamap & bit) !== 0) {
          var i = index(this.datamap, bit);
          if (keyEquals(key)(this.content[i * 2]))
              return new Just(this.content[i * 2 + 1]);
          return Nothing;
      }
      if ((this.nodemap & bit) !== 0) {
          return this.content[this.content.length - 1 - index(this.nodemap, bit)].lookup(Nothing, Just, keyEquals, key, keyHash, shift + 5);
      }
      return Nothing;
  }

  function remove2insert1Mut(a, removeIndex, insertIndex, v1) {
      for (var i = removeIndex; i < insertIndex; i++) a[i] = a[i+2];
      a[i++] = v1;
      for (; i < a.length - 1; i++) a[i] = a[i+1];
      a.length = a.length - 1;
  }

  MapNode.prototype.insertMut = function insertMut(keyEquals, hashFunction, key, keyHash, value, shift) {
      var bit = mask(keyHash, shift);
      var i = index(this.datamap, bit);
      if ((this.datamap & bit) !== 0) {
          var k = this.content[i * 2];
          if (keyEquals(k)(key)) {
              this.content[i*2+1] = value;
          } else {
              var newNode = binaryNode(k, hashFunction(k), this.content[i*2+1], key, keyHash, value, shift + 5);
              this.datamap = this.datamap ^ bit;
              this.nodemap = this.nodemap | bit;
              remove2insert1Mut(this.content, i*2, this.content.length - index(this.nodemap, bit) - 2, newNode);
          }
      } else if ((this.nodemap & bit) !== 0) {
          var n = this.content.length - 1 - index(this.nodemap, bit);
          this.content[n].insertMut(keyEquals, hashFunction, key, keyHash, value, shift + 5);
      } else {
          this.datamap = this.datamap | bit;
          this.content.splice(i*2, 0, key, value);
      }
  }

  MapNode.prototype.insert = function insert(keyEquals, hashFunction, key, keyHash, value, shift) {
      var bit = mask(keyHash, shift);
      var i = index(this.datamap, bit);
      if ((this.datamap & bit) !== 0) {
          var k = this.content[i * 2];
          if (keyEquals(k)(key))
              return new MapNode(this.datamap, this.nodemap, overwriteTwoElements(this.content, i*2, key, value));
          var newNode = binaryNode(k, hashFunction(k), this.content[i*2+1], key, keyHash, value, shift + 5);
          return new MapNode(this.datamap ^ bit, this.nodemap | bit, remove2insert1(this.content, i * 2, this.content.length - index(this.nodemap, bit) - 2, newNode));
      }
      if ((this.nodemap & bit) !== 0) {
          var n = this.content.length - 1 - index(this.nodemap, bit);
          return new MapNode(this.datamap, this.nodemap,
                             copyAndOverwriteOrExtend1(this.content, n,
                                              this.content[n].insert(keyEquals, hashFunction, key, keyHash, value, shift + 5)));
      }
      return new MapNode(this.datamap | bit, this.nodemap, insert2(this.content, i*2, key, value));
  }

  MapNode.prototype.insertWith = function insertWith(keyEquals, hashFunction, f, key, keyHash, value, shift) {
      var bit = mask(keyHash, shift);
      var i = index(this.datamap, bit);
      if ((this.datamap & bit) !== 0) {
          var k = this.content[i * 2];
          if (keyEquals(k)(key))
              return new MapNode(this.datamap, this.nodemap, overwriteTwoElements(this.content, i*2, key, f(this.content[i*2+1])(value)));
          var newNode = binaryNode(k, hashFunction(k), this.content[i*2+1], key, keyHash, value, shift + 5);
          return new MapNode(this.datamap ^ bit, this.nodemap | bit, remove2insert1(this.content, i * 2, this.content.length - index(this.nodemap, bit) - 2, newNode));
      }
      if ((this.nodemap & bit) !== 0) {
          var n = this.content.length - 1 - index(this.nodemap, bit);
          return new MapNode(this.datamap, this.nodemap,
                             copyAndOverwriteOrExtend1(this.content, n,
                                              this.content[n].insertWith(keyEquals, hashFunction, f, key, keyHash, value, shift + 5)));
      }
      return new MapNode(this.datamap | bit, this.nodemap, insert2(this.content, i*2, key, value));
  }

  MapNode.prototype.delet = function delet(keyEquals, key, keyHash, shift) {
      var bit = mask(keyHash, shift);
      if ((this.datamap & bit) !== 0) {
          var dataIndex = index(this.datamap, bit);
          if (keyEquals(this.content[dataIndex*2])(key)) {
              if (this.nodemap === 0 && this.content.length === 2) return empty;
              return new MapNode(this.datamap ^ bit, this.nodemap, remove2(this.content, dataIndex * 2));
          }
          return this;
      }
      if ((this.nodemap & bit) !== 0) {
          var nodeIndex = index(this.nodemap,bit);
          var recNode = this.content[this.content.length - 1 - nodeIndex];
          var recRes = recNode.delet(keyEquals, key, keyHash, shift + 5);
          if (recNode === recRes) return this;
          if (recRes.isSingleton()) {
              if (this.content.length === 1) {
                  recRes.datamap = this.nodemap;
                  return recRes;
              }
              return new MapNode(this.datamap | bit, this.nodemap ^ bit,
                                 insert2remove1(this.content, 2 * index(this.datamap, bit), recRes.content[0], recRes.content[1], this.content.length - 1 - nodeIndex));
          }
          return new MapNode(this.datamap, this.nodemap, copyAndOverwriteOrExtend1(this.content, this.content.length - 1 - nodeIndex, recRes));
      }
      return this;
  }

  MapNode.prototype.toArrayBy = function (f, res) {
      for (var i = 0; i < popCount(this.datamap) * 2;) {
          var k = this.content[i++];
          var v = this.content[i++];
          res.push(f(k)(v));
      }
      for (; i < this.content.length; i++)
          this.content[i].toArrayBy(f, res);
  }

  MapNode.prototype.isSingleton = function () {
      return this.nodemap === 0 && this.content.length === 2;
  }

  MapNode.prototype.eq = function(kf, vf, that) {
      if (this === that) return true;
      if (this.constructor !== that.constructor || this.nodemap !== that.nodemap || this.datamap !== that.datamap) return false;
      for (var i = 0; i < popCount(this.datamap) * 2;) {
          if (kf(this.content[i])(that.content[i])) i++; else return false;
          if (vf(this.content[i])(that.content[i])) i++; else return false;
      }
      for (; i < this.content.length; i++)
          if (!this.content[i].eq(kf, vf, that.content[i])) return false;
      return true;
  }

  MapNode.prototype.hash = function (vhash) {
      var h = this.datamap;
      for (var i = 0; i < popCount(this.datamap); i++)
          h = (h * 31 + vhash(this.content[i * 2 + 1])) | 0;
      for (var j = 0; j < popCount(this.nodemap); j++)
          h = (h * 31 + this.content[this.content.length - j - 1].hash(vhash)) | 0;
      return h;
  }

  MapNode.prototype.size = function () {
      var res = popCount(this.datamap);
      for (var i = res * 2; i < this.content.length; i++) res += this.content[i].size();
      return res;
  }

  MapNode.prototype.imap = function (f) {
      var newContent = this.content.slice();
      for (var i = 0; i < popCount(this.datamap) * 2;) {
          var k = this.content[i++];
          var v = this.content[i++];
          newContent[i-2] = k;
          newContent[i-1] = f(k)(v);
      }
      for (; i < this.content.length; i++)
          newContent[i] = this.content[i].imap(f);
      return new MapNode(this.datamap, this.nodemap, newContent);
  }

  MapNode.prototype.ifoldMap = function (m, mappend, f) {
      for (var i = 0; i < popCount(this.datamap) * 2;) {
          var k = this.content[i++];
          var v = this.content[i++];
          m = mappend(m)(f(k)(v));
      }
      for (; i < this.content.length; i++)
          m = this.content[i].ifoldMap(m, mappend, f);
      return m;
  }

  function lowestBit(n) { return n & -n; }

  function mergeState(bit, thisnode, thisdata, thatnode, thatdata) {
      /* Returns one of these constants:

       const NONE_NONE = 0;
       const NODE_NONE = 1;
       const DATA_NONE = 2;
       const NONE_NODE = 4;
       const NONE_DATA = 8;
       const DATA_NODE = DATA_NONE | NONE_NODE;
       const NODE_DATA = NODE_NONE | NONE_DATA;
       const DATA_DATA = DATA_NONE | NONE_DATA;
       const NODE_NODE = NODE_NONE | NONE_NODE;

       I would love to declare them in the file, but purs compile
       complains about `const` and purs bundle removes variables.
    */  

      var state = 0;
      state |= (bit & thisnode) !== 0 ? 1 : 0;
      state |= (bit & thisdata) !== 0 ? 2 : 0;
      state |= (bit & thatnode) !== 0 ? 4 : 0;
      state |= (bit & thatdata) !== 0 ? 8 : 0;
      return state;
  }

  MapNode.prototype.unionWith = function (eq, hash, f, that, shift) {
      if (this.constructor !== that.constructor)
          throw "Trying to union a MapNode with something else";

      // I'd rather declare these locally in the branches, but purs
      // compile complains about `const`.
      var thisDataIndex, thatDataIndex, thisNodeIndex, thatNodeIndex;

      var datamap = 0;
      var nodemap = 0;
      var data = [];
      var nodes = [];

      // Conceptually, we go through all of the 32 bits in the result
      // and then handle the (in/notin + left/right + data/node)
      // combinations. With this clever trick, we get to skip the 0 bits.
      var skipmap = this.datamap | this.nodemap | that.datamap | that.nodemap;
      while (skipmap !== 0) {
          var bit = lowestBit(skipmap);
          skipmap &= ~bit;

          switch (mergeState(bit, this.nodemap, this.datamap, that.nodemap, that.datamap)) {
          case 1 /* NODE_NONE */:
              thisNodeIndex = index(this.nodemap, bit);
              nodemap |= bit;
              nodes.push(this.content[this.content.length - thisNodeIndex - 1]);
              break;
          case 2 /* DATA_NONE */:
              thisDataIndex = index(this.datamap, bit);
              datamap |= bit;
              data.push(this.content[thisDataIndex * 2], this.content[thisDataIndex * 2 + 1]);
              break;
          case 4 /* NONE_NODE */:
              thatNodeIndex = index(that.nodemap, bit);
              nodemap |= bit;
              nodes.push(that.content[that.content.length - thatNodeIndex - 1]);
              break;
          case 5 /* NODE_NODE */:
              thisNodeIndex = index(this.nodemap, bit);
              thatNodeIndex = index(that.nodemap, bit);
              nodemap |= bit;
              nodes.push(
                  this.content[this.content.length - thisNodeIndex - 1].
                       unionWith(eq, hash, f, that.content[that.content.length - thatNodeIndex - 1], shift + 5));
              break;
          case 6 /* DATA_NODE */:
              thisDataIndex = index(this.datamap, bit);
              thatNodeIndex = index(that.nodemap, bit);
              var k = this.content[thisDataIndex * 2];
              var v = this.content[thisDataIndex * 2 + 1];
              var hk = hash(k);
              var flippedF = function (a) { return function (b) { return f(b)(a); }; };
              nodemap |= bit;
              nodes.push(that.content[that.content.length - thatNodeIndex - 1].insertWith(eq, hash, flippedF, k, hk, v, shift + 5));
              break;
          case 8 /* NONE_DATA */:
              thatDataIndex = index(that.datamap, bit);
              datamap |= bit;
              data.push(that.content[thatDataIndex * 2], that.content[thatDataIndex * 2 + 1]);
              break;
          case 9 /* NODE_DATA */:
              thatDataIndex = index(that.datamap, bit);
              thisNodeIndex = index(this.nodemap, bit);
              var k = that.content[thatDataIndex * 2];
              var v = that.content[thatDataIndex * 2 + 1];
              var hk = hash(k);
              nodemap |= bit;
              nodes.push(this.content[this.content.length - thisNodeIndex - 1].insertWith(eq, hash, f, k, hk, v, shift + 5));
              break;
          case 10 /* DATA_DATA */:
              thisDataIndex = index(this.datamap, bit);
              thatDataIndex = index(that.datamap, bit);
              if (eq(this.content[thisDataIndex * 2])(that.content[thatDataIndex * 2])) {
                  // equal, merge with f
                  datamap |= bit;
                  data.push(this.content[thisDataIndex * 2], f(this.content[thisDataIndex * 2 + 1])(that.content[thatDataIndex * 2 + 1]));
              } else {
                  // key hashes equal at this level, merge into node
                  nodemap |= bit;
                  nodes.push(binaryNode(
                      this.content[thisDataIndex * 2],
                      hash(this.content[thisDataIndex * 2]),
                      this.content[thisDataIndex*2+1],
                      that.content[thatDataIndex * 2],
                      hash(that.content[thatDataIndex * 2]),
                      that.content[thatDataIndex*2+1],
                      shift + 5));
              }
              break;
          }
      }
      return new MapNode(datamap, nodemap, data.concat(nodes.reverse()));
  }

  MapNode.prototype.intersectionWith = function (Nothing, Just, eq, hash, f, that, shift) {
      if (this.constructor !== that.constructor)
          throw "Trying to intersect a MapNode with something else";

      // I'd rather declare these locally in the branches, but purs
      // compile complains about `const`.
      var thisDataIndex, thatDataIndex, thisNodeIndex, thatNodeIndex;

      var datamap = 0;
      var nodemap = 0;
      var data = [];
      var nodes = [];

      // Conceptually, we go through all of the 32 bits in the result
      // and then handle the (in/notin + left/right + data/node)
      // combinations. With this clever trick, we get to skip the 0 bits.
      var skipmap = (this.datamap | this.nodemap) & (that.datamap | that.nodemap);
      while (skipmap !== 0) {
          var bit = lowestBit(skipmap);
          skipmap &= ~bit;

          switch (mergeState(bit, this.nodemap, this.datamap, that.nodemap, that.datamap)) {
          case 5 /* NODE_NODE */:
              thisNodeIndex = index(this.nodemap, bit);
              thatNodeIndex = index(that.nodemap, bit);
              var recRes = this.content[this.content.length - thisNodeIndex - 1].
                   intersectionWith(Nothing, Just, eq, hash, f, that.content[that.content.length - thatNodeIndex - 1], shift + 5);
              if (isEmpty(recRes)) continue;
              if (recRes.isSingleton()) {
                  datamap |= bit;
                  data.push(recRes.content[0], recRes.content[1]);
              } else {
                  nodemap |= bit;
                  nodes.push(recRes);
              }
              break;
          case 6 /* DATA_NODE */:
              thisDataIndex = index(this.datamap, bit);
              thatNodeIndex = index(that.nodemap, bit);
              var k = this.content[thisDataIndex * 2];
              var v = this.content[thisDataIndex * 2 + 1];
              var hk = hash(k);
              var res = that.content[that.content.length - thatNodeIndex - 1].lookup(Nothing, Just, eq, k, hk, shift + 5);
              if (res !== Nothing) {
                  datamap |= bit;
                  data.push(k, f(v)(res.value0));
              }
              break;
          case 9 /* NODE_DATA */:
              thatDataIndex = index(that.datamap, bit);
              thisNodeIndex = index(this.nodemap, bit);
              var k = that.content[thatDataIndex * 2];
              var v = that.content[thatDataIndex * 2 + 1];
              var hk = hash(k);
              var res = this.content[this.content.length - thisNodeIndex - 1].lookup(Nothing, Just, eq, k, hk, shift + 5);
              if (res !== Nothing) {
                  datamap |= bit;
                  data.push(k, f(res.value0)(v));
              }
              break;
          case 10 /* DATA_DATA */:
              thisDataIndex = index(this.datamap, bit);
              thatDataIndex = index(that.datamap, bit);
              if (eq(this.content[thisDataIndex * 2])(that.content[thatDataIndex * 2])) {
                  datamap |= bit;
                  data.push(this.content[thisDataIndex * 2], f(this.content[thisDataIndex * 2 + 1])(that.content[thatDataIndex * 2 + 1]));
              }
              break;
          }
      }
      return new MapNode(datamap, nodemap, data.concat(nodes.reverse()));
  }

  MapNode.prototype.filterWithKey = function filterWithKey(f) {
      var datamap = 0;
      var nodemap = 0;
      var data = [];
      var nodes = [];
      var skipmap = this.datamap | this.nodemap;
      while (skipmap !== 0) {
          var bit = lowestBit(skipmap);
          skipmap &= ~bit;
          if ((this.datamap & bit) !== 0) {
              var dataIndex = index(this.datamap, bit);
              var k = this.content[dataIndex * 2];
              var v = this.content[dataIndex * 2 + 1];
              if (f(k)(v)) {
                  datamap |= bit;
                  data.push(k, v);
              }
          } else { // assert (this.nodemap & bit) !== 0
              var nodeIndex = index(this.nodemap, bit);
              var node = this.content[this.content.length - nodeIndex - 1].filterWithKey(f);
              if (isEmpty(node)) continue;
              if (node.isSingleton()) {
                  datamap |= bit;
                  data.push(node.content[0], node.content[1]);
              } else {
                  nodemap |= bit;
                  nodes.push(node);
              }
          }
      }
      return new MapNode(datamap, nodemap, data.concat(nodes.reverse()));
  }

  // This builds an n-ary curried function that takes all values and all
  // subnodes as arguments and places them in a copy of the hashmap
  // preserving the keys, datamap, and nodemap. Basically, a (Hashmap k
  // v) with s key-value pairs and t nodes turns into a function:
  //
  // k_0 -> .. -> k_s -> HashMap_0 k v -> .. -> HashMap_t k v -> HashMap k v
  //
  // Indices here are to be understood as count.
  //
  // The main use for this is the as the partial hashmap constructor in
  // place of the hole in this concept of an implementation of
  // traverseWithKey:
  //
  // pure ?here <*> f k1 v1 <*> f k2 v2 <*> traverseWithKey f n1 <*> traverseWithKey f n2
  MapNode.prototype.travHelper = function () {
      // TODO could have two helpers that basically switch mode from
      // setting values to setting nodes. That way branches would be
      // more predictable. Because the value branch is essentially
      // unpredictable.
      function go(vi, vm, ni, nm, copy) {
          if (vi < vm)
              return function (v) {
                  return go(vi + 1, vm, ni, nm, function () { var res = copy();
                                                              res.content[vi * 2 + 1] = v;
                                                              return res;
                                                            });
              }
          if (ni < nm)
              return function (n) {
                  return go(vi, vm, ni+1, nm, function () { var res = copy();
                                                            // order of parameters must match stored order
                                                            res.content[vm*2 + ni] = n;
                                                            return res;
                                                          });
              }
          return copy();
      }
      var vm = popCount(this.datamap);
      var self = this;
      return go(0, vm, 0, this.content.length - vm * 2, function () { return new MapNode(self.datamap, self.nodemap, self.content.slice()); });
  }

  MapNode.prototype.ifoldMap = function (m, mappend, f) {
      for (var i = 0; i < popCount(this.datamap) * 2;) {
          var k = this.content[i++];
          var v = this.content[i++];
          m = mappend(m)(f(k)(v));
      }
      for (; i < this.content.length; i++)
          m = this.content[i].ifoldMap(m, mappend, f);
      return m;
  }

  MapNode.prototype.itraverse = function (pure, apply, f) {
      var m = pure(this.travHelper());
      for (var i = 0; i < popCount(this.datamap) * 2;) {
          var k = this.content[i++];
          var v = this.content[i++];
          m = apply(m)(f(k)(v));
      }
      for (; i < this.content.length; i++)
          m = apply(m)(this.content[i].itraverse(pure, apply, f));
      return m;
  }

  /** @constructor */
  function Collision(keys, values) {
      this.keys = keys;
      this.values = values;
  }

  Collision.prototype.lookup = function collisionLookup(Nothing, Just, keyEquals, key, keyHash, shift) {
      for (var i = 0; i < this.keys.length; i++)
          if (keyEquals(key)(this.keys[i]))
              return new Just(this.values[i]);
      return Nothing;
  };

  Collision.prototype.insert = function collisionInsert(keyEquals, hashFunction, key, keyHash, value, shift) {
      var i = 0;
      for (; i < this.keys.length; i++)
          if (keyEquals(key)(this.keys[i]))
              break;
      return new Collision(copyAndOverwriteOrExtend1(this.keys, i, key),
                           copyAndOverwriteOrExtend1(this.values, i, value));
  };

  Collision.prototype.insertMut = function collisionInsertMut(keyEquals, hashFunction, key, keyHash, value, shift) {
      var i = 0;
      for (; i < this.keys.length; i++)
          if (keyEquals(key)(this.keys[i]))
              break;
      // i may be *after* the last element, if the key is not already in the map
      this.keys[i] = key;
      this.values[i] = value;
  };

  Collision.prototype.insertWith = function collisionInsert(keyEquals, hashFunction, f, key, keyHash, value, shift) {
      var i = 0;
      for (; i < this.keys.length; i++)
          if (keyEquals(key)(this.keys[i]))
              return new Collision(copyAndOverwriteOrExtend1(this.keys, i, key),
                                   copyAndOverwriteOrExtend1(this.values, i, f(this.values[i])(value)));
      return new Collision(copyAndOverwriteOrExtend1(this.keys, i, key),
                           copyAndOverwriteOrExtend1(this.values, i, value));
  };

  Collision.prototype.delet = function collisionDelete(keyEquals, key, keyHash, shift) {
      var i = 0;
      for (; i < this.keys.length; i++)
          if (keyEquals(key)(this.keys[i]))
              break;
      if (i === this.keys.length) return this;
      if (this.keys.length === 2)
          return new MapNode(1 << (keyHash & 31), 0, [this.keys[1 - i], this.values[1 - i]]);
      return new Collision(remove1(this.keys, i), remove1(this.values, i));
  }

  Collision.prototype.toArrayBy = function (f, res) {
      for (var i = 0; i < this.keys.length; i++)
          res.push(f(this.keys[i])(this.values[i]));
  }

  Collision.prototype.isSingleton = function () { return false; }

  Collision.prototype.eq = function(kf, vf, that) {
      if (this.constructor !== that.constructor || this.keys.length !== that.keys.length) return false;
      outer:
      for (var i = 0; i < this.keys.length; i++) {
          for (var j = 0; j < that.keys.length; j++) {
              if (kf(this.keys[i])(that.keys[j])) {
                  if (vf(this.values[i])(that.values[j]))
                      continue outer;
                  else
                      return false;
              }
          }
      }
      return true;
  }

  Collision.prototype.hash = function (vhash) {
      // We ignore keys because they have all the same hash anyways
      // (we're in a collision node!)
      var h = 0;
      // We use just + here, not multiply&add, because order in
      // collision nodes is undefined. A commutative combining operation
      // allows us to simply ignore the order.
      for (var i = 0; i < this.values.length; i++)
          h += vhash(this.values[i]);
      return h;
  }

  Collision.prototype.size = function () {
      return this.keys.length;
  }

  Collision.prototype.imap = function (f) {
      var newValues = this.values.slice();
      for (var i = 0; i < this.values.length; i++)
          newValues[i] = f(this.keys[i])(this.values[i]);
      return new Collision(this.keys, newValues);
  }

  Collision.prototype.ifoldMap = function (m, mappend, f) {
      for (var i = 0; i < this.keys.length; i++)
          m = mappend(m)(f(this.keys[i])(this.values[i]));
      return m;
  }

  Collision.prototype.travHelper = function () {
      function go(i, m, copy) {
          if (i < m)
              return function (v) {
                  return go(i + 1, m, function () { var res = copy();
                                                    res.values[i] = v;
                                                    return res;
                                                  });
              }
          return copy();
      }
      var self = this;
      return go(0, this.keys.length, function () { return new Collision(self.keys, self.values.slice()); });
  }

  Collision.prototype.itraverse = function (pure, apply, f) {
      var m = pure(this.travHelper());
      for (var i = 0; i < this.keys.length; i++)
          m = apply(m)(f(this.keys[i])(this.values[i]));
      return m;
  }

  Collision.prototype.unionWith = function (eq, hash, f, that, shift) {
      if (that.constructor !== Collision)
          throw "Trying to union a Collision with something else";
      var keys = [];
      var values = [];
      var added = Array(that.keys.length).fill(false);
      outer:
      for (var i = 0; i < this.keys.length; i++) {
          for (var j = 0; j < that.keys.length; j++) {
              if (eq(this.keys[i])(that.keys[j])) {
                  keys.push(this.keys[i]);
                  values.push(f(this.values[i])(that.values[j]));
                  added[j] = true;
                  continue outer;
              }
          }
          keys.push(this.keys[i]);
          values.push(this.values[i]);
          added[j] = true;
      }
      for (var k = 0; k < that.keys.length; k++) {
          if (!added[k]) {
              keys.push(that.keys[k]);
              values.push(that.values[k]);
          }
      }
      return new Collision(keys, values);
  }

  Collision.prototype.intersectionWith = function (Nothing, Just, eq, hash, f, that, shift) {
      if (that.constructor !== Collision)
          throw "Trying to intersect a Collision with something else";
      var keys = [];
      var values = [];
      outer:
      for (var i = 0; i < this.keys.length; i++) {
          for (var j = 0; j < that.keys.length; j++) {
              if (eq(this.keys[i])(that.keys[j])) {
                  keys.push(this.keys[i]);
                  values.push(f(this.values[i])(that.values[j]));
                  continue outer;
              }
          }
      }
      if (keys.length === 0)
          return empty;
      // This is a bit dodgy. We return a fake MapNode (wrong datamap
      // (WHICH CANNOT BE 0, OTHERWISE isEmpty THINKS IT'S EMPTY!) and
      // nodemap), but it's okay, because we will immediately
      // deconstruct it in the MapNode.intersectionWith.
      if (keys.length === 1)
          return new MapNode(1, 0, [keys[0], values[0]]);
      return new Collision(keys, values);
  }

  Collision.prototype.filterWithKey = function collisionFilterWithKey(f) {
      var keys = [];
      var values = [];
      for (var i = 0; i < this.keys.length; i++) {
          var k = this.keys[i];
          var v = this.values[i];
          if (f(k)(v)) {
              keys.push(k);
              values.push(v);
          }
      }
      if (keys.length === 0) return empty;
      // This is a bit dodgy. We return a fake MapNode (wrong datamap
      // (WHICH CANNOT BE 0, OTHERWISE isEmpty THINKS IT'S EMPTY!) and
      // nodemap), but it's okay, because we will immediately
      // deconstruct it in MapNode's filterWithKey.
      if (keys.length === 1) return new MapNode(1, 0, [keys[0], values[0]]);
      return new Collision(keys, values);
  }

  function mask(keyHash, shift) {
      return 1 << ((keyHash >>> shift) & 31);
  }

  function index(map, bit) {
      return popCount(map & (bit - 1));
  }

  function popCount (n) {
      n = n - ((n >> 1) & 0x55555555);
      n = (n & 0x33333333) + ((n >> 2) & 0x33333333);
      return ((n + (n >> 4) & 0xF0F0F0F) * 0x1010101) >> 24;
  }

  function binaryNode(k1, kh1, v1, k2, kh2, v2, s) {
      if (s >= 32) return new Collision([k1, k2], [v1, v2]);

      var b1 = (kh1 >>> s) & 31;
      var b2 = (kh2 >>> s) & 31;

      if (b1 !== b2) return new MapNode((1 << b1) | (1 << b2), 0, (b1 >>> 0) < (b2 >>> 0) ? [k1, v1, k2, v2] : [k2, v2, k1, v1]);

      return new MapNode(0, 1 << b1, [binaryNode(k1, kh1, v1, k2, kh2, v2, s + 5)]);
  }

  function overwriteTwoElements(a, index, v1, v2) {
      var res = a.slice();
      res[index] = v1;
      res[index+1] = v2;
      return res;
  }

  // TODO benchmark some alternative implementations (manual copy, slice
  // left + copy?, slice both + concat?, ...)
  function remove2(a, index) {
      var res = a.slice();
      res.splice(index, 2);
      return res;
  }

  // I think this is always called with a node index? Therefore, the
  // left will often be larger than the right. Does that help?
  function remove1(a, index) {
      var res = a.slice();
      res.splice(index, 1);
      return res;
  }

  // Make a copy while overwriting the element at index, or adding one element if index == a.length
  function copyAndOverwriteOrExtend1(a, index, v) {
      var res = a.slice();
      res[index] = v;
      return res;
  }

  function remove2insert1(a, removeIndex, insertIndex, v1) {
      var res = new Array(a.length - 1);
      for (var i = 0; i < removeIndex; i++) res[i] = a[i];
      for (; i < insertIndex; i++) res[i] = a[i+2];
      res[i++] = v1;
      for (; i < res.length; i++) res[i] = a[i+1];
      return res;
  }

  function insert2(a, index, v1, v2) {
      var res = new Array(a.length + 2);
      for (var i = 0; i < index; i++) res[i] = a[i];
      res[i++] = v1;
      res[i++] = v2;
      for (; i < res.length; i++) res[i] = a[i - 2];
      return res;
  }

  function insert2remove1(a, insertIndex, v1, v2, removeIndex) {
      var res = new Array(a.length + 1);
      for (var i = 0; i < insertIndex; i++) res[i] = a[i];
      res[i++] = v1;
      res[i++] = v2;
      for (; i < removeIndex + 2; i++) res[i] = a[i-2];
      for (; i < res.length; i++) res[i] = a[i-1];
      return res;
  }

  var empty = new MapNode(0,0,[]);

  exports.empty = empty;

  exports.lookupPurs = function (Nothing, Just, keyEquals, key, keyHash) {
      return function (m) {
          return m.lookup(Nothing, Just, keyEquals, key, keyHash, 0);
      };
  };

  exports.insertPurs = function (keyEquals, hashFunction) {
      return function (key) {
          return function (value) {
              return function (m) {
                  return m.insert(keyEquals, hashFunction, key, hashFunction(key), value, 0);
              };
          };
      };
  };

  exports.toArrayBy = function (f) {
      return function (m) {
          var res = [];
          m.toArrayBy(f, res);
          return res;
      };
  };

  function isEmpty (m) {
      return m.datamap === 0 && m.nodemap === 0;
  }
})(PS["Data.HashMap"] = PS["Data.HashMap"] || {});
(function(exports) {
  // This Source Code Form is subject to the terms of the Mozilla Public
  // License, v. 2.0. If a copy of the MPL was not distributed with this
  // file, You can obtain one at http://mozilla.org/MPL/2.0/.

  "use strict";

  exports.hashString = function (s) {
      var h = 0;
      for (var i = 0; i < s.length; i++) {
          h = (31 * h + s.charCodeAt(i)) | 0;
      }
      return h;
  };
})(PS["Data.Hashable"] = PS["Data.Hashable"] || {});
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Data.Hashable"] = $PS["Data.Hashable"] || {};
  var exports = $PS["Data.Hashable"];
  var $foreign = $PS["Data.Hashable"];
  var Data_Eq = $PS["Data.Eq"];
  var Hashable = function (Eq0, hash) {
      this.Eq0 = Eq0;
      this.hash = hash;
  }; 
  var hashableString = new Hashable(function () {
      return Data_Eq.eqString;
  }, $foreign.hashString);
  var hash = function (dict) {
      return dict.hash;
  };
  exports["hash"] = hash;
  exports["hashableString"] = hashableString;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Data.HashMap"] = $PS["Data.HashMap"] || {};
  var exports = $PS["Data.HashMap"];
  var $foreign = $PS["Data.HashMap"];
  var Data_Eq = $PS["Data.Eq"];
  var Data_Hashable = $PS["Data.Hashable"];
  var Data_Maybe = $PS["Data.Maybe"];
  var lookup = function (dictHashable) {
      return function (k) {
          return $foreign.lookupPurs(Data_Maybe.Nothing.value, Data_Maybe.Just.create, Data_Eq.eq(dictHashable.Eq0()), k, Data_Hashable.hash(dictHashable)(k));
      };
  };
  var insert = function (dictHashable) {
      return $foreign.insertPurs(Data_Eq.eq(dictHashable.Eq0()), Data_Hashable.hash(dictHashable));
  };
  exports["lookup"] = lookup;
  exports["insert"] = insert;
  exports["empty"] = $foreign.empty;
  exports["toArrayBy"] = $foreign.toArrayBy;
})(PS);
(function(exports) {
  "use strict";

  exports.toNumber = function (n) {
    return n;
  };
})(PS["Data.Int"] = PS["Data.Int"] || {});
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Data.Int"] = $PS["Data.Int"] || {};
  var exports = $PS["Data.Int"];
  var $foreign = $PS["Data.Int"];
  exports["toNumber"] = $foreign.toNumber;
})(PS);
(function(exports) {
  // global exports
  "use strict";

  exports.dateMethod = function(method, date) {
    return date[method]();
  };

  exports.parse = function(dateString) {
    return function() {
      return new Date(dateString);
    };
  };
})(PS["Data.JSDate"] = PS["Data.JSDate"] || {});
(function(exports) {
  "use strict";

  exports.showNumberImpl = function (n) {
    var str = n.toString();
    return isNaN(str + ".0") ? str : str + ".0";
  };

  exports.cons = function (head) {
    return function (tail) {
      return [head].concat(tail);
    };
  };

  exports.join = function (separator) {
    return function (xs) {
      return xs.join(separator);
    };
  };
})(PS["Data.Show"] = PS["Data.Show"] || {});
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Data.Symbol"] = $PS["Data.Symbol"] || {};
  var exports = $PS["Data.Symbol"];
  var IsSymbol = function (reflectSymbol) {
      this.reflectSymbol = reflectSymbol;
  };
  var reflectSymbol = function (dict) {
      return dict.reflectSymbol;
  };
  exports["IsSymbol"] = IsSymbol;
  exports["reflectSymbol"] = reflectSymbol;
})(PS);
(function(exports) {
  "use strict";

  exports.unsafeGet = function (label) {
    return function (rec) {
      return rec[label];
    };
  };
})(PS["Record.Unsafe"] = PS["Record.Unsafe"] || {});
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Record.Unsafe"] = $PS["Record.Unsafe"] || {};
  var exports = $PS["Record.Unsafe"];
  var $foreign = $PS["Record.Unsafe"];
  exports["unsafeGet"] = $foreign.unsafeGet;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Type.Proxy"] = $PS["Type.Proxy"] || {};
  var exports = $PS["Type.Proxy"];
  var $$Proxy = (function () {
      function $$Proxy() {

      };
      $$Proxy.value = new $$Proxy();
      return $$Proxy;
  })();
  exports["Proxy"] = $$Proxy;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Data.Show"] = $PS["Data.Show"] || {};
  var exports = $PS["Data.Show"];
  var $foreign = $PS["Data.Show"];
  var Data_Symbol = $PS["Data.Symbol"];
  var Record_Unsafe = $PS["Record.Unsafe"];
  var Type_Proxy = $PS["Type.Proxy"];                
  var ShowRecordFields = function (showRecordFields) {
      this.showRecordFields = showRecordFields;
  };
  var Show = function (show) {
      this.show = show;
  };                                                 
  var showRecordFieldsNil = new ShowRecordFields(function (v) {
      return function (v1) {
          return [  ];
      };
  });
  var showRecordFields = function (dict) {
      return dict.showRecordFields;
  };
  var showRecord = function (dictRowToList) {
      return function (dictShowRecordFields) {
          return new Show(function (record) {
              var v = showRecordFields(dictShowRecordFields)(Type_Proxy["Proxy"].value)(record);
              if (v.length === 0) {
                  return "{}";
              };
              return $foreign.join(" ")([ "{", $foreign.join(", ")(v), "}" ]);
          });
      };
  }; 
  var showNumber = new Show($foreign.showNumberImpl);
  var show = function (dict) {
      return dict.show;
  };
  var showRecordFieldsCons = function (dictIsSymbol) {
      return function (dictShowRecordFields) {
          return function (dictShow) {
              return new ShowRecordFields(function (v) {
                  return function (record) {
                      var tail = showRecordFields(dictShowRecordFields)(Type_Proxy["Proxy"].value)(record);
                      var key = Data_Symbol.reflectSymbol(dictIsSymbol)(Type_Proxy["Proxy"].value);
                      var focus = Record_Unsafe.unsafeGet(key)(record);
                      return $foreign.cons($foreign.join(": ")([ key, show(dictShow)(focus) ]))(tail);
                  };
              });
          };
      };
  };
  exports["Show"] = Show;
  exports["show"] = show;
  exports["showNumber"] = showNumber;
  exports["showRecord"] = showRecord;
  exports["showRecordFieldsNil"] = showRecordFieldsNil;
  exports["showRecordFieldsCons"] = showRecordFieldsCons;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Data.JSDate"] = $PS["Data.JSDate"] || {};
  var exports = $PS["Data.JSDate"];
  var $foreign = $PS["Data.JSDate"];
  var Data_Eq = $PS["Data.Eq"];
  var Data_Ord = $PS["Data.Ord"];
  var Data_Show = $PS["Data.Show"];                                                                                                                 
  var toDateString = function (dt) {
      return $foreign.dateMethod("toDateString", dt);
  };
  var getTime = function (dt) {
      return $foreign.dateMethod("getTime", dt);
  };
  var showJSDate = new Data_Show.Show(function (a) {
      return "(fromTime " + (Data_Show.show(Data_Show.showNumber)(getTime(a)) + ")");
  });
  var eqJSDate = new Data_Eq.Eq(function (a) {
      return function (b) {
          return getTime(a) === getTime(b);
      };
  });
  var ordJSDate = new Data_Ord.Ord(function () {
      return eqJSDate;
  }, function (a) {
      return function (b) {
          return Data_Ord.compare(Data_Ord.ordNumber)(getTime(a))(getTime(b));
      };
  });
  exports["getTime"] = getTime;
  exports["toDateString"] = toDateString;
  exports["ordJSDate"] = ordJSDate;
  exports["showJSDate"] = showJSDate;
  exports["parse"] = $foreign.parse;
})(PS);
(function(exports) {
  /* eslint-disable no-eq-null, eqeqeq */

  "use strict";          

  exports.nullable = function (a, r, f) {
    return a == null ? r : f(a);
  };
})(PS["Data.Nullable"] = PS["Data.Nullable"] || {});
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Data.Nullable"] = $PS["Data.Nullable"] || {};
  var exports = $PS["Data.Nullable"];
  var $foreign = $PS["Data.Nullable"];
  var Data_Maybe = $PS["Data.Maybe"];                                   
  var toMaybe = function (n) {
      return $foreign.nullable(n, Data_Maybe.Nothing.value, Data_Maybe.Just.create);
  };
  exports["toMaybe"] = toMaybe;
})(PS);
(function(exports) {
  "use strict";

  exports.intercalate = function (separator) {
    return function (xs) {
      var len = xs.length;
      if (len === 0) return "";

      var res = xs[0];
      for (var i = 1; i < len; i++) {
        res = res + separator + xs[i];
      }
      return res;
    };
  };
})(PS["Data.Show.Generic"] = PS["Data.Show.Generic"] || {});
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Data.Show.Generic"] = $PS["Data.Show.Generic"] || {};
  var exports = $PS["Data.Show.Generic"];
  var $foreign = $PS["Data.Show.Generic"];
  var Data_Generic_Rep = $PS["Data.Generic.Rep"];
  var Data_Semigroup = $PS["Data.Semigroup"];
  var Data_Show = $PS["Data.Show"];
  var Data_Symbol = $PS["Data.Symbol"];
  var Type_Proxy = $PS["Type.Proxy"];                
  var GenericShowArgs = function (genericShowArgs) {
      this.genericShowArgs = genericShowArgs;
  };
  var GenericShow = function (genericShow$prime) {
      this["genericShow'"] = genericShow$prime;
  }; 
  var genericShowArgsArgument = function (dictShow) {
      return new GenericShowArgs(function (v) {
          return [ Data_Show.show(dictShow)(v) ];
      });
  };
  var genericShowArgs = function (dict) {
      return dict.genericShowArgs;
  };
  var genericShowArgsProduct = function (dictGenericShowArgs) {
      return function (dictGenericShowArgs1) {
          return new GenericShowArgs(function (v) {
              return Data_Semigroup.append(Data_Semigroup.semigroupArray)(genericShowArgs(dictGenericShowArgs)(v.value0))(genericShowArgs(dictGenericShowArgs1)(v.value1));
          });
      };
  };
  var genericShowConstructor = function (dictGenericShowArgs) {
      return function (dictIsSymbol) {
          return new GenericShow(function (v) {
              var ctor = Data_Symbol.reflectSymbol(dictIsSymbol)(Type_Proxy["Proxy"].value);
              var v1 = genericShowArgs(dictGenericShowArgs)(v);
              if (v1.length === 0) {
                  return ctor;
              };
              return "(" + ($foreign.intercalate(" ")(Data_Semigroup.append(Data_Semigroup.semigroupArray)([ ctor ])(v1)) + ")");
          });
      };
  };
  var genericShow$prime = function (dict) {
      return dict["genericShow'"];
  }; 
  var genericShowSum = function (dictGenericShow) {
      return function (dictGenericShow1) {
          return new GenericShow(function (v) {
              if (v instanceof Data_Generic_Rep.Inl) {
                  return genericShow$prime(dictGenericShow)(v.value0);
              };
              if (v instanceof Data_Generic_Rep.Inr) {
                  return genericShow$prime(dictGenericShow1)(v.value0);
              };
              throw new Error("Failed pattern match at Data.Show.Generic (line 26, column 1 - line 28, column 40): " + [ v.constructor.name ]);
          });
      };
  };
  var genericShow = function (dictGeneric) {
      return function (dictGenericShow) {
          return function (x) {
              return genericShow$prime(dictGenericShow)(Data_Generic_Rep.from(dictGeneric)(x));
          };
      };
  };
  exports["genericShow"] = genericShow;
  exports["genericShowSum"] = genericShowSum;
  exports["genericShowArgsProduct"] = genericShowArgsProduct;
  exports["genericShowConstructor"] = genericShowConstructor;
  exports["genericShowArgsArgument"] = genericShowArgsArgument;
})(PS);
(function(exports) {
  "use strict";

  exports.trim = function (s) {
    return s.trim();
  };
})(PS["Data.String.Common"] = PS["Data.String.Common"] || {});
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Data.String.Common"] = $PS["Data.String.Common"] || {};
  var exports = $PS["Data.String.Common"];
  var $foreign = $PS["Data.String.Common"];
  exports["trim"] = $foreign.trim;
})(PS);
(function(exports) {
  "use strict";

  // jshint maxparams: 3

  exports.traverseArrayImpl = (function () {
    function array1(a) {
      return [a];
    }

    function array2(a) {
      return function (b) {
        return [a, b];
      };
    }

    function array3(a) {
      return function (b) {
        return function (c) {
          return [a, b, c];
        };
      };
    }

    function concat2(xs) {
      return function (ys) {
        return xs.concat(ys);
      };
    }

    return function (apply) {
      return function (map) {
        return function (pure) {
          return function (f) {
            return function (array) {
              function go(bot, top) {
                switch (top - bot) {
                case 0: return pure([]);
                case 1: return map(array1)(f(array[bot]));
                case 2: return apply(map(array2)(f(array[bot])))(f(array[bot + 1]));
                case 3: return apply(apply(map(array3)(f(array[bot])))(f(array[bot + 1])))(f(array[bot + 2]));
                default:
                  // This slightly tricky pivot selection aims to produce two
                  // even-length partitions where possible.
                  var pivot = bot + Math.floor((top - bot) / 4) * 2;
                  return apply(map(concat2)(go(bot, pivot)))(go(pivot, top));
                }
              }
              return go(0, array.length);
            };
          };
        };
      };
    };
  })();
})(PS["Data.Traversable"] = PS["Data.Traversable"] || {});
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Data.Traversable"] = $PS["Data.Traversable"] || {};
  var exports = $PS["Data.Traversable"];
  var $foreign = $PS["Data.Traversable"];
  var Control_Applicative = $PS["Control.Applicative"];
  var Control_Apply = $PS["Control.Apply"];
  var Control_Category = $PS["Control.Category"];
  var Data_Foldable = $PS["Data.Foldable"];
  var Data_Functor = $PS["Data.Functor"];            
  var Traversable = function (Foldable1, Functor0, sequence, traverse) {
      this.Foldable1 = Foldable1;
      this.Functor0 = Functor0;
      this.sequence = sequence;
      this.traverse = traverse;
  };
  var traverse = function (dict) {
      return dict.traverse;
  }; 
  var sequenceDefault = function (dictTraversable) {
      return function (dictApplicative) {
          return traverse(dictTraversable)(dictApplicative)(Control_Category.identity(Control_Category.categoryFn));
      };
  };
  var traversableArray = new Traversable(function () {
      return Data_Foldable.foldableArray;
  }, function () {
      return Data_Functor.functorArray;
  }, function (dictApplicative) {
      return sequenceDefault(traversableArray)(dictApplicative);
  }, function (dictApplicative) {
      return $foreign.traverseArrayImpl(Control_Apply.apply(dictApplicative.Apply0()))(Data_Functor.map((dictApplicative.Apply0()).Functor0()))(Control_Applicative.pure(dictApplicative));
  });
  exports["traverse"] = traverse;
  exports["traversableArray"] = traversableArray;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Data.Tuple"] = $PS["Data.Tuple"] || {};
  var exports = $PS["Data.Tuple"];                 
  var Tuple = (function () {
      function Tuple(value0, value1) {
          this.value0 = value0;
          this.value1 = value1;
      };
      Tuple.create = function (value0) {
          return function (value1) {
              return new Tuple(value0, value1);
          };
      };
      return Tuple;
  })();
  var uncurry = function (f) {
      return function (v) {
          return f(v.value0)(v.value1);
      };
  };
  var snd = function (v) {
      return v.value1;
  };
  exports["Tuple"] = Tuple;
  exports["snd"] = snd;
  exports["uncurry"] = uncurry;
})(PS);
(function(exports) {
  "use strict";

  exports.pureE = function (a) {
    return function () {
      return a;
    };
  };

  exports.bindE = function (a) {
    return function (f) {
      return function () {
        return f(a())();
      };
    };
  };
})(PS["Effect"] = PS["Effect"] || {});
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Effect"] = $PS["Effect"] || {};
  var exports = $PS["Effect"];
  var $foreign = $PS["Effect"];
  var Control_Applicative = $PS["Control.Applicative"];
  var Control_Apply = $PS["Control.Apply"];
  var Control_Bind = $PS["Control.Bind"];
  var Control_Monad = $PS["Control.Monad"];
  var Data_Functor = $PS["Data.Functor"];                    
  var monadEffect = new Control_Monad.Monad(function () {
      return applicativeEffect;
  }, function () {
      return bindEffect;
  });
  var bindEffect = new Control_Bind.Bind(function () {
      return applyEffect;
  }, $foreign.bindE);
  var applyEffect = new Control_Apply.Apply(function () {
      return functorEffect;
  }, Control_Monad.ap(monadEffect));
  var applicativeEffect = new Control_Applicative.Applicative(function () {
      return applyEffect;
  }, $foreign.pureE);
  var functorEffect = new Data_Functor.Functor(Control_Applicative.liftA1(applicativeEffect));
  exports["functorEffect"] = functorEffect;
  exports["applicativeEffect"] = applicativeEffect;
  exports["bindEffect"] = bindEffect;
})(PS);
(function(exports) {
  "use strict";

  exports.error = function (msg) {
    return new Error(msg);
  };

  exports.throwException = function (e) {
    return function () {
      throw e;
    };
  };
})(PS["Effect.Exception"] = PS["Effect.Exception"] || {});
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Effect.Exception"] = $PS["Effect.Exception"] || {};
  var exports = $PS["Effect.Exception"];
  var $foreign = $PS["Effect.Exception"];
  var $$throw = function ($2) {
      return $foreign.throwException($foreign.error($2));
  };
  exports["throw"] = $$throw;
})(PS);
(function(exports) {
  "use strict";

  exports.innerText = function(element) {
      return function() {
          return element.innerText;
      };
  };

  exports.renderDateTime = function(date) {
      return function() {
          return date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
      };
  };
})(PS["Main"] = PS["Main"] || {});
(function(exports) {
  "use strict";

  exports.remove = function (node) {
    return function () {
      return node.remove();
    };
  };
})(PS["Web.DOM.ChildNode"] = PS["Web.DOM.ChildNode"] || {});
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Web.DOM.ChildNode"] = $PS["Web.DOM.ChildNode"] || {};
  var exports = $PS["Web.DOM.ChildNode"];
  var $foreign = $PS["Web.DOM.ChildNode"];
  exports["remove"] = $foreign.remove;
})(PS);
(function(exports) {
  "use strict";

  exports.createElement = function (localName) {
    return function (doc) {
      return function () {
        return doc.createElement(localName);
      };
    };
  };
})(PS["Web.DOM.Document"] = PS["Web.DOM.Document"] || {});
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Web.DOM.Document"] = $PS["Web.DOM.Document"] || {};
  var exports = $PS["Web.DOM.Document"];
  var $foreign = $PS["Web.DOM.Document"];
  exports["createElement"] = $foreign.createElement;
})(PS);
(function(exports) {
  "use strict";

  exports.setAttribute = function (name) {
    return function (value) {
      return function (element) {
        return function () {
          element.setAttribute(name, value);
        };
      };
    };
  };
})(PS["Web.DOM.Element"] = PS["Web.DOM.Element"] || {});
(function(exports) {
  "use strict";

  // module Unsafe.Coerce

  exports.unsafeCoerce = function (x) {
    return x;
  };
})(PS["Unsafe.Coerce"] = PS["Unsafe.Coerce"] || {});
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Unsafe.Coerce"] = $PS["Unsafe.Coerce"] || {};
  var exports = $PS["Unsafe.Coerce"];
  var $foreign = $PS["Unsafe.Coerce"];
  exports["unsafeCoerce"] = $foreign.unsafeCoerce;
})(PS);
(function(exports) {
  "use strict";

  exports._unsafeReadProtoTagged = function (nothing, just, name, value) {
    if (typeof window !== "undefined") {
      var ty = window[name];
      if (ty != null && value instanceof ty) {
        return just(value);
      }
    }
    var obj = value;
    while (obj != null) {
      var proto = Object.getPrototypeOf(obj);
      var constructorName = proto.constructor.name;
      if (constructorName === name) {
        return just(value);
      } else if (constructorName === "Object") {
        return nothing;
      }
      obj = proto;
    }
    return nothing;
  };
})(PS["Web.Internal.FFI"] = PS["Web.Internal.FFI"] || {});
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Web.Internal.FFI"] = $PS["Web.Internal.FFI"] || {};
  var exports = $PS["Web.Internal.FFI"];
  var $foreign = $PS["Web.Internal.FFI"];
  var Data_Maybe = $PS["Data.Maybe"];                
  var unsafeReadProtoTagged = function (name) {
      return function (value) {
          return $foreign["_unsafeReadProtoTagged"](Data_Maybe.Nothing.value, Data_Maybe.Just.create, name, value);
      };
  };
  exports["unsafeReadProtoTagged"] = unsafeReadProtoTagged;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Web.DOM.Element"] = $PS["Web.DOM.Element"] || {};
  var exports = $PS["Web.DOM.Element"];
  var $foreign = $PS["Web.DOM.Element"];
  var Unsafe_Coerce = $PS["Unsafe.Coerce"];
  var Web_Internal_FFI = $PS["Web.Internal.FFI"];                
  var toParentNode = Unsafe_Coerce.unsafeCoerce;              
  var toNode = Unsafe_Coerce.unsafeCoerce;       
  var toChildNode = Unsafe_Coerce.unsafeCoerce;                                        
  var fromNode = Web_Internal_FFI.unsafeReadProtoTagged("Element");
  exports["fromNode"] = fromNode;
  exports["toNode"] = toNode;
  exports["toChildNode"] = toChildNode;
  exports["toParentNode"] = toParentNode;
  exports["setAttribute"] = $foreign.setAttribute;
})(PS);
(function(exports) {
  "use strict";

  exports.toArray = function (list) {
    return function () {
      return [].slice.call(list);
    };
  };
})(PS["Web.DOM.HTMLCollection"] = PS["Web.DOM.HTMLCollection"] || {});
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Web.DOM.HTMLCollection"] = $PS["Web.DOM.HTMLCollection"] || {};
  var exports = $PS["Web.DOM.HTMLCollection"];
  var $foreign = $PS["Web.DOM.HTMLCollection"];
  exports["toArray"] = $foreign.toArray;
})(PS);
(function(exports) {
  "use strict";                                   

  exports.setTextContent = function (value) {
    return function (node) {
      return function () {
        node.textContent = value;
      };
    };
  };

  exports.appendChild = function (node) {
    return function (parent) {
      return function () {
        parent.appendChild(node);
      };
    };
  };
})(PS["Web.DOM.Node"] = PS["Web.DOM.Node"] || {});
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Web.DOM.Node"] = $PS["Web.DOM.Node"] || {};
  var exports = $PS["Web.DOM.Node"];
  var $foreign = $PS["Web.DOM.Node"];
  exports["setTextContent"] = $foreign.setTextContent;
  exports["appendChild"] = $foreign.appendChild;
})(PS);
(function(exports) {
  "use strict";

  exports.toArray = function (list) {
    return function () {
      return [].slice.call(list);
    };
  };
})(PS["Web.DOM.NodeList"] = PS["Web.DOM.NodeList"] || {});
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Web.DOM.NodeList"] = $PS["Web.DOM.NodeList"] || {};
  var exports = $PS["Web.DOM.NodeList"];
  var $foreign = $PS["Web.DOM.NodeList"];
  exports["toArray"] = $foreign.toArray;
})(PS);
(function(exports) {
  "use strict";

  var getEffProp = function (name) {
    return function (node) {
      return function () {
        return node[name];
      };
    };
  };

  exports.children = getEffProp("children");                  

  exports._querySelector = function (selector) {
    return function (node) {
      return function () {
        return node.querySelector(selector);
      };
    };
  };

  exports.querySelectorAll = function (selector) {
    return function (node) {
      return function () {
        return node.querySelectorAll(selector);
      };
    };
  };
})(PS["Web.DOM.ParentNode"] = PS["Web.DOM.ParentNode"] || {});
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Web.DOM.ParentNode"] = $PS["Web.DOM.ParentNode"] || {};
  var exports = $PS["Web.DOM.ParentNode"];
  var $foreign = $PS["Web.DOM.ParentNode"];
  var Data_Functor = $PS["Data.Functor"];
  var Data_Nullable = $PS["Data.Nullable"];
  var Effect = $PS["Effect"];
  var querySelector = function (qs) {
      var $0 = Data_Functor.map(Effect.functorEffect)(Data_Nullable.toMaybe);
      var $1 = $foreign["_querySelector"](qs);
      return function ($2) {
          return $0($1($2));
      };
  };
  exports["querySelector"] = querySelector;
  exports["children"] = $foreign.children;
  exports["querySelectorAll"] = $foreign.querySelectorAll;
})(PS);
(function(exports) {
  "use strict";

  exports.window = function () {
    return window;
  };
})(PS["Web.HTML"] = PS["Web.HTML"] || {});
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Web.HTML"] = $PS["Web.HTML"] || {};
  var exports = $PS["Web.HTML"];
  var $foreign = $PS["Web.HTML"];
  exports["window"] = $foreign.window;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Web.HTML.HTMLDocument"] = $PS["Web.HTML.HTMLDocument"] || {};
  var exports = $PS["Web.HTML.HTMLDocument"];
  var Unsafe_Coerce = $PS["Unsafe.Coerce"];                      
  var toParentNode = Unsafe_Coerce.unsafeCoerce; 
  var toDocument = Unsafe_Coerce.unsafeCoerce;
  exports["toDocument"] = toDocument;
  exports["toParentNode"] = toParentNode;
})(PS);
(function(exports) {
  "use strict";

  exports._read = function (nothing, just, value) {
    var tag = Object.prototype.toString.call(value);
    if (tag.indexOf("[object HTML") === 0 && tag.indexOf("Element]") === tag.length - 8) {
      return just(value);
    } else {
      return nothing;
    }
  };
})(PS["Web.HTML.HTMLElement"] = PS["Web.HTML.HTMLElement"] || {});
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Web.HTML.HTMLElement"] = $PS["Web.HTML.HTMLElement"] || {};
  var exports = $PS["Web.HTML.HTMLElement"];
  var $foreign = $PS["Web.HTML.HTMLElement"];
  var Data_Maybe = $PS["Data.Maybe"];
  var fromNode = function (x) {
      return $foreign["_read"](Data_Maybe.Nothing.value, Data_Maybe.Just.create, x);
  };
  exports["fromNode"] = fromNode;
})(PS);
(function(exports) {
  "use strict";

  exports.document = function (window) {
    return function () {
      return window.document;
    };
  };
})(PS["Web.HTML.Window"] = PS["Web.HTML.Window"] || {});
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Web.HTML.Window"] = $PS["Web.HTML.Window"] || {};
  var exports = $PS["Web.HTML.Window"];
  var $foreign = $PS["Web.HTML.Window"];
  exports["document"] = $foreign.document;
})(PS);
(function($PS) {
  // Generated by purs version 0.14.1
  "use strict";
  $PS["Main"] = $PS["Main"] || {};
  var exports = $PS["Main"];
  var $foreign = $PS["Main"];
  var Control_Applicative = $PS["Control.Applicative"];
  var Control_Bind = $PS["Control.Bind"];
  var Data_Array = $PS["Data.Array"];
  var Data_Boolean = $PS["Data.Boolean"];
  var Data_Foldable = $PS["Data.Foldable"];
  var Data_Function = $PS["Data.Function"];
  var Data_Functor = $PS["Data.Functor"];
  var Data_Generic_Rep = $PS["Data.Generic.Rep"];
  var Data_HashMap = $PS["Data.HashMap"];
  var Data_Hashable = $PS["Data.Hashable"];
  var Data_Int = $PS["Data.Int"];
  var Data_JSDate = $PS["Data.JSDate"];
  var Data_Maybe = $PS["Data.Maybe"];
  var Data_Ord = $PS["Data.Ord"];
  var Data_Show = $PS["Data.Show"];
  var Data_Show_Generic = $PS["Data.Show.Generic"];
  var Data_String_Common = $PS["Data.String.Common"];
  var Data_Symbol = $PS["Data.Symbol"];
  var Data_Traversable = $PS["Data.Traversable"];
  var Data_Tuple = $PS["Data.Tuple"];
  var Effect = $PS["Effect"];
  var Effect_Exception = $PS["Effect.Exception"];
  var Web_DOM_ChildNode = $PS["Web.DOM.ChildNode"];
  var Web_DOM_Document = $PS["Web.DOM.Document"];
  var Web_DOM_Element = $PS["Web.DOM.Element"];
  var Web_DOM_HTMLCollection = $PS["Web.DOM.HTMLCollection"];
  var Web_DOM_Node = $PS["Web.DOM.Node"];
  var Web_DOM_NodeList = $PS["Web.DOM.NodeList"];
  var Web_DOM_ParentNode = $PS["Web.DOM.ParentNode"];
  var Web_HTML = $PS["Web.HTML"];
  var Web_HTML_HTMLDocument = $PS["Web.HTML.HTMLDocument"];
  var Web_HTML_HTMLElement = $PS["Web.HTML.HTMLElement"];
  var Web_HTML_Window = $PS["Web.HTML.Window"];                
  var Single = (function () {
      function Single(value0) {
          this.value0 = value0;
      };
      Single.create = function (value0) {
          return new Single(value0);
      };
      return Single;
  })();
  var After = (function () {
      function After(value0, value1) {
          this.value0 = value0;
          this.value1 = value1;
      };
      After.create = function (value0) {
          return function (value1) {
              return new After(value0, value1);
          };
      };
      return After;
  })();
  var Parallel = (function () {
      function Parallel(value0, value1) {
          this.value0 = value0;
          this.value1 = value1;
      };
      Parallel.create = function (value0) {
          return function (value1) {
              return new Parallel(value0, value1);
          };
      };
      return Parallel;
  })();
  var scheduleStart = function (v) {
      if (v instanceof Single) {
          return v.value0.start;
      };
      if (v instanceof After) {
          return scheduleStart(v.value0);
      };
      if (v instanceof Parallel) {
          return Data_Ord.min(Data_JSDate.ordJSDate)(scheduleStart(v.value0))(scheduleStart(v.value1));
      };
      throw new Error("Failed pattern match at Main (line 50, column 1 - line 50, column 53): " + [ v.constructor.name ]);
  };
  var scheduleParallelism = function (v) {
      if (v instanceof Single) {
          return 1;
      };
      if (v instanceof After) {
          return Data_Ord.max(Data_Ord.ordInt)(scheduleParallelism(v.value0))(scheduleParallelism(v.value1));
      };
      if (v instanceof Parallel) {
          return scheduleParallelism(v.value0) + scheduleParallelism(v.value1) | 0;
      };
      throw new Error("Failed pattern match at Main (line 60, column 1 - line 60, column 51): " + [ v.constructor.name ]);
  };
  var scheduleEnd = function (v) {
      if (v instanceof Single) {
          return v.value0.end;
      };
      if (v instanceof After) {
          return scheduleEnd(v.value1);
      };
      if (v instanceof Parallel) {
          return Data_Ord.max(Data_JSDate.ordJSDate)(scheduleEnd(v.value0))(scheduleEnd(v.value1));
      };
      throw new Error("Failed pattern match at Main (line 55, column 1 - line 55, column 51): " + [ v.constructor.name ]);
  };
  var scheduleInsert = function (entry) {
      return function (schedule) {
          if (Data_Ord.greaterThanOrEq(Data_JSDate.ordJSDate)(entry.start)(scheduleEnd(schedule))) {
              return new After(schedule, new Single(entry));
          };
          if (Data_Ord.lessThanOrEq(Data_JSDate.ordJSDate)(entry.end)(scheduleStart(schedule))) {
              return new After(new Single(entry), schedule);
          };
          if (Data_Boolean.otherwise) {
              if (schedule instanceof Single) {
                  return new Parallel(new Single(schedule.value0), new Single(entry));
              };
              if (schedule instanceof After && (schedule.value0 instanceof After && Data_Ord.greaterThanOrEq(Data_JSDate.ordJSDate)(entry.start)(scheduleEnd(schedule.value0.value0)))) {
                  return new After(schedule.value0.value0, scheduleInsert(entry)(new After(schedule.value0.value1, schedule.value1)));
              };
              if (schedule instanceof After) {
                  if (Data_Ord.greaterThanOrEq(Data_JSDate.ordJSDate)(entry.start)(scheduleEnd(schedule.value0))) {
                      return new After(schedule.value0, scheduleInsert(entry)(schedule.value1));
                  };
                  if (Data_Ord.lessThanOrEq(Data_JSDate.ordJSDate)(entry.end)(scheduleStart(schedule.value1))) {
                      return new After(scheduleInsert(entry)(schedule.value0), schedule.value1);
                  };
                  if (Data_Boolean.otherwise) {
                      return new Parallel(new After(schedule.value0, schedule.value1), new Single(entry));
                  };
              };
              if (schedule instanceof Parallel) {
                  var y$prime = scheduleInsert(entry)(schedule.value1);
                  var x$prime = scheduleInsert(entry)(schedule.value0);
                  var r = scheduleParallelism(schedule.value0) + scheduleParallelism(y$prime) | 0;
                  var l = scheduleParallelism(x$prime) + scheduleParallelism(schedule.value1) | 0;
                  var $40 = l < r;
                  if ($40) {
                      return new Parallel(x$prime, schedule.value1);
                  };
                  return new Parallel(schedule.value0, y$prime);
              };
              throw new Error("Failed pattern match at Main (line 73, column 19 - line 89, column 59): " + [ schedule.constructor.name ]);
          };
          throw new Error("Failed pattern match at Main (line 67, column 1 - line 67, column 64): " + [ entry.constructor.name, schedule.constructor.name ]);
      };
  };
  var scheduleRender = function (doc) {
      return function (day) {
          return function (schedule0) {
              var zero = scheduleStart(schedule0);
              var ticks = function (date) {
                  return Data_JSDate.getTime(date) / 1000.0 / 60.0;
              };
              var go = function (container) {
                  return function (left) {
                      return function (width) {
                          return function (schedule) {
                              if (schedule instanceof Single) {
                                  var y = (ticks(schedule.value0.start) - ticks(zero)) + Data_Int.toNumber(30);
                                  var height = ticks(schedule.value0.end) - ticks(schedule.value0.start);
                                  return function __do() {
                                      var div = (function () {
                                          var v = Data_String_Common.trim(schedule.value0.content.link);
                                          if (v === "") {
                                              return Web_DOM_Document.createElement("div")(doc)();
                                          };
                                          var a = Web_DOM_Document.createElement("a")(doc)();
                                          Web_DOM_Element.setAttribute("href")(v)(a)();
                                          return a;
                                      })();
                                      Web_DOM_Element.setAttribute("class")("entry " + schedule.value0.content.kind)(div)();
                                      Web_DOM_Element.setAttribute("style")("position: absolute;" + ("top: " + (Data_Show.show(Data_Show.showNumber)(y) + ("px;" + ("left: " + (Data_Show.show(Data_Show.showNumber)(left) + ("%; " + ("width: " + (Data_Show.show(Data_Show.showNumber)(width) + ("%; " + ("height: " + (Data_Show.show(Data_Show.showNumber)(height) + "px;"))))))))))))(div)();
                                      var timeSpan = Web_DOM_Document.createElement("span")(doc)();
                                      Web_DOM_Element.setAttribute("class")("time")(timeSpan)();
                                      var startStr = $foreign.renderDateTime(schedule.value0.start)();
                                      var endStr = $foreign.renderDateTime(schedule.value0.end)();
                                      Web_DOM_Node.setTextContent(startStr + (" - " + (endStr + ":")))(Web_DOM_Element.toNode(timeSpan))();
                                      Web_DOM_Node.appendChild(Web_DOM_Element.toNode(timeSpan))(Web_DOM_Element.toNode(div))();
                                      var titleSpan = Web_DOM_Document.createElement("span")(doc)();
                                      Web_DOM_Element.setAttribute("class")("title")(titleSpan)();
                                      Web_DOM_Node.setTextContent(schedule.value0.content.title)(Web_DOM_Element.toNode(titleSpan))();
                                      Web_DOM_Node.appendChild(Web_DOM_Element.toNode(titleSpan))(Web_DOM_Element.toNode(div))();
                                      return Web_DOM_Node.appendChild(Web_DOM_Element.toNode(div))(Web_DOM_Element.toNode(container))();
                                  };
                              };
                              if (schedule instanceof After) {
                                  return function __do() {
                                      go(container)(left)(width)(schedule.value0)();
                                      return go(container)(left)(width)(schedule.value1)();
                                  };
                              };
                              if (schedule instanceof Parallel) {
                                  var yp = Data_Int.toNumber(scheduleParallelism(schedule.value1));
                                  var xp = Data_Int.toNumber(scheduleParallelism(schedule.value0));
                                  var unitWidth = width / (xp + yp);
                                  return function __do() {
                                      go(container)(left)(xp * unitWidth)(schedule.value0)();
                                      return go(container)(left + xp * unitWidth)(yp * unitWidth)(schedule.value1)();
                                  };
                              };
                              throw new Error("Failed pattern match at Main (line 115, column 40 - line 160, column 68): " + [ schedule.constructor.name ]);
                          };
                      };
                  };
              };
              return function __do() {
                  var container = Web_DOM_Document.createElement("div")(doc)();
                  var start = ticks(scheduleStart(schedule0));
                  var end = ticks(scheduleEnd(schedule0));
                  var height = (end - start) + Data_Int.toNumber(30);
                  Web_DOM_Element.setAttribute("class")("day")(container)();
                  Web_DOM_Element.setAttribute("style")("position: relative; height: " + (Data_Show.show(Data_Show.showNumber)(height) + "px;"))(container)();
                  var div = Web_DOM_Document.createElement("div")(doc)();
                  Web_DOM_Element.setAttribute("class")("date")(div)();
                  Web_DOM_Node.setTextContent(day)(Web_DOM_Element.toNode(div))();
                  Web_DOM_Node.appendChild(Web_DOM_Element.toNode(div))(Web_DOM_Element.toNode(container))();
                  go(container)(0.0)(100.0)(schedule0)();
                  return container;
              };
          };
      };
  };
  var parseEntry = function (element) {
      return function __do() {
          var cells = Control_Bind.bind(Effect.bindEffect)(Control_Bind.bind(Effect.bindEffect)(Control_Bind.bind(Effect.bindEffect)(Web_DOM_ParentNode.querySelectorAll("td")(Web_DOM_Element.toParentNode(element)))(Web_DOM_NodeList.toArray))((function () {
              var $80 = Control_Applicative.pure(Effect.applicativeEffect);
              var $81 = Data_Array.mapMaybe(Web_HTML_HTMLElement.fromNode);
              return function ($82) {
                  return $80($81($82));
              };
          })()))(Data_Traversable.traverse(Data_Traversable.traversableArray)(Effect.applicativeEffect)($foreign.innerText))();
          if (cells.length === 5) {
              var start = Data_JSDate.parse(cells[0])();
              var end = Data_JSDate.parse(cells[1])();
              return new Data_Maybe.Just({
                  start: start,
                  end: end,
                  content: {
                      kind: cells[2],
                      link: cells[3],
                      title: cells[4]
                  }
              });
          };
          return Data_Maybe.Nothing.value;
      };
  };
  var parseEntries = function (schedule) {
      return function __do() {
          var trs = Control_Bind.bind(Effect.bindEffect)(Web_DOM_ParentNode.querySelectorAll("tr")(Web_DOM_Element.toParentNode(schedule)))(Web_DOM_NodeList.toArray)();
          return Data_Functor.map(Effect.functorEffect)(Data_Array.catMaybes)(Data_Traversable.traverse(Data_Traversable.traversableArray)(Effect.applicativeEffect)(parseEntry)(Data_Array.mapMaybe(Web_DOM_Element.fromNode)(trs)))();
      };
  };
  var genericSchedule = new Data_Generic_Rep.Generic(function (x) {
      if (x instanceof Single) {
          return new Data_Generic_Rep.Inl(x.value0);
      };
      if (x instanceof After) {
          return new Data_Generic_Rep.Inr(new Data_Generic_Rep.Inl(new Data_Generic_Rep.Product(x.value0, x.value1)));
      };
      if (x instanceof Parallel) {
          return new Data_Generic_Rep.Inr(new Data_Generic_Rep.Inr(new Data_Generic_Rep.Product(x.value0, x.value1)));
      };
      throw new Error("Failed pattern match at Main (line 45, column 1 - line 45, column 58): " + [ x.constructor.name ]);
  }, function (x) {
      if (x instanceof Data_Generic_Rep.Inl) {
          return new Single(x.value0);
      };
      if (x instanceof Data_Generic_Rep.Inr && x.value0 instanceof Data_Generic_Rep.Inl) {
          return new After(x.value0.value0.value0, x.value0.value0.value1);
      };
      if (x instanceof Data_Generic_Rep.Inr && x.value0 instanceof Data_Generic_Rep.Inr) {
          return new Parallel(x.value0.value0.value0, x.value0.value0.value1);
      };
      throw new Error("Failed pattern match at Main (line 45, column 1 - line 45, column 58): " + [ x.constructor.name ]);
  });
  var showSchedule = function (dictShow) {
      return new Data_Show.Show(function (x) {
          return Data_Show_Generic.genericShow(genericSchedule)(Data_Show_Generic.genericShowSum(Data_Show_Generic.genericShowConstructor(Data_Show_Generic.genericShowArgsArgument(Data_Show.showRecord()(Data_Show.showRecordFieldsCons(new Data_Symbol.IsSymbol(function () {
              return "content";
          }))(Data_Show.showRecordFieldsCons(new Data_Symbol.IsSymbol(function () {
              return "end";
          }))(Data_Show.showRecordFieldsCons(new Data_Symbol.IsSymbol(function () {
              return "start";
          }))(Data_Show.showRecordFieldsNil)(Data_JSDate.showJSDate))(Data_JSDate.showJSDate))(dictShow))))(new Data_Symbol.IsSymbol(function () {
              return "Single";
          })))(Data_Show_Generic.genericShowSum(Data_Show_Generic.genericShowConstructor(Data_Show_Generic.genericShowArgsProduct(Data_Show_Generic.genericShowArgsArgument(showSchedule(dictShow)))(Data_Show_Generic.genericShowArgsArgument(showSchedule(dictShow))))(new Data_Symbol.IsSymbol(function () {
              return "After";
          })))(Data_Show_Generic.genericShowConstructor(Data_Show_Generic.genericShowArgsProduct(Data_Show_Generic.genericShowArgsArgument(showSchedule(dictShow)))(Data_Show_Generic.genericShowArgsArgument(showSchedule(dictShow))))(new Data_Symbol.IsSymbol(function () {
              return "Parallel";
          })))))(x);
      });
  };
  var calendarRender = function (doc) {
      return function (calendar) {
          return Data_Traversable.traverse(Data_Traversable.traversableArray)(Effect.applicativeEffect)(Data_Tuple.uncurry(scheduleRender(doc)))(Data_Array.sortWith(Data_JSDate.ordJSDate)(function ($83) {
              return scheduleStart(Data_Tuple.snd($83));
          })(Data_HashMap.toArrayBy(Data_Tuple.Tuple.create)(calendar)));
      };
  };
  var calendarInsert = function (entry) {
      return function (calendar) {
          var day = Data_JSDate.toDateString(entry.start);
          var v = Data_HashMap.lookup(Data_Hashable.hashableString)(day)(calendar);
          if (v instanceof Data_Maybe.Nothing) {
              return Data_HashMap.insert(Data_Hashable.hashableString)(day)(new Single(entry))(calendar);
          };
          if (v instanceof Data_Maybe.Just) {
              return Data_HashMap.insert(Data_Hashable.hashableString)(day)(scheduleInsert(entry)(v.value0))(calendar);
          };
          throw new Error("Failed pattern match at Main (line 170, column 33 - line 172, column 72): " + [ v.constructor.name ]);
      };
  };
  var calendarFromEntries = Data_Array.foldl(Data_Function.flip(calendarInsert))(Data_HashMap.empty);
  var main = function __do() {
      var window = Web_HTML.window();
      var doc = Web_HTML_Window.document(window)();
      var schedule = Control_Bind.bind(Effect.bindEffect)(Web_DOM_ParentNode.querySelector(".schedule")(Web_HTML_HTMLDocument.toParentNode(doc)))(Data_Maybe.maybe(Effect_Exception["throw"]("no schedule"))(Control_Applicative.pure(Effect.applicativeEffect)))();
      var calendar = Data_Functor.map(Effect.functorEffect)(calendarFromEntries)(parseEntries(schedule))();
      Control_Bind.bind(Effect.bindEffect)(Control_Bind.bind(Effect.bindEffect)(Web_DOM_ParentNode.children(Web_DOM_Element.toParentNode(schedule)))(Web_DOM_HTMLCollection.toArray))(Data_Foldable.traverse_(Effect.applicativeEffect)(Data_Foldable.foldableArray)(function ($84) {
          return Web_DOM_ChildNode.remove(Web_DOM_Element.toChildNode($84));
      }))();
      var rendered = calendarRender(Web_HTML_HTMLDocument.toDocument(doc))(calendar)();
      return Data_Foldable.for_(Effect.applicativeEffect)(Data_Foldable.foldableArray)(rendered)(function (c) {
          return Web_DOM_Node.appendChild(Web_DOM_Element.toNode(c))(Web_DOM_Element.toNode(schedule));
      })();
  };
  exports["Single"] = Single;
  exports["After"] = After;
  exports["Parallel"] = Parallel;
  exports["scheduleStart"] = scheduleStart;
  exports["scheduleEnd"] = scheduleEnd;
  exports["scheduleParallelism"] = scheduleParallelism;
  exports["scheduleInsert"] = scheduleInsert;
  exports["scheduleRender"] = scheduleRender;
  exports["calendarInsert"] = calendarInsert;
  exports["calendarFromEntries"] = calendarFromEntries;
  exports["calendarRender"] = calendarRender;
  exports["parseEntry"] = parseEntry;
  exports["parseEntries"] = parseEntries;
  exports["main"] = main;
  exports["genericSchedule"] = genericSchedule;
  exports["showSchedule"] = showSchedule;
  exports["innerText"] = $foreign.innerText;
  exports["renderDateTime"] = $foreign.renderDateTime;
})(PS);
PS["Main"].main();
</script>

  </main>

  <footer>
    Copyright © 2018 - 2025 Zürich Friends of Haskell ·
    <a href="https://github.com/zfoh/zfoh.ch">Source code available</a>
    ·
    <a href="/terms-and-conditions.html">Terms and Conditions</a>
    ·
    <a href="/privacy-policy.html">Privacy Policy</a>
    <br>
    Header image modified from <a href="https://openclipart.org/favs/306465/simple-nature-banner">artwork by j4p4n on
    openclipart</a>.
  </footer>
</body>

</html>
